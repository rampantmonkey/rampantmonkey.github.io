:title One Time Passwords
:description Releasing version one of my one time password generator
:date 2014-12-15
:slug one-time-passwords


<p><a href="http://en.wikipedia.org/wiki/Two_factor_authentication">Two factor authentication</a> has become commonplace amongst the multitude of web services I use on a daily basis.
The goal of two factor authentication is to increase security by requiring two pieces of information to authorize yourself.
First you use the traditional username/password combination to establish identity.
Then you use a second, time sensitive code.
This code is delivered by text message or generated by using an authenticator application.</p>

<p>To amuse myself, and reduce my dependence on my phone, I decided to implement <a href="onetime.go">my own one time password generator</a>.
Of course it will be a command line application implemented in <a href="https://golang.org/">go</a>.
Let&#39;s look at the most common application - <a href="https://github.com/google/google-authenticator">Google Authenticator</a> - for inspiration.
This screenshot taken on my iPhone shows three accounts and their respective codes.<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>
Each account has a code and a countdown timer (shown as a circular progress meter).
The goal: reproduce the same code and same timing for each account.
<img src="/media/google_authenticator_screenshot.png" alt="google authenticator screenshot"></p>

<p>The first step is to research the algorithm used.
<a href="http://en.wikipedia.org/wiki/Google_Authenticator">Wikipedia</a> provides a brief overview and a link to the <a href="https://www.ietf.org/rfc/rfc6238.txt">RFC (#6238)</a>.
The algorithm used is called Time OTP, or TOTP.
TOTP takes one input, a secret string.<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>
The secret string is then hashed<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup> with the current unix time<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>.
The output is then truncated, modded, and padded to return a 6 digit code.
That covers the criteria for generating a single code.
What about one for every site?</p>

<p>Run the algorithm multiple times - once for each site.
Done.
Well, not quite.
We want to display the time remaining for each code in place to avoid scrolling.
The terminal provides a mechanism for this exact scenario - escape codes.</p>

<p><a href="http://en.wikipedia.org/wiki/ANSI_escape_code">Terminal escape codes</a> are a string of characters, from stdout, that are interpreted by the terminal as behavior rather than displayed to the user.
For example, coloring text can be done with terminal escape codes.
<code>echo &quot;this is \x1b[0;32mgreen\x1b[0m text&quot;</code><sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup>
Aside from color, and more relevant to this project, are the collection of escape codes for moving the cursor and clearing text.
Two are of particular interest - move cursor up (<code>\0x1b[A</code>) and clear current line(<code>\0x1b[2k</code>).<sup id="fnref6"><a href="#fn6" rel="footnote">6</a></sup></p>

<p>Every half second I clear the output and redraw<sup id="fnref7"><a href="#fn7" rel="footnote">7</a></sup>.
After a draw the cursor sits at the beginning of the next line.
To clear the output move the cursor up and clear the current line.
Repeat <code>len(sites)</code> times.</p>

<p>Since TOTP is time sensitive a token generator can be frustrating to debug.
Essentially, the clocks have to be in sync on both the server side and the authenticator application side.
Otherwise, the tokens would not match and login would fail.
A handy tool for this (at least on linux) is <a href="http://www.ntp.org/">NTP</a><sup id="fnref8"><a href="#fn8" rel="footnote">8</a></sup>.
In my case the clocks were out of sync by 40 seconds.
This was the most frustrating part.
Since the time difference was only slightly longer than the token lifetime I would occasionally see correct tokens further back in the output<sup id="fnref9"><a href="#fn9" rel="footnote">9</a></sup>.
Long story short, time is hard.</p>

<p>When I started this project I only expected to learn about a hash function.
NTP, base32 encoding, and terminal escape codes are three tools that were previously mysterious but crucial to implementing onetime.
Overall, I would call it a success.
There are still many areas to explore in the future (profiling memory usage, cross platform testing, output to file instead of terminal, ...).</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Don&#39;t worry, they are generated from old secrets. No security issue here.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>The secret is encoded in base32. Some sites (looking at you Hover) decide to provide a key with an odd number of characters. be sure to pad it with &#39;=&#39;.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>Google Authenticator uses <a href="https://www.ietf.org/rfc/rfc2104.txt">HMAC-SHA1</a>.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>Well, the time is computed as number of 30 second periods since the Unix Epoch for UI. It would be hard to copy and paste if the code was valid for only one second.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

<li id="fn5">
<p>Run it in a VT/100 compatible terminal.&nbsp;<a href="#fnref5" rev="footnote">&#8617;</a></p>
</li>

<li id="fn6">
<p><code>\0x1b</code> is the hex literal for <code>ESC</code> (keycode 27).&nbsp;<a href="#fnref6" rev="footnote">&#8617;</a></p>
</li>

<li id="fn7">
<p>Half second redraw time instead of second to reduce timing inaccuracies.&nbsp;<a href="#fnref7" rev="footnote">&#8617;</a></p>
</li>

<li id="fn8">
<p>This protocol is on the implementation list.&nbsp;<a href="#fnref8" rev="footnote">&#8617;</a></p>
</li>

<li id="fn9">
<p>This was ultimately the clue to fixing it.&nbsp;<a href="#fnref9" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
