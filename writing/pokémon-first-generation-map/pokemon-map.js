(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // src/locations.json
  var require_locations = __commonJS({
    "src/locations.json"(exports, module) {
      module.exports = [{ CONSTANT_NAME: "PALLET_TOWN", height: 9, width: 10, id: "00", Name: "PalletTown", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_1", offset: 0 }, south: { destination: "ROUTE_21", offset: 0 } }, warps: [{ row: "5", col: "5", dest: "REDS_HOUSE_1F", src: "PALLET_TOWN" }, { row: "13", col: "5", dest: "BLUES_HOUSE", src: "PALLET_TOWN" }, { row: "12", col: "11", dest: "OAKS_LAB", src: "PALLET_TOWN" }], mapData: { type: "Buffer", data: [82, 79, 82, 82, 79, 11, 80, 82, 82, 80, 78, 1, 56, 57, 1, 1, 56, 57, 1, 77, 78, 8, 60, 61, 1, 8, 60, 61, 1, 77, 78, 1, 1, 1, 1, 1, 1, 1, 1, 77, 78, 1, 119, 86, 1, 12, 13, 14, 1, 77, 78, 1, 116, 116, 1, 16, 58, 0, 1, 77, 78, 1, 1, 1, 1, 119, 86, 119, 49, 77, 78, 10, 29, 30, 49, 116, 116, 10, 49, 77, 80, 10, 101, 100, 97, 97, 97, 97, 97, 79] } }, { CONSTANT_NAME: "VIRIDIAN_CITY", height: 18, width: 20, id: "01", Name: "ViridianCity", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_2", offset: 5 }, south: { destination: "ROUTE_1", offset: 5 }, west: { destination: "ROUTE_22", offset: 4 } }, warps: [{ row: "23", col: "25", dest: "VIRIDIAN_POKECENTER", src: "VIRIDIAN_CITY" }, { row: "29", col: "19", dest: "VIRIDIAN_MART", src: "VIRIDIAN_CITY" }, { row: "21", col: "15", dest: "VIRIDIAN_SCHOOL_HOUSE", src: "VIRIDIAN_CITY" }, { row: "21", col: "9", dest: "VIRIDIAN_NICKNAME_HOUSE", src: "VIRIDIAN_CITY" }, { row: "32", col: "7", dest: "VIRIDIAN_GYM", src: "VIRIDIAN_CITY" }], mapData: { type: "Buffer", data: [44, 44, 41, 15, 15, 15, 15, 15, 27, 8, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 44, 44, 41, 15, 15, 15, 15, 15, 27, 1, 15, 15, 49, 49, 49, 49, 49, 49, 15, 15, 44, 44, 41, 10, 82, 82, 82, 52, 1, 1, 1, 49, 49, 49, 12, 13, 14, 49, 15, 15, 44, 44, 41, 77, 15, 15, 15, 15, 27, 1, 27, 49, 49, 8, 16, 17, 18, 49, 15, 15, 44, 44, 41, 77, 15, 15, 15, 15, 27, 1, 2, 3, 26, 26, 7, 7, 7, 26, 15, 15, 44, 44, 41, 77, 15, 15, 15, 15, 27, 1, 1, 1, 1, 1, 1, 1, 1, 49, 15, 15, 87, 87, 37, 77, 15, 15, 15, 15, 27, 1, 119, 119, 119, 119, 119, 119, 119, 119, 15, 15, 10, 10, 10, 77, 15, 15, 15, 15, 27, 1, 2, 3, 1, 1, 1, 1, 1, 1, 15, 15, 49, 1, 1, 10, 108, 108, 108, 108, 8, 1, 119, 119, 1, 10, 32, 33, 10, 1, 15, 15, 63, 59, 1, 1, 1, 1, 1, 1, 1, 1, 116, 116, 1, 10, 124, 115, 10, 1, 15, 15, 44, 41, 28, 111, 10, 10, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 15, 44, 41, 1, 10, 52, 116, 116, 10, 1, 116, 1, 32, 33, 1, 116, 10, 10, 1, 15, 15, 44, 41, 1, 10, 29, 31, 30, 10, 1, 10, 1, 124, 114, 1, 10, 10, 116, 1, 15, 15, 87, 37, 26, 7, 101, 67, 100, 47, 26, 47, 26, 26, 26, 26, 26, 26, 26, 26, 15, 15, 10, 77, 1, 116, 10, 10, 10, 10, 1, 10, 8, 10, 116, 116, 1, 116, 116, 1, 15, 15, 10, 77, 119, 119, 119, 119, 119, 119, 119, 119, 1, 119, 119, 119, 119, 119, 119, 119, 15, 15, 10, 10, 10, 10, 10, 10, 77, 10, 10, 77, 1, 78, 10, 10, 78, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 77, 10, 10, 77, 1, 78, 10, 10, 78, 10, 10, 10, 10, 10] } }, { CONSTANT_NAME: "PEWTER_CITY", height: 18, width: 20, id: "02", Name: "PewterCity", blockset: "OVERWORLD", connections: { south: { destination: "ROUTE_2", offset: 5 }, east: { destination: "ROUTE_3", offset: 4 } }, warps: [{ row: "14", col: "7", dest: "MUSEUM_1F", src: "PEWTER_CITY" }, { row: "19", col: "5", dest: "MUSEUM_1F", src: "PEWTER_CITY" }, { row: "16", col: "17", dest: "PEWTER_GYM", src: "PEWTER_CITY" }, { row: "29", col: "13", dest: "PEWTER_NIDORAN_HOUSE", src: "PEWTER_CITY" }, { row: "23", col: "17", dest: "PEWTER_MART", src: "PEWTER_CITY" }, { row: "7", col: "29", dest: "PEWTER_SPEECH_HOUSE", src: "PEWTER_CITY" }, { row: "13", col: "25", dest: "PEWTER_POKECENTER", src: "PEWTER_CITY" }], mapData: { type: "Buffer", data: [10, 10, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 111, 111, 111, 63, 59, 1, 116, 116, 12, 13, 13, 14, 32, 13, 33, 111, 111, 10, 116, 116, 110, 15, 15, 44, 41, 1, 116, 116, 117, 113, 113, 118, 124, 125, 126, 10, 52, 10, 116, 116, 110, 15, 15, 44, 41, 26, 47, 7, 55, 125, 58, 126, 26, 7, 7, 7, 66, 7, 47, 7, 66, 15, 15, 44, 41, 1, 1, 1, 1, 1, 8, 1, 1, 10, 10, 10, 10, 10, 10, 10, 110, 15, 15, 44, 41, 1, 116, 116, 116, 116, 116, 116, 1, 1, 1, 1, 1, 1, 1, 1, 62, 63, 63, 44, 41, 1, 1, 1, 1, 1, 1, 1, 1, 10, 10, 10, 10, 2, 3, 1, 40, 44, 44, 44, 41, 1, 10, 10, 1, 12, 13, 14, 1, 1, 32, 33, 1, 1, 1, 1, 36, 87, 87, 44, 41, 1, 10, 10, 8, 16, 17, 18, 1, 10, 124, 115, 10, 10, 10, 1, 1, 1, 1, 44, 41, 1, 1, 1, 1, 1, 1, 1, 27, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 44, 41, 28, 111, 111, 28, 111, 111, 111, 27, 10, 10, 10, 10, 10, 10, 1, 62, 63, 63, 44, 41, 1, 1, 1, 1, 32, 33, 1, 1, 49, 119, 86, 119, 119, 49, 1, 40, 44, 44, 44, 41, 1, 10, 10, 10, 124, 114, 116, 1, 110, 116, 116, 116, 116, 109, 1, 36, 87, 87, 44, 41, 1, 1, 1, 1, 1, 1, 1, 1, 110, 116, 116, 116, 116, 109, 1, 77, 10, 10, 43, 37, 1, 2, 3, 116, 10, 10, 10, 8, 110, 7, 47, 7, 7, 109, 1, 77, 10, 10, 41, 19, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 77, 10, 10, 37, 81, 81, 81, 81, 81, 15, 15, 15, 1, 15, 15, 15, 81, 81, 81, 81, 81, 10, 10, 10, 10, 10, 10, 10, 10, 15, 15, 15, 1, 15, 15, 15, 10, 10, 10, 10, 10, 10, 10] } }, { CONSTANT_NAME: "CERULEAN_CITY", height: 18, width: 20, id: "03", Name: "CeruleanCity", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_24", offset: 5 }, south: { destination: "ROUTE_5", offset: 5 }, west: { destination: "ROUTE_4", offset: 4 }, east: { destination: "ROUTE_9", offset: 4 } }, warps: [{ row: "27", col: "11", dest: "CERULEAN_TRASHED_HOUSE", src: "CERULEAN_CITY" }, { row: "13", col: "15", dest: "CERULEAN_TRADE_HOUSE", src: "CERULEAN_CITY" }, { row: "19", col: "17", dest: "CERULEAN_POKECENTER", src: "CERULEAN_CITY" }, { row: "30", col: "19", dest: "CERULEAN_GYM", src: "CERULEAN_CITY" }, { row: "13", col: "25", dest: "BIKE_SHOP", src: "CERULEAN_CITY" }, { row: "25", col: "25", dest: "CERULEAN_MART", src: "CERULEAN_CITY" }, { row: "4", col: "11", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CITY" }, { row: "27", col: "9", dest: "CERULEAN_TRASHED_HOUSE", src: "CERULEAN_CITY" }, { row: "9", col: "11", dest: "CERULEAN_BADGE_HOUSE", src: "CERULEAN_CITY" }, { row: "9", col: "9", dest: "CERULEAN_BADGE_HOUSE", src: "CERULEAN_CITY" }], mapData: { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 41, 67, 67, 25, 84, 78, 10, 24, 67, 67, 67, 67, 67, 67, 44, 44, 43, 87, 87, 87, 37, 67, 67, 25, 84, 80, 7, 24, 67, 67, 67, 67, 67, 67, 44, 44, 41, 67, 67, 67, 67, 67, 67, 25, 10, 78, 10, 24, 67, 67, 67, 67, 67, 67, 44, 44, 41, 25, 108, 108, 108, 108, 108, 54, 10, 109, 110, 108, 108, 108, 108, 15, 15, 109, 44, 44, 41, 25, 85, 85, 85, 85, 85, 110, 10, 109, 110, 85, 85, 85, 85, 15, 15, 109, 87, 87, 112, 25, 2, 9, 3, 48, 9, 3, 1, 1, 1, 2, 9, 3, 1, 48, 9, 3, 49, 49, 49, 25, 1, 1, 1, 1, 1, 1, 1, 10, 1, 10, 10, 10, 27, 10, 10, 78, 31, 31, 31, 25, 92, 7, 2, 9, 3, 32, 33, 10, 1, 1, 1, 1, 27, 1, 1, 80, 107, 107, 107, 21, 1, 10, 10, 10, 10, 124, 114, 7, 12, 13, 13, 14, 1, 10, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 16, 17, 17, 18, 26, 47, 92, 98, 81, 81, 78, 1, 10, 116, 116, 116, 116, 116, 116, 1, 1, 8, 49, 49, 49, 95, 1, 78, 116, 116, 78, 1, 1, 1, 32, 33, 1, 1, 1, 1, 32, 33, 116, 116, 116, 95, 1, 78, 116, 116, 78, 1, 10, 86, 124, 126, 1, 48, 9, 3, 124, 115, 48, 9, 3, 95, 1, 78, 116, 116, 78, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 95, 1, 78, 116, 116, 98, 108, 108, 108, 108, 54, 86, 50, 108, 108, 108, 108, 108, 108, 108, 108, 1, 78, 116, 116, 78, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 78, 116, 116, 80, 82, 82, 109, 93, 110, 7, 7, 7, 7, 78, 93, 77, 82, 82, 82, 82, 78, 116, 116, 116, 116, 116, 109, 39, 110, 10, 10, 10, 10, 78, 39, 77, 116, 116, 116, 116, 116] } }, { CONSTANT_NAME: "LAVENDER_TOWN", height: 9, width: 10, id: "04", Name: "LavenderTown", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_10", offset: 0 }, south: { destination: "ROUTE_12", offset: 0 }, west: { destination: "ROUTE_8", offset: 0 } }, warps: [{ row: "3", col: "5", dest: "LAVENDER_POKECENTER", src: "LAVENDER_TOWN" }, { row: "14", col: "5", dest: "POKEMON_TOWER_1F", src: "LAVENDER_TOWN" }, { row: "7", col: "9", dest: "MR_FUJIS_HOUSE", src: "LAVENDER_TOWN" }, { row: "15", col: "13", dest: "LAVENDER_MART", src: "LAVENDER_TOWN" }, { row: "3", col: "13", dest: "LAVENDER_CUBONE_HOUSE", src: "LAVENDER_TOWN" }, { row: "7", col: "13", dest: "NAME_RATERS_HOUSE", src: "LAVENDER_TOWN" }], mapData: { type: "Buffer", data: [87, 87, 37, 123, 123, 40, 104, 127, 105, 44, 123, 32, 33, 123, 121, 40, 55, 125, 126, 44, 123, 124, 114, 123, 123, 36, 87, 6, 87, 42, 123, 123, 123, 123, 123, 123, 123, 123, 121, 40, 123, 123, 121, 2, 3, 121, 123, 123, 123, 40, 123, 123, 123, 123, 123, 123, 123, 32, 33, 40, 123, 2, 3, 2, 3, 123, 123, 124, 115, 40, 123, 123, 123, 123, 123, 123, 123, 123, 123, 40, 63, 63, 63, 59, 123, 62, 63, 63, 63, 44] } }, { CONSTANT_NAME: "VERMILION_CITY", height: 18, width: 20, id: "05", Name: "VermilionCity", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_6", offset: 5 }, east: { destination: "ROUTE_11", offset: 4 } }, warps: [{ row: "11", col: "3", dest: "VERMILION_POKECENTER", src: "VERMILION_CITY" }, { row: "9", col: "13", dest: "POKEMON_FAN_CLUB", src: "VERMILION_CITY" }, { row: "23", col: "13", dest: "VERMILION_MART", src: "VERMILION_CITY" }, { row: "12", col: "19", dest: "VERMILION_GYM", src: "VERMILION_CITY" }, { row: "23", col: "19", dest: "VERMILION_PIDGEY_HOUSE", src: "VERMILION_CITY" }, { row: "18", col: "31", dest: "VERMILION_DOCK", src: "VERMILION_CITY" }, { row: "19", col: "31", dest: "VERMILION_DOCK", src: "VERMILION_CITY" }, { row: "15", col: "13", dest: "VERMILION_TRADE_HOUSE", src: "VERMILION_CITY" }, { row: "7", col: "3", dest: "VERMILION_OLD_ROD_HOUSE", src: "VERMILION_CITY" }], mapData: { type: "Buffer", data: [67, 67, 67, 32, 33, 32, 33, 32, 33, 49, 32, 33, 49, 49, 49, 49, 49, 49, 49, 49, 67, 107, 107, 124, 126, 124, 114, 55, 126, 49, 55, 126, 119, 86, 119, 119, 119, 49, 49, 49, 25, 67, 100, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 27, 49, 49, 25, 67, 45, 31, 30, 49, 49, 49, 49, 49, 49, 49, 49, 49, 73, 72, 49, 27, 49, 49, 25, 67, 67, 67, 45, 31, 31, 30, 49, 49, 49, 49, 49, 49, 68, 69, 49, 27, 49, 49, 25, 67, 67, 67, 32, 33, 67, 32, 33, 49, 49, 32, 33, 49, 49, 49, 49, 27, 49, 49, 25, 67, 100, 8, 124, 126, 49, 124, 126, 49, 49, 124, 115, 119, 119, 119, 119, 19, 86, 119, 25, 67, 100, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 8, 49, 49, 49, 49, 49, 25, 67, 100, 49, 12, 13, 14, 49, 49, 49, 49, 32, 33, 29, 30, 84, 29, 31, 31, 31, 25, 67, 100, 86, 16, 17, 18, 53, 29, 30, 49, 124, 126, 101, 100, 84, 101, 67, 67, 67, 25, 67, 100, 49, 49, 49, 49, 49, 101, 100, 49, 49, 49, 101, 45, 84, 46, 67, 67, 67, 25, 67, 100, 49, 49, 49, 49, 49, 101, 45, 31, 31, 31, 46, 67, 84, 67, 100, 15, 15, 25, 67, 45, 31, 31, 31, 31, 31, 46, 67, 67, 67, 67, 67, 67, 84, 67, 100, 15, 15, 25, 67, 67, 67, 67, 67, 67, 67, 67, 84, 84, 84, 84, 84, 84, 84, 67, 45, 103, 31, 25, 67, 67, 67, 67, 67, 67, 67, 67, 84, 120, 120, 120, 120, 120, 120, 67, 67, 24, 67, 25, 107, 107, 107, 107, 107, 107, 107, 19, 84, 19, 107, 107, 107, 107, 107, 107, 107, 24, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 5, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 84, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67] } }, { CONSTANT_NAME: "CELADON_CITY", height: 18, width: 25, id: "06", Name: "CeladonCity", blockset: "OVERWORLD", connections: { west: { destination: "ROUTE_16", offset: 4 }, east: { destination: "ROUTE_7", offset: 4 } }, warps: [{ row: "8", col: "13", dest: "CELADON_MART_1F", src: "CELADON_CITY" }, { row: "10", col: "13", dest: "CELADON_MART_1F", src: "CELADON_CITY" }, { row: "24", col: "9", dest: "CELADON_MANSION_1F", src: "CELADON_CITY" }, { row: "24", col: "3", dest: "CELADON_MANSION_1F", src: "CELADON_CITY" }, { row: "25", col: "3", dest: "CELADON_MANSION_1F", src: "CELADON_CITY" }, { row: "41", col: "9", dest: "CELADON_POKECENTER", src: "CELADON_CITY" }, { row: "12", col: "27", dest: "CELADON_GYM", src: "CELADON_CITY" }, { row: "28", col: "19", dest: "GAME_CORNER", src: "CELADON_CITY" }, { row: "39", col: "19", dest: "CELADON_MART_5F", src: "CELADON_CITY" }, { row: "33", col: "19", dest: "GAME_CORNER_PRIZE_ROOM", src: "CELADON_CITY" }, { row: "31", col: "27", dest: "CELADON_DINER", src: "CELADON_CITY" }, { row: "35", col: "27", dest: "CELADON_CHIEF_HOUSE", src: "CELADON_CITY" }, { row: "43", col: "27", dest: "CELADON_HOTEL", src: "CELADON_CITY" }], mapData: { type: "Buffer", data: [15, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 15, 15, 10, 10, 10, 10, 10, 10, 10, 10, 10, 111, 111, 10, 111, 111, 111, 10, 111, 111, 111, 111, 111, 111, 10, 110, 15, 32, 33, 85, 85, 85, 85, 32, 13, 33, 85, 32, 13, 33, 85, 85, 85, 85, 85, 85, 85, 85, 85, 109, 110, 15, 104, 105, 32, 13, 13, 33, 104, 127, 105, 85, 104, 127, 105, 32, 33, 32, 33, 32, 33, 32, 33, 85, 109, 110, 15, 55, 126, 104, 127, 127, 105, 55, 125, 126, 121, 55, 58, 126, 55, 126, 55, 126, 55, 126, 124, 114, 85, 15, 15, 15, 85, 85, 104, 127, 127, 105, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 15, 85, 85, 55, 58, 58, 115, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 15, 15, 15, 85, 85, 85, 85, 85, 85, 85, 85, 121, 48, 9, 3, 86, 119, 119, 119, 119, 85, 119, 119, 119, 119, 15, 15, 15, 85, 85, 85, 85, 85, 85, 85, 85, 85, 78, 84, 77, 32, 13, 33, 32, 33, 85, 32, 33, 32, 33, 15, 110, 119, 85, 85, 85, 85, 85, 85, 85, 85, 85, 103, 31, 106, 55, 58, 126, 124, 126, 85, 55, 126, 55, 126, 15, 110, 15, 85, 85, 85, 85, 85, 85, 85, 85, 85, 24, 67, 25, 86, 119, 119, 86, 119, 85, 86, 119, 119, 119, 53, 110, 15, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 109, 110, 15, 32, 33, 12, 13, 13, 14, 32, 33, 32, 33, 85, 85, 32, 33, 32, 33, 32, 33, 32, 33, 32, 33, 10, 110, 15, 55, 126, 16, 17, 17, 18, 55, 126, 55, 126, 85, 85, 55, 126, 124, 126, 124, 126, 55, 126, 124, 126, 10, 110, 15, 85, 85, 85, 85, 85, 121, 85, 85, 32, 33, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 10, 110, 15, 7, 47, 7, 7, 7, 7, 7, 7, 55, 126, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 10, 110, 15, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 108, 108, 108, 108, 108, 108, 50, 54, 108, 108, 108, 108, 10, 110, 15, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 54, 111, 111, 111, 111, 111, 15] } }, { CONSTANT_NAME: "FUCHSIA_CITY", height: 18, width: 20, id: "07", Name: "FuchsiaCity", blockset: "OVERWORLD", connections: { south: { destination: "ROUTE_19", offset: 5 }, west: { destination: "ROUTE_18", offset: 4 }, east: { destination: "ROUTE_15", offset: 4 } }, warps: [{ row: "5", col: "13", dest: "FUCHSIA_MART", src: "FUCHSIA_CITY" }, { row: "11", col: "27", dest: "FUCHSIA_BILLS_GRANDPAS_HOUSE", src: "FUCHSIA_CITY" }, { row: "19", col: "27", dest: "FUCHSIA_POKECENTER", src: "FUCHSIA_CITY" }, { row: "27", col: "27", dest: "WARDENS_HOUSE", src: "FUCHSIA_CITY" }, { row: "18", col: "3", dest: "SAFARI_ZONE_GATE", src: "FUCHSIA_CITY" }, { row: "5", col: "27", dest: "FUCHSIA_GYM", src: "FUCHSIA_CITY" }, { row: "22", col: "13", dest: "FUCHSIA_MEETING_ROOM", src: "FUCHSIA_CITY" }, { row: "31", col: "27", dest: "FUCHSIA_GOOD_ROD_HOUSE", src: "FUCHSIA_CITY" }, { row: "31", col: "24", dest: "FUCHSIA_GOOD_ROD_HOUSE", src: "FUCHSIA_CITY" }], mapData: { type: "Buffer", data: [15, 15, 15, 15, 15, 15, 15, 15, 32, 13, 33, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 122, 111, 111, 111, 111, 111, 122, 55, 58, 126, 122, 111, 111, 111, 111, 111, 111, 122, 15, 15, 110, 29, 30, 15, 116, 116, 109, 86, 85, 119, 110, 1, 1, 15, 1, 1, 1, 109, 15, 15, 110, 119, 86, 15, 119, 86, 109, 122, 111, 111, 96, 119, 86, 15, 119, 86, 119, 109, 15, 15, 122, 122, 122, 122, 122, 122, 122, 110, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 15, 15, 122, 32, 33, 111, 111, 111, 111, 96, 122, 32, 13, 33, 110, 108, 108, 108, 109, 122, 15, 15, 122, 124, 115, 122, 122, 122, 122, 122, 122, 55, 58, 126, 96, 119, 86, 119, 109, 122, 15, 15, 111, 111, 111, 111, 111, 121, 122, 122, 110, 86, 85, 86, 122, 122, 122, 122, 122, 111, 15, 1, 1, 103, 31, 31, 31, 109, 122, 122, 110, 1, 85, 1, 108, 108, 108, 108, 108, 49, 49, 78, 1, 20, 107, 107, 107, 80, 82, 82, 96, 1, 85, 1, 119, 119, 119, 119, 49, 49, 15, 78, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 85, 95, 116, 29, 31, 30, 27, 110, 15, 78, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 59, 95, 116, 10, 10, 10, 27, 110, 15, 78, 36, 32, 13, 33, 87, 87, 87, 87, 32, 33, 37, 95, 56, 57, 56, 57, 27, 110, 15, 78, 88, 124, 17, 126, 2, 3, 48, 3, 124, 114, 89, 49, 60, 61, 60, 61, 49, 110, 15, 78, 88, 8, 49, 49, 49, 49, 49, 49, 49, 49, 89, 95, 86, 119, 49, 119, 27, 110, 15, 78, 90, 7, 7, 92, 111, 111, 111, 92, 7, 7, 91, 1, 1, 1, 1, 49, 49, 110, 15, 80, 82, 82, 82, 82, 62, 63, 59, 116, 116, 116, 116, 80, 82, 82, 82, 82, 82, 110, 15, 49, 49, 49, 49, 49, 40, 44, 41, 49, 49, 49, 49, 62, 63, 59, 15, 15, 15, 15, 15] } }, { CONSTANT_NAME: "CINNABAR_ISLAND", height: 9, width: 10, id: "08", Name: "CinnabarIsland", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_21", offset: 0 }, east: { destination: "ROUTE_20", offset: 0 } }, warps: [{ row: "6", col: "3", dest: "POKEMON_MANSION_1F", src: "CINNABAR_ISLAND" }, { row: "18", col: "3", dest: "CINNABAR_GYM", src: "CINNABAR_ISLAND" }, { row: "6", col: "9", dest: "CINNABAR_LAB", src: "CINNABAR_ISLAND" }, { row: "11", col: "11", dest: "CINNABAR_POKECENTER", src: "CINNABAR_ISLAND" }, { row: "15", col: "11", dest: "CINNABAR_MART", src: "CINNABAR_ISLAND" }], mapData: { type: "Buffer", data: [24, 100, 32, 13, 33, 123, 123, 12, 13, 14, 24, 100, 55, 58, 126, 123, 121, 16, 17, 18, 24, 100, 123, 123, 121, 123, 123, 123, 123, 123, 24, 100, 32, 13, 33, 123, 123, 123, 123, 123, 24, 100, 55, 58, 126, 32, 33, 32, 33, 123, 24, 100, 123, 123, 121, 124, 114, 124, 115, 123, 24, 45, 30, 123, 123, 123, 123, 123, 123, 123, 24, 67, 45, 31, 31, 31, 31, 31, 31, 31, 20, 107, 107, 107, 107, 107, 107, 107, 107, 107] } }, { CONSTANT_NAME: "INDIGO_PLATEAU", height: 9, width: 10, id: "09", Name: "IndigoPlateau", blockset: "PLATEAU", connections: { south: { destination: "ROUTE_23", offset: 0 } }, warps: [{ row: "9", col: "5", dest: "INDIGO_PLATEAU_LOBBY", src: "INDIGO_PLATEAU" }, { row: "10", col: "5", dest: "INDIGO_PLATEAU_LOBBY", src: "INDIGO_PLATEAU" }], mapData: { type: "Buffer", data: [24, 26, 26, 33, 23, 23, 34, 26, 26, 27, 28, 39, 28, 24, 26, 26, 27, 31, 39, 31, 1, 1, 1, 28, 29, 30, 31, 1, 1, 1, 41, 41, 41, 1, 67, 66, 1, 42, 42, 42, 44, 44, 44, 40, 67, 66, 40, 43, 43, 43, 41, 41, 41, 1, 67, 66, 1, 42, 42, 42, 44, 44, 44, 40, 67, 66, 40, 43, 43, 43, 41, 41, 41, 1, 67, 66, 1, 42, 42, 42, 44, 44, 44, 40, 67, 66, 40, 43, 43, 43] } }, { CONSTANT_NAME: "SAFFRON_CITY", height: 18, width: 20, id: "0A", Name: "SaffronCity", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_5", offset: 5 }, south: { destination: "ROUTE_6", offset: 5 }, west: { destination: "ROUTE_7", offset: 4 }, east: { destination: "ROUTE_8", offset: 4 } }, warps: [{ row: "7", col: "5", dest: "COPYCATS_HOUSE_1F", src: "SAFFRON_CITY" }, { row: "26", col: "3", dest: "FIGHTING_DOJO", src: "SAFFRON_CITY" }, { row: "34", col: "3", dest: "SAFFRON_GYM", src: "SAFFRON_CITY" }, { row: "13", col: "11", dest: "SAFFRON_PIDGEY_HOUSE", src: "SAFFRON_CITY" }, { row: "25", col: "11", dest: "SAFFRON_MART", src: "SAFFRON_CITY" }, { row: "18", col: "21", dest: "SILPH_CO_1F", src: "SAFFRON_CITY" }, { row: "9", col: "29", dest: "SAFFRON_POKECENTER", src: "SAFFRON_CITY" }, { row: "29", col: "29", dest: "MR_PSYCHICS_HOUSE", src: "SAFFRON_CITY" }], mapData: { type: "Buffer", data: [82, 82, 82, 82, 82, 79, 82, 82, 82, 49, 49, 12, 13, 14, 12, 13, 13, 14, 56, 57, 78, 56, 57, 56, 57, 56, 57, 49, 49, 49, 49, 16, 17, 18, 16, 17, 17, 18, 16, 0, 78, 16, 0, 60, 61, 16, 0, 119, 86, 119, 49, 49, 119, 86, 119, 49, 119, 86, 119, 77, 78, 73, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 72, 77, 78, 39, 56, 57, 56, 57, 56, 57, 49, 49, 49, 49, 32, 33, 56, 57, 56, 57, 39, 77, 10, 39, 16, 0, 16, 0, 60, 61, 32, 13, 13, 33, 124, 115, 16, 0, 16, 0, 39, 77, 10, 38, 35, 35, 35, 35, 35, 35, 104, 127, 127, 105, 35, 35, 35, 35, 35, 35, 34, 77, 10, 39, 85, 85, 85, 85, 85, 85, 104, 127, 127, 105, 85, 85, 85, 85, 85, 85, 39, 77, 1, 39, 49, 32, 33, 32, 33, 49, 104, 127, 127, 105, 32, 33, 32, 33, 32, 33, 39, 1, 86, 34, 49, 104, 105, 104, 105, 49, 104, 127, 127, 105, 104, 105, 104, 105, 104, 105, 38, 86, 10, 39, 86, 55, 126, 55, 126, 86, 55, 58, 125, 126, 55, 126, 55, 126, 55, 126, 39, 77, 10, 38, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 34, 77, 78, 39, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 39, 77, 78, 39, 56, 57, 32, 33, 56, 57, 56, 57, 56, 57, 49, 49, 32, 33, 56, 57, 39, 77, 78, 39, 16, 0, 124, 114, 16, 0, 16, 0, 16, 0, 119, 86, 124, 126, 16, 0, 39, 77, 78, 68, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 69, 77, 32, 33, 56, 57, 56, 57, 56, 57, 56, 57, 49, 49, 56, 57, 56, 57, 56, 57, 32, 33, 55, 126, 16, 0, 16, 0, 16, 0, 16, 0, 10, 119, 16, 0, 16, 0, 16, 0, 55, 126] } }, { CONSTANT_NAME: "UNUSED_MAP_0B", height: 0, width: 0, id: "0B" }, { CONSTANT_NAME: "ROUTE_1", height: 18, width: 10, id: "0C", Name: "Route1", blockset: "OVERWORLD", connections: { north: { destination: "VIRIDIAN_CITY", offset: -5 }, south: { destination: "PALLET_TOWN", offset: 0 } }, warps: [], mapData: { type: "Buffer", data: [10, 77, 82, 82, 79, 49, 80, 82, 82, 78, 10, 77, 10, 10, 10, 49, 10, 10, 116, 78, 10, 77, 7, 7, 66, 26, 26, 49, 49, 78, 10, 110, 116, 116, 110, 11, 11, 11, 11, 109, 10, 110, 7, 7, 66, 11, 11, 11, 11, 109, 10, 110, 10, 116, 116, 10, 49, 49, 49, 109, 10, 110, 111, 7, 7, 111, 28, 11, 11, 109, 10, 77, 10, 10, 116, 116, 49, 11, 11, 78, 10, 77, 10, 49, 49, 49, 49, 116, 116, 78, 10, 77, 47, 26, 47, 7, 7, 7, 7, 78, 10, 77, 10, 49, 49, 49, 49, 49, 49, 78, 10, 77, 111, 111, 111, 111, 11, 11, 26, 78, 10, 77, 10, 10, 116, 116, 11, 11, 49, 78, 10, 77, 26, 49, 8, 26, 26, 26, 26, 78, 10, 110, 10, 11, 11, 49, 10, 11, 11, 109, 10, 110, 11, 11, 116, 49, 11, 11, 116, 109, 10, 110, 81, 81, 99, 11, 98, 81, 81, 109, 10, 110, 10, 10, 77, 11, 78, 10, 10, 109] } }, { CONSTANT_NAME: "ROUTE_2", height: 36, width: 10, id: "0D", Name: "Route2", blockset: "OVERWORLD", connections: { north: { destination: "PEWTER_CITY", offset: -5 }, south: { destination: "VIRIDIAN_CITY", offset: -5 } }, warps: [{ row: "12", col: "9", dest: "DIGLETTS_CAVE_ROUTE_2", src: "ROUTE_2" }, { row: "3", col: "11", dest: "VIRIDIAN_FOREST_NORTH_GATE", src: "ROUTE_2" }, { row: "15", col: "19", dest: "ROUTE_2_TRADE_HOUSE", src: "ROUTE_2" }, { row: "16", col: "35", dest: "ROUTE_2_GATE", src: "ROUTE_2" }, { row: "15", col: "39", dest: "ROUTE_2_GATE", src: "ROUTE_2" }, { row: "3", col: "43", dest: "VIRIDIAN_FOREST_SOUTH_GATE", src: "ROUTE_2" }], mapData: { type: "Buffer", data: [15, 15, 15, 15, 1, 15, 15, 15, 15, 15, 11, 11, 11, 11, 1, 27, 49, 49, 49, 49, 11, 11, 11, 11, 1, 27, 49, 49, 49, 49, 11, 11, 11, 11, 1, 62, 63, 63, 59, 49, 49, 49, 49, 49, 49, 36, 6, 87, 37, 49, 108, 109, 50, 108, 108, 8, 49, 116, 116, 10, 10, 32, 33, 10, 10, 49, 49, 49, 49, 49, 82, 124, 126, 82, 82, 82, 82, 10, 10, 49, 85, 85, 85, 85, 15, 15, 15, 10, 10, 49, 26, 26, 26, 26, 15, 15, 15, 2, 3, 49, 11, 1, 11, 11, 15, 15, 15, 49, 49, 49, 15, 15, 15, 15, 15, 15, 15, 50, 108, 108, 15, 15, 15, 15, 15, 15, 15, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 7, 47, 7, 15, 15, 15, 15, 15, 15, 15, 10, 10, 116, 15, 15, 15, 15, 15, 15, 15, 7, 47, 7, 15, 15, 15, 15, 15, 15, 15, 10, 10, 116, 15, 15, 15, 15, 15, 15, 15, 82, 10, 82, 15, 15, 15, 15, 15, 15, 15, 32, 13, 33, 108, 109, 50, 108, 108, 15, 15, 124, 125, 126, 10, 32, 33, 10, 10, 15, 15, 10, 10, 10, 82, 124, 126, 82, 82, 15, 15, 47, 7, 7, 85, 85, 85, 85, 85, 110, 10, 10, 10, 10, 26, 26, 26, 26, 1, 110, 10, 10, 116, 116, 116, 1, 11, 11, 11, 110, 7, 47, 7, 7, 116, 1, 11, 11, 11, 110, 10, 10, 10, 10, 116, 1, 10, 111, 111, 111, 52, 10, 10, 10, 116, 1, 110, 15, 15, 15, 109, 10, 10, 10, 116, 1, 10, 108, 108, 108, 109, 116, 10, 10, 116, 1, 49, 49, 49, 10, 109, 116, 116, 10, 15, 7, 7, 47, 26, 7, 52, 47, 7, 7, 15, 116, 116, 10, 49, 10, 109, 10, 10, 10, 15, 49, 8, 49, 49, 10, 109, 116, 116, 10, 15, 1, 116, 116, 49, 10, 109, 116, 116, 10, 15, 1, 1, 1, 1, 111, 52, 111, 111, 111, 15, 15, 15, 27, 1, 15, 15, 15, 15, 15] } }, { CONSTANT_NAME: "ROUTE_3", height: 9, width: 35, id: "0E", Name: "Route3", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_4", offset: 25 }, west: { destination: "PEWTER_CITY", offset: -4 } }, warps: [], mapData: { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 41, 109, 1, 1, 1, 40, 44, 44, 44, 44, 44, 44, 43, 87, 87, 87, 87, 87, 87, 87, 87, 87, 42, 44, 43, 87, 87, 87, 87, 87, 87, 87, 87, 42, 44, 41, 10, 1, 1, 1, 40, 44, 44, 44, 44, 44, 44, 41, 10, 10, 10, 10, 10, 10, 10, 10, 116, 40, 44, 41, 10, 10, 10, 10, 10, 10, 10, 10, 40, 44, 41, 10, 1, 62, 63, 44, 44, 44, 87, 87, 87, 87, 37, 47, 7, 7, 66, 7, 7, 66, 7, 47, 36, 87, 37, 7, 47, 62, 63, 59, 7, 7, 47, 40, 44, 41, 7, 47, 36, 87, 87, 42, 44, 1, 10, 64, 10, 10, 10, 10, 10, 110, 10, 10, 110, 10, 10, 10, 10, 10, 10, 10, 40, 44, 41, 10, 10, 10, 36, 87, 37, 10, 86, 11, 11, 11, 40, 44, 1, 10, 65, 10, 110, 7, 7, 47, 66, 7, 7, 66, 11, 11, 11, 11, 11, 11, 11, 40, 44, 41, 116, 116, 10, 10, 10, 10, 10, 11, 11, 11, 11, 40, 44, 63, 63, 63, 63, 59, 10, 10, 10, 10, 10, 10, 110, 11, 11, 11, 11, 11, 11, 11, 40, 44, 41, 116, 116, 116, 10, 10, 10, 10, 11, 11, 11, 11, 40, 44, 44, 44, 44, 44, 41, 62, 63, 63, 63, 63, 63, 63, 59, 15, 15, 15, 15, 15, 15, 40, 44, 41, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 44, 44, 87, 87, 87, 87, 37, 40, 44, 44, 44, 44, 44, 44, 41, 15, 15, 15, 15, 15, 15, 40, 44, 41, 40, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44] } }, { CONSTANT_NAME: "ROUTE_4", height: 9, width: 45, id: "0F", Name: "Route4", blockset: "OVERWORLD", connections: { south: { destination: "ROUTE_3", offset: -25 }, east: { destination: "CERULEAN_CITY", offset: -4 } }, warps: [{ row: "11", col: "5", dest: "MT_MOON_POKECENTER", src: "ROUTE_4" }, { row: "18", col: "5", dest: "MT_MOON_1F", src: "ROUTE_4" }, { row: "24", col: "5", dest: "MT_MOON_B1F", src: "ROUTE_4" }], mapData: { type: "Buffer", data: [44, 44, 44, 44, 43, 87, 87, 42, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 42, 44, 44, 44, 44, 44, 43, 87, 87, 37, 32, 33, 36, 42, 44, 44, 44, 44, 44, 44, 44, 44, 41, 10, 88, 10, 89, 89, 10, 10, 88, 10, 88, 10, 10, 88, 10, 10, 10, 10, 10, 49, 49, 49, 49, 36, 87, 87, 87, 87, 44, 41, 1, 1, 1, 124, 114, 1, 36, 6, 42, 43, 6, 87, 87, 87, 87, 37, 10, 90, 47, 91, 89, 10, 10, 88, 10, 88, 10, 10, 90, 7, 7, 7, 7, 7, 26, 26, 26, 26, 97, 97, 97, 97, 97, 44, 41, 26, 26, 1, 1, 1, 1, 8, 1, 40, 41, 49, 8, 49, 10, 10, 10, 10, 10, 10, 10, 89, 10, 10, 88, 10, 90, 47, 7, 7, 7, 7, 7, 7, 7, 26, 26, 26, 26, 103, 31, 31, 31, 31, 44, 41, 1, 1, 1, 1, 1, 26, 26, 26, 40, 41, 7, 7, 7, 7, 7, 47, 7, 7, 7, 7, 91, 10, 10, 90, 7, 7, 7, 7, 47, 111, 7, 7, 7, 7, 26, 28, 26, 26, 20, 107, 107, 107, 107, 44, 41, 26, 26, 26, 26, 1, 1, 1, 1, 40, 41, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 109, 11, 11, 11, 11, 11, 110, 49, 49, 49, 49, 49, 49, 49, 44, 41, 1, 1, 1, 1, 1, 26, 26, 26, 40, 44, 63, 63, 63, 63, 63, 63, 63, 63, 59, 47, 7, 7, 7, 7, 47, 7, 7, 7, 7, 109, 11, 11, 11, 11, 11, 110, 47, 7, 98, 81, 81, 81, 81, 44, 44, 59, 26, 26, 1, 1, 1, 1, 1, 40, 44, 44, 44, 44, 44, 44, 44, 44, 44, 41, 116, 116, 116, 10, 10, 10, 10, 10, 10, 10, 109, 11, 11, 11, 11, 11, 10, 10, 10, 78, 10, 10, 10, 10, 44, 44, 41, 1, 1, 1, 26, 62, 63, 63, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 59, 116, 116] } }, { CONSTANT_NAME: "ROUTE_5", height: 18, width: 10, id: "10", Name: "Route5", blockset: "OVERWORLD", connections: { north: { destination: "CERULEAN_CITY", offset: -5 }, south: { destination: "SAFFRON_CITY", offset: -5 } }, warps: [{ row: "10", col: "29", dest: "ROUTE_5_GATE", src: "ROUTE_5" }, { row: "9", col: "29", dest: "ROUTE_5_GATE", src: "ROUTE_5" }, { row: "10", col: "33", dest: "ROUTE_5_GATE", src: "ROUTE_5" }, { row: "17", col: "27", dest: "UNDERGROUND_PATH_ROUTE_5", src: "ROUTE_5" }, { row: "10", col: "21", dest: "DAYCARE", src: "ROUTE_5" }], mapData: { type: "Buffer", data: [109, 39, 110, 10, 10, 10, 10, 78, 39, 77, 109, 39, 110, 7, 7, 7, 7, 78, 39, 77, 109, 39, 110, 11, 11, 11, 11, 78, 39, 77, 109, 39, 110, 7, 7, 7, 7, 78, 39, 77, 109, 39, 110, 11, 11, 11, 11, 78, 39, 77, 109, 39, 110, 7, 7, 7, 7, 78, 39, 77, 109, 39, 110, 11, 11, 11, 11, 78, 39, 77, 109, 39, 110, 7, 7, 7, 7, 78, 39, 77, 109, 39, 95, 49, 49, 49, 49, 27, 39, 77, 109, 39, 95, 49, 12, 14, 49, 27, 39, 77, 109, 94, 95, 49, 16, 18, 49, 27, 94, 77, 109, 1, 95, 26, 26, 26, 26, 27, 1, 77, 109, 1, 1, 1, 1, 1, 1, 1, 32, 33, 109, 1, 1, 1, 1, 1, 1, 1, 124, 126, 109, 1, 1, 1, 27, 95, 1, 1, 8, 77, 109, 1, 1, 32, 13, 13, 33, 1, 1, 77, 110, 119, 119, 55, 125, 58, 126, 119, 119, 109, 110, 116, 116, 10, 10, 10, 10, 116, 116, 109] } }, { CONSTANT_NAME: "ROUTE_6", height: 18, width: 10, id: "11", Name: "Route6", blockset: "OVERWORLD", connections: { north: { destination: "SAFFRON_CITY", offset: -5 }, south: { destination: "VERMILION_CITY", offset: -5 } }, warps: [{ row: "9", col: "1", dest: "ROUTE_6_GATE", src: "ROUTE_6" }, { row: "10", col: "1", dest: "ROUTE_6_GATE", src: "ROUTE_6" }, { row: "10", col: "7", dest: "ROUTE_6_GATE", src: "ROUTE_6" }, { row: "17", col: "13", dest: "UNDERGROUND_PATH_ROUTE_6", src: "ROUTE_6" }], mapData: { type: "Buffer", data: [116, 116, 116, 10, 77, 77, 10, 116, 116, 116, 81, 81, 81, 81, 32, 13, 33, 81, 81, 81, 116, 116, 116, 10, 104, 127, 105, 116, 116, 116, 7, 47, 7, 7, 55, 58, 126, 7, 47, 7, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 7, 7, 7, 47, 7, 7, 7, 7, 32, 33, 49, 49, 49, 49, 49, 49, 49, 49, 124, 126, 11, 11, 49, 11, 11, 11, 11, 49, 49, 8, 11, 11, 49, 11, 11, 11, 11, 11, 11, 11, 11, 11, 49, 11, 11, 11, 11, 11, 11, 11, 11, 11, 49, 49, 49, 49, 49, 49, 49, 11, 11, 11, 11, 11, 11, 11, 11, 11, 49, 11, 29, 31, 31, 31, 31, 31, 30, 11, 49, 11, 101, 67, 67, 67, 67, 67, 100, 11, 49, 11, 81, 99, 10, 10, 49, 49, 49, 49, 49, 11, 10, 77, 82, 82, 49, 10, 11, 11, 11, 11, 31, 31, 31, 106, 49, 98, 81, 81, 81, 81, 67, 67, 67, 25, 49, 78, 10, 10, 10, 10] } }, { CONSTANT_NAME: "ROUTE_7", height: 9, width: 10, id: "12", Name: "Route7", blockset: "OVERWORLD", connections: { west: { destination: "CELADON_CITY", offset: -4 }, east: { destination: "SAFFRON_CITY", offset: -4 } }, warps: [{ row: "18", col: "9", dest: "ROUTE_7_GATE", src: "ROUTE_7" }, { row: "18", col: "10", dest: "ROUTE_7_GATE", src: "ROUTE_7" }, { row: "11", col: "9", dest: "ROUTE_7_GATE", src: "ROUTE_7" }, { row: "11", col: "10", dest: "ROUTE_7_GATE", src: "ROUTE_7" }, { row: "5", col: "13", dest: "UNDERGROUND_PATH_ROUTE_7", src: "ROUTE_7" }], mapData: { type: "Buffer", data: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 49, 49, 49, 71, 11, 11, 11, 11, 95, 123, 15, 49, 49, 71, 11, 11, 11, 116, 95, 123, 15, 26, 92, 75, 116, 49, 49, 49, 95, 123, 15, 49, 49, 49, 49, 95, 32, 13, 33, 1, 15, 26, 32, 33, 92, 26, 55, 125, 126, 119, 15, 8, 124, 126, 49, 49, 49, 49, 95, 123, 15, 49, 49, 49, 49, 49, 49, 49, 95, 123, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15] } }, { CONSTANT_NAME: "ROUTE_8", height: 9, width: 30, id: "13", Name: "Route8", blockset: "OVERWORLD", connections: { west: { destination: "SAFFRON_CITY", offset: -4 }, east: { destination: "LAVENDER_TOWN", offset: 0 } }, warps: [{ row: "1", col: "9", dest: "ROUTE_8_GATE", src: "ROUTE_8" }, { row: "1", col: "10", dest: "ROUTE_8_GATE", src: "ROUTE_8" }, { row: "8", col: "9", dest: "ROUTE_8_GATE", src: "ROUTE_8" }, { row: "8", col: "10", dest: "ROUTE_8_GATE", src: "ROUTE_8" }, { row: "13", col: "3", dest: "UNDERGROUND_PATH_ROUTE_8", src: "ROUTE_8" }], mapData: { type: "Buffer", data: [19, 19, 40, 44, 44, 43, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 37, 40, 43, 19, 19, 36, 87, 87, 37, 2, 3, 8, 26, 26, 78, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 77, 19, 19, 15, 15, 40, 41, 19, 19, 78, 1, 1, 1, 1, 1, 77, 49, 49, 78, 10, 73, 35, 35, 35, 35, 35, 35, 35, 72, 10, 77, 19, 98, 116, 116, 40, 41, 19, 19, 78, 1, 116, 116, 116, 1, 77, 26, 26, 78, 10, 39, 10, 82, 82, 82, 82, 82, 10, 39, 10, 77, 19, 78, 10, 10, 36, 37, 1, 32, 13, 33, 81, 81, 116, 1, 77, 49, 49, 78, 10, 39, 77, 116, 11, 11, 11, 116, 78, 39, 10, 77, 19, 78, 10, 1, 119, 119, 119, 55, 125, 126, 119, 1, 1, 1, 77, 97, 97, 10, 10, 39, 77, 116, 11, 11, 11, 116, 53, 39, 10, 77, 19, 78, 10, 93, 62, 59, 19, 19, 78, 10, 10, 10, 10, 93, 10, 10, 10, 10, 10, 39, 53, 116, 11, 11, 11, 116, 78, 39, 10, 10, 10, 10, 10, 39, 40, 41, 19, 19, 78, 10, 10, 10, 10, 68, 35, 35, 35, 35, 35, 69, 77, 116, 116, 116, 116, 116, 78, 68, 35, 35, 35, 35, 35, 69, 40, 41, 19, 19, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 44, 44] } }, { CONSTANT_NAME: "ROUTE_9", height: 9, width: 30, id: "14", Name: "Route9", blockset: "OVERWORLD", connections: { west: { destination: "CERULEAN_CITY", offset: -4 }, east: { destination: "ROUTE_10", offset: 0 } }, warps: [], mapData: { type: "Buffer", data: [36, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 42, 43, 87, 87, 87, 87, 87, 87, 87, 42, 44, 44, 43, 116, 116, 77, 11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 62, 59, 11, 11, 40, 41, 10, 10, 10, 10, 10, 10, 10, 40, 44, 44, 41, 116, 116, 77, 11, 11, 11, 11, 11, 62, 59, 7, 7, 47, 40, 41, 47, 7, 36, 37, 47, 7, 7, 7, 62, 59, 7, 40, 44, 44, 41, 82, 82, 79, 7, 7, 7, 7, 76, 40, 41, 49, 49, 8, 36, 37, 49, 49, 49, 49, 49, 49, 49, 49, 36, 37, 49, 36, 87, 87, 37, 10, 10, 53, 49, 49, 49, 49, 62, 44, 41, 26, 26, 26, 7, 47, 62, 59, 49, 62, 59, 49, 62, 59, 49, 49, 49, 49, 49, 49, 49, 81, 81, 99, 62, 59, 26, 26, 36, 87, 37, 49, 49, 49, 49, 10, 36, 37, 7, 36, 37, 47, 40, 41, 26, 62, 59, 26, 62, 63, 63, 116, 116, 77, 40, 41, 7, 7, 7, 7, 47, 26, 26, 62, 59, 47, 7, 7, 7, 7, 7, 7, 36, 37, 26, 36, 37, 26, 40, 44, 44, 116, 116, 77, 40, 41, 49, 49, 49, 49, 49, 49, 49, 40, 41, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 40, 44, 44, 116, 116, 77, 40, 44, 63, 63, 63, 63, 63, 63, 63, 44, 44, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 44, 44, 44] } }, { CONSTANT_NAME: "ROUTE_10", height: 36, width: 10, id: "15", Name: "Route10", blockset: "OVERWORLD", connections: { south: { destination: "LAVENDER_TOWN", offset: 0 }, west: { destination: "ROUTE_9", offset: 0 } }, warps: [{ row: "11", col: "19", dest: "ROCK_TUNNEL_POKECENTER", src: "ROUTE_10" }, { row: "8", col: "17", dest: "ROCK_TUNNEL_1F", src: "ROUTE_10" }, { row: "8", col: "53", dest: "ROCK_TUNNEL_1F", src: "ROUTE_10" }, { row: "6", col: "39", dest: "POWER_PLANT", src: "ROUTE_10" }], mapData: { type: "Buffer", data: [87, 87, 87, 87, 87, 87, 87, 87, 87, 42, 67, 67, 67, 67, 67, 67, 67, 67, 67, 40, 97, 1, 97, 97, 97, 97, 97, 97, 101, 40, 1, 10, 11, 11, 11, 11, 11, 77, 101, 40, 1, 10, 11, 11, 11, 11, 11, 77, 101, 40, 59, 7, 7, 7, 7, 7, 47, 79, 101, 40, 41, 10, 10, 10, 10, 10, 10, 77, 101, 40, 44, 63, 63, 63, 59, 10, 10, 77, 101, 40, 43, 87, 87, 87, 112, 32, 33, 77, 101, 40, 41, 49, 119, 86, 53, 124, 114, 77, 101, 40, 41, 10, 10, 10, 53, 85, 85, 77, 101, 40, 41, 85, 85, 85, 53, 10, 10, 77, 101, 40, 41, 85, 85, 85, 53, 10, 10, 77, 101, 40, 41, 85, 85, 85, 10, 10, 10, 77, 101, 40, 41, 10, 10, 10, 10, 10, 10, 79, 101, 40, 44, 63, 63, 63, 63, 63, 59, 123, 101, 40, 43, 87, 87, 87, 87, 42, 41, 123, 101, 40, 41, 32, 13, 13, 33, 40, 41, 123, 101, 40, 41, 104, 127, 127, 105, 40, 41, 123, 101, 40, 41, 55, 125, 58, 126, 40, 41, 123, 101, 40, 41, 123, 121, 123, 123, 40, 41, 123, 101, 40, 41, 123, 123, 123, 123, 36, 37, 123, 101, 40, 41, 123, 123, 123, 123, 123, 123, 123, 101, 40, 41, 31, 31, 31, 31, 31, 31, 31, 46, 40, 44, 63, 63, 63, 63, 63, 63, 63, 63, 44, 44, 44, 44, 44, 44, 44, 43, 87, 87, 42, 43, 87, 87, 87, 6, 87, 37, 10, 76, 40, 41, 49, 49, 49, 8, 49, 49, 10, 10, 40, 41, 49, 49, 49, 49, 62, 59, 47, 7, 40, 41, 26, 62, 63, 63, 44, 41, 10, 10, 40, 41, 122, 36, 87, 87, 87, 37, 7, 47, 40, 41, 10, 10, 10, 10, 10, 10, 10, 122, 40, 44, 63, 63, 63, 59, 10, 10, 10, 10, 40, 44, 44, 43, 87, 37, 47, 12, 13, 14, 40, 44, 44, 41, 122, 122, 122, 117, 113, 118, 40, 44, 44, 41, 122, 49, 62, 104, 127, 105, 44] } }, { CONSTANT_NAME: "ROUTE_11", height: 9, width: 30, id: "16", Name: "Route11", blockset: "OVERWORLD", connections: { west: { destination: "VERMILION_CITY", offset: -4 }, east: { destination: "ROUTE_12", offset: -27 } }, warps: [{ row: "49", col: "8", dest: "ROUTE_11_GATE_1F", src: "ROUTE_11" }, { row: "49", col: "9", dest: "ROUTE_11_GATE_1F", src: "ROUTE_11" }, { row: "58", col: "8", dest: "ROUTE_11_GATE_1F", src: "ROUTE_11" }, { row: "58", col: "9", dest: "ROUTE_11_GATE_1F", src: "ROUTE_11" }, { row: "4", col: "5", dest: "DIGLETTS_CAVE_ROUTE_11", src: "ROUTE_11" }], mapData: { type: "Buffer", data: [49, 49, 49, 49, 109, 73, 35, 35, 35, 35, 35, 72, 11, 11, 11, 73, 35, 35, 35, 35, 72, 11, 11, 10, 10, 10, 10, 10, 15, 15, 49, 62, 63, 59, 109, 39, 11, 11, 11, 11, 11, 39, 11, 11, 11, 39, 11, 11, 11, 11, 94, 11, 11, 10, 10, 10, 10, 10, 15, 15, 86, 36, 6, 37, 109, 39, 11, 11, 11, 11, 11, 39, 11, 11, 11, 39, 11, 11, 11, 11, 11, 11, 11, 10, 76, 10, 10, 10, 15, 15, 49, 49, 49, 49, 49, 34, 11, 11, 73, 35, 35, 34, 11, 11, 11, 38, 35, 35, 72, 11, 11, 11, 11, 111, 111, 32, 13, 13, 33, 15, 31, 31, 31, 30, 109, 39, 11, 11, 39, 11, 11, 39, 11, 11, 11, 39, 11, 11, 39, 11, 11, 11, 1, 1, 1, 55, 125, 125, 126, 10, 67, 67, 67, 100, 109, 68, 35, 35, 69, 11, 11, 68, 35, 35, 35, 34, 11, 11, 39, 11, 11, 11, 93, 108, 108, 10, 10, 10, 15, 15, 67, 67, 67, 100, 109, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 39, 11, 11, 39, 11, 11, 11, 39, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 109, 93, 11, 11, 11, 11, 11, 11, 11, 11, 11, 38, 35, 35, 34, 11, 11, 11, 39, 10, 10, 10, 10, 10, 15, 15, 15, 15, 15, 15, 15, 68, 35, 35, 35, 35, 35, 35, 35, 35, 35, 69, 11, 11, 68, 35, 35, 35, 69, 10, 10, 10, 10, 10, 15, 15] } }, { CONSTANT_NAME: "ROUTE_12", height: 54, width: 10, id: "17", Name: "Route12", blockset: "OVERWORLD", connections: { north: { destination: "LAVENDER_TOWN", offset: 0 }, south: { destination: "ROUTE_13", offset: -20 }, west: { destination: "ROUTE_11", offset: 27 } }, warps: [{ row: "10", col: "15", dest: "ROUTE_12_GATE_1F", src: "ROUTE_12" }, { row: "11", col: "15", dest: "ROUTE_12_GATE_1F", src: "ROUTE_12" }, { row: "10", col: "21", dest: "ROUTE_12_GATE_1F", src: "ROUTE_12" }, { row: "11", col: "77", dest: "ROUTE_12_SUPER_ROD_HOUSE", src: "ROUTE_12" }], mapData: { type: "Buffer", data: [44, 44, 44, 41, 49, 40, 44, 44, 44, 44, 44, 43, 87, 37, 49, 36, 87, 87, 87, 87, 44, 41, 67, 67, 84, 67, 67, 25, 67, 67, 44, 41, 67, 67, 84, 67, 67, 25, 107, 107, 44, 41, 67, 67, 84, 67, 67, 67, 67, 25, 44, 41, 84, 84, 122, 84, 67, 67, 67, 25, 44, 41, 84, 120, 120, 84, 121, 84, 84, 25, 44, 41, 84, 67, 67, 84, 120, 120, 120, 25, 44, 41, 84, 67, 32, 13, 33, 67, 67, 25, 44, 41, 120, 67, 104, 127, 105, 67, 67, 25, 44, 41, 107, 107, 55, 58, 126, 107, 107, 21, 44, 41, 67, 67, 67, 84, 67, 67, 67, 25, 44, 41, 67, 67, 67, 84, 67, 67, 67, 25, 44, 41, 84, 84, 84, 122, 84, 84, 67, 25, 44, 41, 120, 120, 120, 120, 120, 84, 67, 25, 44, 41, 84, 67, 67, 84, 84, 84, 67, 25, 44, 41, 84, 67, 67, 84, 120, 120, 67, 25, 44, 41, 122, 84, 84, 84, 67, 84, 67, 25, 87, 37, 84, 120, 120, 120, 67, 84, 67, 25, 15, 15, 84, 67, 67, 67, 67, 120, 67, 25, 15, 15, 122, 84, 122, 84, 84, 84, 67, 25, 15, 15, 84, 120, 84, 120, 120, 120, 67, 25, 15, 15, 120, 67, 84, 84, 84, 67, 67, 25, 15, 15, 67, 67, 120, 120, 122, 84, 67, 25, 15, 15, 84, 84, 84, 67, 84, 120, 67, 25, 15, 15, 84, 120, 84, 67, 84, 84, 67, 25, 15, 15, 84, 67, 84, 84, 122, 84, 67, 25, 15, 15, 84, 67, 120, 120, 120, 120, 67, 25, 15, 15, 84, 84, 84, 122, 84, 84, 67, 25, 15, 15, 120, 120, 120, 84, 120, 120, 67, 25, 54, 54, 107, 107, 107, 84, 67, 67, 67, 25, 76, 76, 97, 97, 97, 121, 67, 67, 67, 25, 15, 15, 120, 120, 120, 84, 67, 67, 67, 25, 15, 15, 67, 67, 67, 84, 67, 67, 67, 25, 15, 15, 67, 67, 67, 84, 67, 67, 67, 25, 15, 15, 67, 67, 67, 84, 67, 67, 67, 25, 10, 110, 67, 67, 67, 84, 84, 84, 67, 25, 10, 110, 67, 67, 67, 120, 120, 84, 67, 25, 10, 110, 84, 49, 49, 2, 3, 49, 67, 25, 10, 110, 84, 119, 119, 119, 119, 119, 67, 25, 10, 110, 84, 120, 120, 120, 120, 120, 67, 25, 10, 110, 84, 84, 84, 122, 84, 67, 67, 25, 10, 110, 120, 120, 120, 84, 120, 67, 67, 25, 10, 110, 108, 54, 67, 84, 67, 67, 67, 25, 10, 110, 10, 53, 84, 84, 67, 67, 67, 25, 10, 110, 108, 10, 120, 122, 84, 84, 67, 25, 10, 110, 84, 84, 84, 84, 120, 120, 67, 25, 10, 110, 120, 120, 120, 84, 84, 84, 67, 25, 10, 110, 67, 67, 67, 120, 120, 84, 67, 25, 10, 110, 108, 108, 51, 84, 122, 84, 67, 25, 10, 110, 11, 11, 110, 120, 84, 120, 67, 25, 10, 110, 11, 11, 110, 67, 84, 67, 67, 25, 10, 110, 11, 11, 110, 84, 122, 67, 67, 25, 10, 110, 11, 11, 110, 84, 120, 67, 67, 25] } }, { CONSTANT_NAME: "ROUTE_13", height: 9, width: 30, id: "18", Name: "Route13", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_12", offset: 20 }, west: { destination: "ROUTE_14", offset: 0 } }, warps: [], mapData: { type: "Buffer", data: [49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 28, 15, 15, 15, 15, 15, 15, 15, 84, 67, 67, 67, 25, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 15, 108, 108, 108, 108, 108, 108, 15, 84, 67, 67, 67, 25, 119, 119, 119, 119, 119, 119, 1, 49, 119, 119, 119, 119, 49, 27, 119, 119, 86, 52, 10, 11, 11, 11, 11, 11, 110, 84, 67, 67, 67, 25, 119, 119, 119, 119, 119, 49, 119, 119, 27, 119, 119, 119, 119, 119, 119, 119, 1, 15, 109, 11, 11, 11, 11, 11, 110, 84, 67, 67, 67, 25, 119, 119, 49, 119, 119, 119, 27, 119, 119, 119, 119, 119, 119, 49, 27, 119, 1, 15, 15, 111, 111, 111, 111, 111, 15, 84, 67, 67, 67, 25, 119, 119, 119, 27, 49, 119, 119, 119, 119, 119, 119, 49, 27, 119, 119, 86, 119, 49, 84, 84, 84, 84, 84, 84, 84, 84, 67, 67, 67, 25, 27, 119, 119, 49, 119, 119, 119, 86, 27, 119, 119, 119, 119, 119, 119, 119, 119, 119, 120, 120, 120, 120, 120, 120, 120, 120, 67, 67, 67, 25, 15, 15, 81, 81, 81, 81, 81, 81, 81, 31, 31, 31, 31, 31, 31, 31, 31, 106, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 15, 15, 31, 31, 31, 31, 31, 31, 31, 67, 67, 67, 67, 67, 67, 67, 67, 25, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 21] } }, { CONSTANT_NAME: "ROUTE_14", height: 27, width: 10, id: "19", Name: "Route14", blockset: "OVERWORLD", connections: { west: { destination: "ROUTE_15", offset: 18 }, east: { destination: "ROUTE_13", offset: 0 } }, warps: [], mapData: { type: "Buffer", data: [10, 77, 49, 49, 49, 49, 49, 49, 49, 49, 10, 77, 119, 119, 119, 119, 119, 119, 119, 119, 10, 77, 49, 119, 119, 119, 119, 119, 119, 119, 10, 77, 119, 119, 119, 119, 119, 49, 119, 119, 10, 77, 119, 49, 119, 119, 119, 119, 119, 119, 10, 77, 119, 119, 119, 119, 49, 119, 119, 119, 10, 77, 49, 49, 49, 10, 85, 10, 8, 119, 10, 77, 49, 49, 49, 10, 85, 77, 15, 15, 10, 77, 28, 28, 28, 10, 85, 77, 15, 15, 10, 77, 11, 11, 11, 109, 85, 77, 15, 15, 10, 77, 11, 11, 11, 109, 85, 77, 31, 31, 10, 77, 11, 11, 11, 109, 85, 77, 67, 67, 10, 77, 110, 7, 7, 109, 85, 77, 67, 67, 10, 77, 53, 10, 85, 109, 85, 77, 67, 67, 10, 77, 10, 10, 85, 109, 85, 10, 99, 67, 10, 77, 10, 10, 85, 109, 85, 10, 77, 67, 10, 77, 10, 10, 85, 53, 85, 10, 77, 67, 10, 77, 10, 10, 85, 109, 85, 10, 77, 67, 19, 19, 10, 10, 85, 109, 85, 10, 77, 67, 19, 19, 10, 10, 85, 109, 85, 10, 77, 67, 85, 110, 85, 85, 85, 10, 85, 10, 77, 67, 7, 53, 10, 10, 10, 10, 85, 10, 77, 67, 10, 10, 10, 10, 10, 10, 85, 10, 77, 67, 85, 85, 85, 85, 85, 85, 85, 10, 77, 67, 10, 10, 10, 10, 10, 10, 10, 10, 77, 67, 81, 81, 81, 81, 81, 81, 81, 81, 81, 67, 10, 10, 10, 10, 10, 10, 10, 10, 10, 67] } }, { CONSTANT_NAME: "ROUTE_15", height: 9, width: 30, id: "1A", Name: "Route15", blockset: "OVERWORLD", connections: { west: { destination: "FUCHSIA_CITY", offset: -4 }, east: { destination: "ROUTE_14", offset: -18 } }, warps: [{ row: "7", col: "8", dest: "ROUTE_15_GATE_1F", src: "ROUTE_15" }, { row: "7", col: "9", dest: "ROUTE_15_GATE_1F", src: "ROUTE_15" }, { row: "14", col: "8", dest: "ROUTE_15_GATE_1F", src: "ROUTE_15" }, { row: "14", col: "9", dest: "ROUTE_15_GATE_1F", src: "ROUTE_15" }], mapData: { type: "Buffer", data: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 19, 19, 111, 76, 10, 10, 10, 10, 10, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 19, 19, 15, 15, 10, 10, 10, 10, 10, 78, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 15, 15, 82, 82, 32, 13, 33, 80, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 49, 49, 49, 49, 55, 125, 126, 85, 85, 11, 11, 11, 116, 116, 116, 11, 11, 11, 49, 8, 49, 116, 116, 11, 11, 116, 11, 11, 11, 116, 15, 15, 81, 81, 10, 10, 10, 78, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 15, 15, 10, 10, 10, 10, 10, 78, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 108, 10, 10, 10, 10, 10, 10, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10] } }, { CONSTANT_NAME: "ROUTE_16", height: 9, width: 20, id: "1B", Name: "Route16", blockset: "OVERWORLD", connections: { south: { destination: "ROUTE_17", offset: 0 }, east: { destination: "CELADON_CITY", offset: -4 } }, warps: [{ row: "17", col: "10", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "17", col: "11", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "24", col: "10", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "24", col: "11", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "17", col: "4", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "17", col: "5", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "24", col: "4", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "24", col: "5", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16" }, { row: "7", col: "5", dest: "ROUTE_16_FLY_HOUSE", src: "ROUTE_16" }], mapData: { type: "Buffer", data: [82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 15, 15, 78, 10, 10, 10, 10, 10, 10, 10, 10, 32, 13, 33, 10, 10, 11, 11, 11, 11, 15, 15, 78, 1, 1, 2, 3, 1, 1, 1, 1, 55, 125, 126, 1, 1, 11, 11, 11, 11, 15, 15, 78, 1, 1, 1, 1, 1, 10, 10, 10, 32, 13, 33, 10, 1, 1, 1, 1, 1, 15, 15, 80, 119, 119, 119, 119, 119, 119, 119, 119, 104, 127, 105, 111, 111, 111, 111, 111, 96, 15, 15, 78, 49, 10, 10, 49, 49, 49, 49, 49, 55, 125, 126, 119, 86, 119, 119, 119, 119, 119, 119, 78, 49, 10, 10, 49, 49, 49, 49, 49, 49, 49, 49, 15, 15, 15, 15, 15, 15, 15, 15, 78, 49, 10, 10, 49, 49, 98, 81, 81, 81, 81, 81, 15, 15, 15, 15, 15, 15, 15, 15, 78, 49, 8, 49, 49, 10, 78, 29, 31, 31, 31, 31, 15, 15, 15, 15, 15, 15, 15, 15] } }, { CONSTANT_NAME: "ROUTE_17", height: 72, width: 10, id: "1C", Name: "Route17", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_16", offset: 0 }, south: { destination: "ROUTE_18", offset: 0 } }, warps: [], mapData: { type: "Buffer", data: [78, 93, 116, 116, 93, 116, 78, 101, 67, 67, 78, 39, 116, 116, 39, 116, 78, 101, 67, 67, 78, 39, 116, 116, 39, 116, 81, 81, 81, 99, 78, 39, 116, 116, 39, 116, 116, 116, 116, 77, 78, 39, 116, 116, 39, 116, 11, 11, 11, 77, 78, 39, 116, 116, 39, 116, 11, 11, 11, 77, 78, 39, 116, 116, 39, 116, 11, 11, 11, 77, 78, 39, 116, 116, 39, 116, 11, 11, 11, 77, 78, 39, 116, 116, 39, 116, 11, 11, 11, 77, 78, 39, 116, 116, 39, 116, 11, 11, 11, 77, 78, 39, 116, 116, 39, 116, 116, 116, 116, 77, 78, 39, 116, 116, 39, 116, 116, 116, 116, 77, 78, 39, 116, 116, 39, 116, 116, 116, 116, 77, 78, 39, 116, 116, 39, 29, 30, 93, 116, 77, 78, 39, 116, 116, 39, 101, 100, 39, 116, 77, 78, 39, 116, 116, 39, 101, 100, 39, 116, 77, 78, 39, 116, 116, 39, 101, 100, 39, 116, 77, 78, 39, 116, 116, 39, 101, 100, 39, 116, 77, 78, 39, 116, 116, 94, 101, 100, 39, 116, 77, 78, 39, 29, 30, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 8, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 8, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 8, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 101, 100, 49, 101, 100, 39, 116, 77, 78, 39, 116, 49, 8, 101, 100, 39, 116, 77, 78, 39, 116, 29, 31, 46, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 116, 101, 67, 67, 100, 39, 116, 77, 78, 39, 49, 49, 8, 49, 49, 39, 49, 77, 78, 39, 49, 29, 31, 31, 30, 39, 49, 77, 78, 39, 49, 101, 67, 67, 100, 39, 49, 77, 78, 39, 49, 101, 67, 67, 100, 39, 49, 77, 78, 39, 49, 49, 49, 49, 49, 39, 49, 77, 78, 94, 49, 49, 49, 49, 49, 94, 49, 77, 78, 119, 119, 49, 119, 119, 49, 119, 119, 77, 103, 31, 30, 93, 49, 49, 93, 29, 31, 106, 24, 67, 100, 39, 49, 49, 39, 101, 67, 25, 24, 67, 100, 39, 49, 49, 39, 101, 67, 25, 24, 67, 100, 39, 49, 49, 39, 101, 67, 25, 24, 67, 100, 39, 49, 49, 39, 101, 67, 25, 24, 67, 100, 39, 49, 49, 39, 101, 67, 25, 24, 67, 100, 39, 49, 49, 39, 101, 67, 25, 24, 67, 100, 39, 49, 49, 39, 101, 67, 25, 24, 67, 100, 94, 8, 49, 94, 101, 67, 25, 24, 67, 100, 26, 26, 92, 26, 101, 67, 25] } }, { CONSTANT_NAME: "ROUTE_18", height: 9, width: 25, id: "1D", Name: "Route18", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_17", offset: 0 }, east: { destination: "FUCHSIA_CITY", offset: -4 } }, warps: [{ row: "33", col: "8", dest: "ROUTE_18_GATE_1F", src: "ROUTE_18" }, { row: "33", col: "9", dest: "ROUTE_18_GATE_1F", src: "ROUTE_18" }, { row: "40", col: "8", dest: "ROUTE_18_GATE_1F", src: "ROUTE_18" }, { row: "40", col: "9", dest: "ROUTE_18_GATE_1F", src: "ROUTE_18" }], mapData: { type: "Buffer", data: [24, 67, 100, 49, 49, 49, 49, 101, 67, 67, 20, 107, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 24, 67, 100, 49, 116, 116, 49, 101, 67, 67, 67, 100, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 24, 67, 100, 49, 116, 116, 49, 101, 67, 67, 67, 100, 119, 119, 119, 119, 86, 32, 13, 33, 49, 49, 49, 49, 49, 24, 67, 100, 49, 116, 116, 49, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 104, 127, 105, 119, 86, 119, 119, 119, 24, 67, 100, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 55, 125, 126, 1, 1, 1, 1, 1, 24, 67, 45, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 98, 81, 81, 64, 77, 81, 81, 99, 24, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 78, 11, 11, 11, 77, 116, 116, 77, 24, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 78, 11, 11, 11, 77, 116, 116, 77, 20, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 80, 82, 82, 82, 79, 82, 82, 79] } }, { CONSTANT_NAME: "ROUTE_19", height: 27, width: 10, id: "1E", Name: "Route19", blockset: "OVERWORLD", connections: { north: { destination: "FUCHSIA_CITY", offset: -5 }, west: { destination: "ROUTE_20", offset: 18 } }, warps: [], mapData: { type: "Buffer", data: [40, 44, 41, 26, 26, 26, 27, 40, 44, 41, 40, 44, 41, 26, 26, 26, 27, 36, 87, 37, 36, 87, 37, 26, 26, 26, 27, 24, 67, 67, 67, 25, 49, 49, 49, 49, 49, 24, 67, 67, 107, 21, 49, 49, 49, 8, 49, 20, 107, 107, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 19, 67, 67, 67, 67, 67, 67, 67, 67, 25, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 107, 107, 107, 107, 107, 107, 107, 107, 107, 19] } }, { CONSTANT_NAME: "ROUTE_20", height: 9, width: 50, id: "1F", Name: "Route20", blockset: "OVERWORLD", connections: { west: { destination: "CINNABAR_ISLAND", offset: 0 }, east: { destination: "ROUTE_19", offset: -18 } }, warps: [{ row: "48", col: "5", dest: "SEAFOAM_ISLANDS_1F", src: "ROUTE_20" }, { row: "58", col: "9", dest: "SEAFOAM_ISLANDS_1F", src: "ROUTE_20" }], mapData: { type: "Buffer", data: [107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 100, 62, 63, 59, 122, 122, 122, 122, 122, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 100, 36, 6, 37, 122, 122, 122, 122, 122, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 100, 122, 84, 8, 122, 122, 62, 63, 59, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 84, 84, 67, 67, 67, 25, 100, 122, 84, 122, 122, 122, 36, 6, 37, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 120, 120, 67, 67, 67, 25, 45, 31, 67, 31, 31, 106, 8, 84, 122, 24, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 101, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 25, 107, 107, 107, 107, 107, 21, 31, 67, 31, 24, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 46, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 24, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 20, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107] } }, { CONSTANT_NAME: "ROUTE_21", height: 45, width: 10, id: "20", Name: "Route21", blockset: "OVERWORLD", connections: { north: { destination: "PALLET_TOWN", offset: 0 }, south: { destination: "CINNABAR_ISLAND", offset: 0 } }, warps: [], mapData: { type: "Buffer", data: [81, 99, 101, 100, 81, 81, 81, 98, 81, 81, 10, 77, 101, 100, 10, 116, 116, 78, 10, 10, 116, 77, 101, 100, 11, 11, 11, 78, 116, 10, 116, 77, 101, 100, 11, 11, 11, 78, 10, 10, 116, 77, 101, 100, 11, 11, 11, 78, 10, 10, 116, 77, 101, 45, 31, 31, 31, 103, 31, 31, 82, 79, 101, 67, 67, 67, 67, 24, 67, 67, 103, 31, 46, 67, 67, 67, 67, 20, 107, 107, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 84, 84, 67, 67, 67, 67, 67, 25, 24, 67, 120, 120, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 84, 84, 25, 24, 67, 67, 67, 67, 67, 67, 120, 120, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 67, 25, 24, 67, 67, 67, 67, 67, 67, 67, 107, 21, 24, 67, 67, 67, 67, 67, 67, 25, 67, 67, 24, 67, 67, 67, 67, 84, 67, 25, 67, 67] } }, { CONSTANT_NAME: "ROUTE_22", height: 9, width: 20, id: "21", Name: "Route22", blockset: "OVERWORLD", connections: { north: { destination: "ROUTE_23", offset: 0 }, east: { destination: "VIRIDIAN_CITY", offset: -4 } }, warps: [{ row: "8", col: "5", dest: "ROUTE_22_GATE", src: "ROUTE_22" }], mapData: { type: "Buffer", data: [19, 32, 13, 13, 13, 13, 33, 40, 44, 44, 44, 44, 44, 44, 43, 87, 87, 87, 42, 44, 59, 104, 127, 127, 127, 127, 105, 36, 87, 87, 87, 87, 87, 87, 37, 7, 47, 7, 40, 44, 41, 55, 125, 125, 58, 125, 126, 19, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 36, 87, 41, 85, 85, 85, 85, 85, 85, 19, 7, 7, 7, 29, 30, 62, 59, 47, 7, 98, 10, 10, 41, 7, 7, 7, 7, 47, 7, 19, 11, 11, 11, 101, 100, 40, 41, 11, 11, 78, 1, 1, 41, 49, 49, 86, 119, 119, 119, 19, 11, 11, 11, 85, 85, 40, 41, 11, 11, 78, 1, 62, 41, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 36, 37, 7, 47, 7, 7, 40, 41, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 40, 44, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 44] } }, { CONSTANT_NAME: "ROUTE_23", height: 72, width: 10, id: "22", Name: "Route23", blockset: "PLATEAU", connections: { north: { destination: "INDIGO_PLATEAU", offset: 0 }, south: { destination: "ROUTE_22", offset: 0 } }, warps: [{ row: "7", col: "139", dest: "ROUTE_22_GATE", src: "ROUTE_23" }, { row: "8", col: "139", dest: "ROUTE_22_GATE", src: "ROUTE_23" }, { row: "4", col: "31", dest: "VICTORY_ROAD_1F", src: "ROUTE_23" }, { row: "14", col: "31", dest: "VICTORY_ROAD_2F", src: "ROUTE_23" }], mapData: { type: "Buffer", data: [53, 23, 54, 54, 67, 66, 53, 53, 23, 54, 53, 23, 54, 54, 67, 66, 53, 53, 23, 54, 53, 54, 43, 43, 67, 66, 44, 44, 53, 54, 53, 54, 65, 67, 66, 65, 65, 65, 53, 54, 53, 54, 66, 65, 65, 67, 67, 67, 53, 54, 53, 54, 67, 65, 67, 66, 65, 66, 53, 54, 53, 54, 65, 67, 67, 67, 66, 65, 53, 54, 53, 54, 67, 66, 66, 66, 66, 65, 53, 54, 44, 43, 66, 65, 67, 66, 65, 66, 44, 43, 65, 65, 67, 67, 67, 66, 66, 66, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 41, 1, 1, 1, 1, 1, 1, 1, 42, 65, 53, 23, 23, 23, 23, 23, 23, 23, 54, 65, 53, 23, 23, 23, 23, 23, 23, 23, 54, 65, 24, 26, 26, 26, 26, 26, 26, 26, 27, 65, 28, 39, 30, 39, 53, 23, 54, 30, 31, 65, 10, 72, 10, 10, 24, 26, 27, 65, 65, 65, 10, 10, 10, 10, 53, 23, 54, 1, 1, 1, 10, 10, 10, 10, 24, 26, 27, 1, 1, 42, 10, 10, 10, 10, 53, 23, 54, 23, 23, 54, 10, 10, 10, 10, 24, 26, 27, 26, 26, 27, 68, 10, 69, 10, 44, 40, 43, 40, 40, 43, 24, 26, 27, 10, 2, 64, 10, 1, 1, 1, 44, 40, 43, 10, 19, 22, 10, 41, 1, 42, 10, 10, 10, 10, 10, 10, 10, 24, 26, 27, 68, 10, 69, 10, 10, 69, 10, 53, 23, 54, 24, 26, 27, 26, 26, 27, 10, 24, 26, 27, 53, 23, 54, 40, 40, 43, 10, 53, 23, 54, 24, 26, 27, 64, 64, 10, 10, 24, 26, 27, 53, 23, 54, 64, 2, 10, 22, 53, 23, 54, 24, 26, 27, 22, 19, 64, 64, 24, 26, 27, 53, 23, 54, 22, 19, 19, 22, 53, 23, 54, 24, 26, 27, 64, 2, 10, 22, 24, 26, 27, 53, 23, 54, 22, 64, 19, 10, 44, 40, 43, 24, 26, 27, 2, 10, 10, 10, 64, 64, 64, 53, 23, 54, 2, 10, 10, 10, 68, 10, 69, 24, 26, 27, 18, 18, 18, 18, 24, 26, 27, 44, 40, 43, 4, 4, 4, 4, 44, 40, 43, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 70, 4, 4, 70, 4, 71, 4, 4, 4, 4, 24, 26, 26, 24, 26, 27, 70, 71, 4, 4, 44, 40, 40, 53, 23, 54, 24, 27, 4, 4, 4, 4, 4, 24, 26, 27, 53, 54, 4, 4, 4, 4, 4, 53, 23, 54, 24, 27, 4, 4, 4, 4, 4, 24, 26, 27, 44, 43, 4, 20, 65, 21, 4, 53, 23, 54, 4, 4, 4, 56, 18, 55, 4, 24, 26, 27, 70, 4, 4, 71, 4, 4, 4, 53, 23, 54, 24, 26, 26, 27, 4, 4, 4, 24, 26, 27, 44, 40, 40, 43, 4, 4, 4, 44, 40, 43, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 70, 4, 4, 4, 71, 4, 4, 4, 70, 71, 24, 26, 26, 26, 27, 10, 10, 10, 24, 27, 44, 40, 40, 40, 43, 10, 10, 10, 44, 43, 65, 65, 65, 65, 65, 65, 65, 65, 1, 1, 65, 41, 1, 1, 42, 1, 41, 1, 1, 42, 65, 24, 26, 26, 27, 1, 24, 26, 26, 27, 65, 44, 40, 40, 43, 1, 44, 40, 40, 43, 65, 65, 65, 65, 65, 1, 1, 1, 1, 1, 41, 1, 1, 42, 65, 41, 1, 42, 1, 42, 24, 26, 26, 27, 65, 24, 26, 27, 26, 27, 44, 40, 40, 43, 65, 44, 40, 43, 40, 43, 1, 1, 1, 1, 65, 65, 65, 65, 65, 65, 41, 1, 41, 1, 42, 1, 42, 65, 41, 42, 24, 26, 24, 26, 27, 26, 27, 65, 24, 27, 44, 40, 44, 40, 43, 40, 43, 65, 44, 43, 1, 1, 1, 65, 65, 65, 65, 65, 65, 65, 41, 1, 42, 65, 65, 41, 1, 1, 1, 42, 24, 26, 27, 65, 65, 24, 26, 26, 26, 27, 44, 40, 43, 65, 65, 44, 40, 40, 40, 43, 1, 58, 60, 60, 60, 60, 59, 1, 1, 1, 1, 62, 61, 61, 61, 61, 63, 1, 1, 1] } }, { CONSTANT_NAME: "ROUTE_24", height: 18, width: 10, id: "23", Name: "Route24", blockset: "OVERWORLD", connections: { south: { destination: "CERULEAN_CITY", offset: -5 }, east: { destination: "ROUTE_25", offset: 0 } }, warps: [], mapData: { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 87, 87, 87, 87, 87, 87, 87, 87, 44, 41, 49, 49, 49, 49, 71, 49, 88, 10, 44, 41, 26, 92, 26, 26, 75, 49, 90, 7, 44, 41, 49, 49, 49, 49, 49, 49, 49, 49, 44, 41, 10, 10, 10, 49, 98, 81, 81, 81, 44, 41, 116, 116, 10, 49, 78, 10, 62, 63, 44, 41, 116, 116, 10, 49, 78, 10, 40, 44, 44, 41, 10, 29, 106, 84, 78, 10, 40, 44, 44, 41, 11, 101, 25, 84, 78, 10, 40, 44, 44, 41, 11, 101, 25, 84, 78, 10, 36, 87, 44, 41, 11, 101, 25, 84, 78, 77, 67, 67, 44, 41, 11, 101, 25, 84, 78, 77, 67, 67, 44, 41, 11, 101, 25, 84, 78, 77, 67, 67, 44, 41, 11, 101, 25, 84, 78, 77, 67, 67, 44, 41, 11, 101, 25, 84, 78, 77, 67, 67, 44, 41, 31, 46, 25, 84, 78, 77, 67, 67, 44, 41, 67, 67, 25, 84, 78, 77, 67, 67] } }, { CONSTANT_NAME: "ROUTE_25", height: 9, width: 30, id: "24", Name: "Route25", blockset: "OVERWORLD", connections: { west: { destination: "ROUTE_24", offset: 0 } }, warps: [{ row: "45", col: "3", dest: "BILLS_HOUSE", src: "ROUTE_25" }], mapData: { type: "Buffer", data: [44, 44, 44, 44, 43, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 37, 56, 57, 36, 87, 87, 87, 87, 37, 87, 87, 87, 87, 37, 110, 10, 110, 10, 10, 110, 10, 10, 96, 116, 116, 116, 116, 77, 119, 119, 86, 60, 61, 119, 119, 119, 82, 67, 67, 10, 11, 11, 11, 10, 10, 76, 76, 76, 10, 110, 108, 110, 116, 116, 110, 116, 116, 116, 116, 116, 85, 85, 85, 85, 10, 10, 77, 67, 67, 7, 7, 7, 7, 76, 108, 76, 10, 109, 108, 110, 10, 116, 116, 111, 116, 116, 116, 116, 116, 116, 85, 85, 85, 85, 10, 10, 77, 67, 67, 49, 49, 49, 49, 49, 109, 108, 10, 109, 76, 10, 10, 116, 116, 109, 116, 116, 116, 116, 29, 31, 31, 84, 84, 31, 31, 30, 77, 67, 67, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 101, 67, 67, 84, 84, 67, 67, 100, 77, 67, 67, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 59, 82, 82, 82, 82, 82, 82, 82, 82, 82, 79, 67, 67, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 41, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 67, 67, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 41, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67] } }, { CONSTANT_NAME: "REDS_HOUSE_1F", height: 4, width: 4, id: "25", Name: "RedsHouse1F", blockset: "REDS_HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "REDS_HOUSE_1F" }, { row: "3", col: "7", dest: "LAST_MAP", src: "REDS_HOUSE_1F" }, { row: "7", col: "1", dest: "REDS_HOUSE_2F", src: "REDS_HOUSE_1F" }], mapData: { type: "Buffer", data: [4, 9, 5, 7, 15, 15, 15, 15, 15, 1, 2, 15, 15, 11, 15, 15] } }, { CONSTANT_NAME: "REDS_HOUSE_2F", height: 4, width: 4, id: "26", Name: "RedsHouse2F", blockset: "REDS_HOUSE", connections: {}, warps: [{ row: "7", col: "1", dest: "REDS_HOUSE_1F", src: "REDS_HOUSE_2F" }], mapData: { type: "Buffer", data: [16, 17, 5, 8, 15, 15, 15, 15, 15, 13, 15, 15, 12, 15, 15, 18] } }, { CONSTANT_NAME: "BLUES_HOUSE", height: 4, width: 4, id: "27", Name: "BluesHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "BLUES_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "BLUES_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "OAKS_LAB", height: 6, width: 5, id: "28", Name: "OaksLab", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "11", dest: "LAST_MAP", src: "OAKS_LAB" }, { row: "5", col: "11", dest: "LAST_MAP", src: "OAKS_LAB" }], mapData: { type: "Buffer", data: [101, 102, 103, 104, 104, 107, 107, 5, 105, 106, 5, 5, 5, 109, 110, 104, 104, 5, 104, 104, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5] } }, { CONSTANT_NAME: "VIRIDIAN_POKECENTER", height: 4, width: 7, id: "29", Name: "ViridianPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "VIRIDIAN_MART", height: 4, width: 4, id: "2A", Name: "ViridianMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "VIRIDIAN_SCHOOL_HOUSE", height: 4, width: 4, id: "2B", Name: "ViridianSchoolHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_SCHOOL_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_SCHOOL_HOUSE" }], mapData: { type: "Buffer", data: [5, 18, 19, 9, 15, 20, 21, 15, 15, 24, 25, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "VIRIDIAN_NICKNAME_HOUSE", height: 4, width: 4, id: "2C", Name: "ViridianNicknameHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_NICKNAME_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_NICKNAME_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "VIRIDIAN_GYM", height: 9, width: 10, id: "2D", Name: "ViridianGym", blockset: "GYM", connections: {}, warps: [{ row: "16", col: "17", dest: "LAST_MAP", src: "VIRIDIAN_GYM" }, { row: "17", col: "17", dest: "LAST_MAP", src: "VIRIDIAN_GYM" }], mapData: { type: "Buffer", data: [73, 1, 74, 1, 1, 95, 1, 1, 1, 93, 75, 5, 81, 100, 86, 99, 70, 70, 94, 92, 82, 70, 78, 83, 84, 85, 5, 5, 76, 5, 97, 5, 96, 76, 85, 72, 72, 91, 76, 5, 64, 68, 76, 76, 5, 5, 5, 77, 76, 5, 5, 44, 85, 76, 5, 5, 5, 81, 96, 71, 5, 44, 88, 72, 72, 72, 90, 5, 98, 5, 67, 69, 87, 70, 70, 70, 89, 50, 5, 49, 64, 5, 5, 65, 5, 5, 66, 5, 4, 5] } }, { CONSTANT_NAME: "DIGLETTS_CAVE_ROUTE_2", height: 4, width: 4, id: "2E", Name: "DiglettsCaveRoute2", blockset: "CAVERN", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "DIGLETTS_CAVE_ROUTE_2" }, { row: "3", col: "7", dest: "LAST_MAP", src: "DIGLETTS_CAVE_ROUTE_2" }, { row: "4", col: "4", dest: "DIGLETTS_CAVE", src: "DIGLETTS_CAVE_ROUTE_2" }], mapData: { type: "Buffer", data: [125, 125, 125, 125, 6, 1, 1, 125, 6, 1, 39, 125, 10, 36, 4, 125] } }, { CONSTANT_NAME: "VIRIDIAN_FOREST_NORTH_GATE", height: 4, width: 5, id: "2F", Name: "ViridianForestNorthGate", blockset: "GATE", connections: {}, warps: [{ row: "4", col: "0", dest: "LAST_MAP", src: "VIRIDIAN_FOREST_NORTH_GATE" }, { row: "5", col: "0", dest: "LAST_MAP", src: "VIRIDIAN_FOREST_NORTH_GATE" }, { row: "4", col: "7", dest: "VIRIDIAN_FOREST", src: "VIRIDIAN_FOREST_NORTH_GATE" }, { row: "5", col: "7", dest: "VIRIDIAN_FOREST", src: "VIRIDIAN_FOREST_NORTH_GATE" }], mapData: { type: "Buffer", data: [94, 92, 115, 92, 95, 58, 0, 0, 98, 99, 58, 0, 0, 96, 100, 58, 0, 11, 97, 101] } }, { CONSTANT_NAME: "ROUTE_2_TRADE_HOUSE", height: 4, width: 4, id: "30", Name: "Route2TradeHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "ROUTE_2_TRADE_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "ROUTE_2_TRADE_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "ROUTE_2_GATE", height: 4, width: 5, id: "31", Name: "Route2Gate", blockset: "GATE", connections: {}, warps: [{ row: "4", col: "0", dest: "LAST_MAP", src: "ROUTE_2_GATE" }, { row: "5", col: "0", dest: "LAST_MAP", src: "ROUTE_2_GATE" }, { row: "4", col: "7", dest: "LAST_MAP", src: "ROUTE_2_GATE" }, { row: "5", col: "7", dest: "LAST_MAP", src: "ROUTE_2_GATE" }], mapData: { type: "Buffer", data: [94, 92, 115, 92, 95, 58, 0, 0, 98, 99, 58, 0, 0, 96, 100, 58, 0, 11, 97, 101] } }, { CONSTANT_NAME: "VIRIDIAN_FOREST_SOUTH_GATE", height: 4, width: 5, id: "32", Name: "ViridianForestSouthGate", blockset: "GATE", connections: {}, warps: [{ row: "4", col: "0", dest: "VIRIDIAN_FOREST", src: "VIRIDIAN_FOREST_SOUTH_GATE" }, { row: "5", col: "0", dest: "VIRIDIAN_FOREST", src: "VIRIDIAN_FOREST_SOUTH_GATE" }, { row: "4", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_FOREST_SOUTH_GATE" }, { row: "5", col: "7", dest: "LAST_MAP", src: "VIRIDIAN_FOREST_SOUTH_GATE" }], mapData: { type: "Buffer", data: [94, 92, 115, 92, 95, 58, 0, 0, 98, 99, 58, 0, 0, 96, 100, 58, 0, 11, 97, 101] } }, { CONSTANT_NAME: "VIRIDIAN_FOREST", height: 24, width: 17, id: "33", Name: "ViridianForest", blockset: "FOREST", connections: {}, warps: [{ row: "1", col: "0", dest: "VIRIDIAN_FOREST_NORTH_GATE", src: "VIRIDIAN_FOREST" }, { row: "2", col: "0", dest: "VIRIDIAN_FOREST_NORTH_GATE", src: "VIRIDIAN_FOREST" }, { row: "15", col: "47", dest: "VIRIDIAN_FOREST_SOUTH_GATE", src: "VIRIDIAN_FOREST" }, { row: "16", col: "47", dest: "VIRIDIAN_FOREST_SOUTH_GATE", src: "VIRIDIAN_FOREST" }, { row: "17", col: "47", dest: "VIRIDIAN_FOREST_SOUTH_GATE", src: "VIRIDIAN_FOREST" }, { row: "18", col: "47", dest: "VIRIDIAN_FOREST_SOUTH_GATE", src: "VIRIDIAN_FOREST" }], mapData: { type: "Buffer", data: [55, 21, 2, 57, 57, 57, 57, 2, 57, 57, 57, 57, 57, 57, 57, 57, 73, 55, 59, 2, 27, 27, 27, 41, 2, 27, 41, 53, 53, 53, 53, 53, 41, 59, 55, 59, 2, 41, 59, 55, 27, 2, 27, 59, 2, 2, 2, 2, 2, 55, 59, 6, 7, 2, 1, 7, 6, 1, 2, 1, 7, 2, 2, 2, 2, 2, 55, 59, 6, 7, 2, 1, 7, 6, 1, 2, 1, 1, 1, 1, 27, 41, 27, 27, 59, 6, 7, 2, 1, 7, 6, 1, 2, 1, 7, 2, 2, 55, 59, 2, 1, 7, 6, 7, 2, 1, 7, 6, 1, 2, 1, 7, 2, 2, 55, 59, 2, 1, 7, 6, 7, 2, 1, 7, 6, 1, 2, 1, 7, 2, 2, 55, 59, 2, 1, 7, 6, 7, 2, 1, 7, 6, 1, 27, 1, 7, 2, 2, 55, 21, 2, 1, 7, 6, 7, 2, 1, 7, 55, 41, 27, 27, 59, 2, 2, 55, 41, 27, 27, 59, 6, 7, 2, 1, 7, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 55, 59, 6, 1, 27, 1, 7, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 55, 59, 55, 27, 33, 41, 27, 27, 59, 2, 2, 2, 2, 2, 6, 1, 2, 55, 59, 2, 2, 2, 2, 2, 55, 59, 2, 2, 2, 2, 2, 6, 1, 2, 55, 59, 2, 2, 2, 2, 2, 55, 59, 2, 2, 2, 2, 2, 6, 1, 2, 55, 59, 6, 1, 1, 1, 7, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 55, 59, 2, 2, 2, 41, 1, 1, 1, 1, 33, 7, 2, 2, 6, 27, 27, 41, 59, 2, 2, 2, 27, 7, 2, 2, 6, 27, 7, 2, 2, 6, 27, 2, 2, 2, 2, 2, 2, 27, 7, 2, 2, 6, 27, 7, 2, 2, 6, 27, 2, 2, 2, 2, 2, 2, 27, 7, 2, 2, 6, 27, 7, 2, 2, 6, 27, 2, 2, 2, 6, 1, 1, 27, 1, 1, 1, 1, 20, 1, 1, 1, 22, 27, 1, 1, 7, 6, 1, 1, 27, 27, 27, 27, 27, 24, 27, 27, 27, 27, 27, 1, 1, 7, 2, 2, 2, 2, 2, 2, 2, 55, 27, 21, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 55, 88, 59, 2, 2, 2, 2, 2, 2, 2] } }, { CONSTANT_NAME: "MUSEUM_1F", height: 4, width: 10, id: "34", Name: "Museum1F", blockset: "GATE", connections: {}, warps: [{ row: "10", col: "7", dest: "LAST_MAP", src: "MUSEUM_1F" }, { row: "11", col: "7", dest: "LAST_MAP", src: "MUSEUM_1F" }, { row: "16", col: "7", dest: "LAST_MAP", src: "MUSEUM_1F" }, { row: "17", col: "7", dest: "LAST_MAP", src: "MUSEUM_1F" }, { row: "7", col: "7", dest: "MUSEUM_2F", src: "MUSEUM_1F" }], mapData: { type: "Buffer", data: [60, 60, 60, 80, 80, 67, 77, 77, 77, 77, 64, 65, 83, 0, 0, 76, 78, 0, 79, 0, 68, 69, 87, 0, 71, 74, 84, 96, 0, 0, 72, 73, 91, 82, 70, 11, 116, 9, 11, 116] } }, { CONSTANT_NAME: "MUSEUM_2F", height: 4, width: 7, id: "35", Name: "Museum2F", blockset: "GATE", connections: {}, warps: [{ row: "7", col: "7", dest: "MUSEUM_1F", src: "MUSEUM_2F" }], mapData: { type: "Buffer", data: [60, 60, 60, 60, 60, 61, 62, 0, 0, 0, 0, 0, 63, 75, 88, 89, 90, 0, 71, 0, 0, 0, 0, 0, 86, 70, 0, 0] } }, { CONSTANT_NAME: "PEWTER_GYM", height: 7, width: 5, id: "36", Name: "PewterGym", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "13", dest: "LAST_MAP", src: "PEWTER_GYM" }, { row: "5", col: "13", dest: "LAST_MAP", src: "PEWTER_GYM" }], mapData: { type: "Buffer", data: [8, 10, 10, 10, 9, 12, 11, 5, 11, 13, 14, 18, 19, 11, 15, 14, 18, 19, 11, 15, 12, 7, 5, 6, 13, 5, 17, 5, 16, 5, 5, 5, 4, 5, 5] } }, { CONSTANT_NAME: "PEWTER_NIDORAN_HOUSE", height: 4, width: 4, id: "37", Name: "PewterNidoranHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "PEWTER_NIDORAN_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "PEWTER_NIDORAN_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "PEWTER_MART", height: 4, width: 4, id: "38", Name: "PewterMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "PEWTER_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "PEWTER_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "PEWTER_SPEECH_HOUSE", height: 4, width: 4, id: "39", Name: "PewterSpeechHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "PEWTER_SPEECH_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "PEWTER_SPEECH_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "PEWTER_POKECENTER", height: 4, width: 7, id: "3A", Name: "PewterPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "PEWTER_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "PEWTER_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "MT_MOON_1F", height: 18, width: 20, id: "3B", Name: "MtMoon1F", blockset: "CAVERN", connections: {}, warps: [{ row: "14", col: "35", dest: "LAST_MAP", src: "MT_MOON_1F" }, { row: "15", col: "35", dest: "LAST_MAP", src: "MT_MOON_1F" }, { row: "5", col: "5", dest: "MT_MOON_B1F", src: "MT_MOON_1F" }, { row: "17", col: "11", dest: "MT_MOON_B1F", src: "MT_MOON_1F" }, { row: "25", col: "15", dest: "MT_MOON_B1F", src: "MT_MOON_1F" }], mapData: { type: "Buffer", data: [23, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 27, 1, 1, 1, 1, 1, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 27, 1, 40, 1, 1, 1, 27, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 27, 1, 1, 1, 1, 1, 27, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 27, 1, 1, 1, 1, 1, 27, 1, 1, 32, 34, 32, 34, 32, 34, 1, 1, 1, 1, 27, 27, 1, 1, 1, 1, 1, 27, 1, 40, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 27, 1, 1, 1, 1, 1, 27, 1, 1, 31, 1, 1, 1, 1, 1, 1, 23, 1, 1, 27, 27, 1, 1, 1, 1, 1, 31, 1, 1, 23, 1, 1, 40, 1, 1, 1, 31, 1, 1, 27, 27, 1, 1, 1, 1, 1, 1, 1, 1, 31, 1, 23, 1, 1, 1, 1, 23, 1, 1, 27, 27, 32, 33, 34, 23, 1, 1, 1, 1, 23, 1, 31, 1, 1, 1, 1, 31, 1, 1, 27, 27, 1, 1, 1, 27, 32, 33, 33, 34, 31, 1, 23, 1, 1, 1, 1, 23, 1, 1, 27, 27, 1, 1, 1, 31, 1, 1, 42, 1, 1, 1, 31, 1, 1, 1, 1, 31, 1, 1, 27, 27, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 23, 1, 1, 27, 27, 1, 1, 1, 1, 1, 1, 1, 20, 22, 32, 34, 1, 20, 22, 1, 31, 1, 1, 27, 27, 1, 1, 1, 1, 1, 1, 1, 24, 26, 1, 1, 1, 24, 26, 1, 1, 1, 1, 27, 27, 1, 1, 1, 1, 20, 22, 1, 24, 26, 1, 1, 1, 28, 30, 1, 1, 1, 1, 27, 27, 1, 1, 1, 1, 24, 26, 1, 24, 26, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31, 31, 32, 33, 33, 34, 28, 30, 36, 28, 30, 32, 33, 33, 33, 33, 33, 33, 33, 33, 34] } }, { CONSTANT_NAME: "MT_MOON_B1F", height: 14, width: 14, id: "3C", Name: "MtMoonB1F", blockset: "CAVERN", connections: {}, warps: [{ row: "5", col: "5", dest: "MT_MOON_1F", src: "MT_MOON_B1F" }, { row: "17", col: "11", dest: "MT_MOON_B2F", src: "MT_MOON_B1F" }, { row: "25", col: "9", dest: "MT_MOON_1F", src: "MT_MOON_B1F" }, { row: "25", col: "15", dest: "MT_MOON_1F", src: "MT_MOON_B1F" }, { row: "21", col: "17", dest: "MT_MOON_B2F", src: "MT_MOON_B1F" }, { row: "13", col: "27", dest: "MT_MOON_B2F", src: "MT_MOON_B1F" }, { row: "23", col: "3", dest: "MT_MOON_B2F", src: "MT_MOON_B1F" }, { row: "27", col: "3", dest: "LAST_MAP", src: "MT_MOON_B1F" }], mapData: { type: "Buffer", data: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 63, 63, 63, 63, 3, 3, 63, 63, 3, 3, 3, 3, 3, 3, 25, 60, 25, 61, 3, 3, 61, 25, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 25, 25, 3, 3, 3, 63, 63, 63, 63, 63, 63, 3, 3, 3, 25, 25, 3, 3, 3, 25, 25, 25, 25, 25, 61, 3, 3, 3, 25, 25, 3, 3, 3, 25, 60, 25, 25, 25, 25, 3, 3, 3, 25, 25, 3, 3, 3, 3, 3, 3, 3, 3, 63, 63, 3, 3, 25, 25, 63, 63, 63, 63, 63, 63, 63, 3, 61, 25, 3, 3, 25, 25, 25, 25, 25, 25, 25, 25, 60, 3, 25, 25, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 25, 25, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 25, 25, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 25, 25, 3, 3, 3, 3, 3, 63, 63, 63, 63, 63, 63, 63, 25, 25, 3, 3, 3, 3, 3, 25, 60, 25, 25, 25, 25, 25, 25, 25] } }, { CONSTANT_NAME: "MT_MOON_B2F", height: 18, width: 20, id: "3D", Name: "MtMoonB2F", blockset: "CAVERN", connections: {}, warps: [{ row: "25", col: "9", dest: "MT_MOON_B1F", src: "MT_MOON_B2F" }, { row: "21", col: "17", dest: "MT_MOON_B1F", src: "MT_MOON_B2F" }, { row: "15", col: "27", dest: "MT_MOON_B1F", src: "MT_MOON_B2F" }, { row: "5", col: "7", dest: "MT_MOON_B1F", src: "MT_MOON_B2F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 21, 21, 47, 20, 21, 21, 21, 21, 21, 21, 22, 47, 46, 46, 46, 46, 46, 46, 46, 46, 25, 25, 47, 102, 29, 29, 29, 69, 25, 68, 30, 47, 65, 66, 46, 64, 65, 66, 46, 46, 25, 25, 47, 25, 61, 25, 20, 21, 25, 21, 22, 47, 25, 26, 1, 28, 41, 30, 1, 1, 25, 25, 47, 51, 51, 51, 28, 29, 41, 43, 26, 47, 25, 26, 62, 1, 1, 1, 13, 1, 46, 46, 46, 46, 46, 47, 25, 25, 25, 28, 30, 47, 25, 26, 1, 1, 1, 1, 1, 1, 46, 46, 1, 1, 1, 47, 51, 51, 25, 51, 51, 47, 25, 25, 21, 21, 22, 20, 21, 21, 25, 48, 1, 1, 1, 46, 46, 46, 25, 46, 46, 47, 25, 25, 68, 41, 30, 28, 41, 69, 25, 26, 1, 1, 1, 24, 25, 25, 25, 25, 25, 47, 61, 25, 72, 1, 1, 1, 1, 73, 25, 26, 1, 1, 1, 24, 25, 25, 51, 51, 51, 47, 51, 51, 74, 71, 71, 71, 71, 75, 25, 26, 1, 1, 1, 24, 25, 25, 47, 46, 46, 46, 46, 64, 65, 66, 46, 47, 46, 46, 25, 26, 1, 1, 1, 24, 25, 25, 47, 25, 25, 25, 25, 28, 41, 30, 25, 47, 25, 25, 25, 26, 1, 1, 1, 24, 25, 25, 47, 25, 25, 25, 25, 25, 25, 25, 25, 47, 25, 44, 29, 30, 1, 1, 1, 24, 25, 25, 47, 61, 25, 25, 25, 25, 25, 25, 25, 47, 25, 26, 1, 1, 1, 1, 1, 24, 25, 25, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 25, 26, 1, 1, 1, 1, 1, 24, 25, 25, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 25, 26, 1, 1, 1, 1, 1, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] } }, { CONSTANT_NAME: "CERULEAN_TRASHED_HOUSE", height: 4, width: 4, id: "3E", Name: "CeruleanTrashedHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "CERULEAN_TRASHED_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "CERULEAN_TRASHED_HOUSE" }, { row: "3", col: "0", dest: "LAST_MAP", src: "CERULEAN_TRASHED_HOUSE" }], mapData: { type: "Buffer", data: [26, 31, 22, 23, 30, 28, 29, 27, 15, 32, 33, 15, 6, 11, 27, 34] } }, { CONSTANT_NAME: "CERULEAN_TRADE_HOUSE", height: 4, width: 4, id: "3F", Name: "CeruleanTradeHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "CERULEAN_TRADE_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "CERULEAN_TRADE_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "CERULEAN_POKECENTER", height: 4, width: 7, id: "40", Name: "CeruleanPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "CERULEAN_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "CERULEAN_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "CERULEAN_GYM", height: 7, width: 5, id: "41", Name: "CeruleanGym", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "13", dest: "LAST_MAP", src: "CERULEAN_GYM" }, { row: "5", col: "13", dest: "LAST_MAP", src: "CERULEAN_GYM" }], mapData: { type: "Buffer", data: [20, 20, 33, 20, 20, 21, 35, 34, 35, 22, 21, 30, 30, 31, 22, 21, 28, 29, 32, 22, 21, 27, 5, 23, 22, 21, 26, 5, 25, 22, 24, 24, 4, 24, 24] } }, { CONSTANT_NAME: "BIKE_SHOP", height: 4, width: 4, id: "42", Name: "BikeShop", blockset: "CLUB", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "BIKE_SHOP" }, { row: "3", col: "7", dest: "LAST_MAP", src: "BIKE_SHOP" }], mapData: { type: "Buffer", data: [4, 5, 2, 3, 8, 8, 6, 7, 11, 10, 10, 10, 10, 1, 10, 9] } }, { CONSTANT_NAME: "CERULEAN_MART", height: 4, width: 4, id: "43", Name: "CeruleanMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "CERULEAN_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "CERULEAN_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "MT_MOON_POKECENTER", height: 4, width: 7, id: "44", Name: "MtMoonPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "MT_MOON_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "MT_MOON_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "CERULEAN_TRASHED_HOUSE_COPY", height: 4, width: 4, id: "45" }, { CONSTANT_NAME: "ROUTE_5_GATE", height: 3, width: 4, id: "46", Name: "Route5Gate", blockset: "GATE", connections: {}, warps: [{ row: "3", col: "5", dest: "LAST_MAP", src: "ROUTE_5_GATE" }, { row: "4", col: "5", dest: "LAST_MAP", src: "ROUTE_5_GATE" }, { row: "3", col: "0", dest: "LAST_MAP", src: "ROUTE_5_GATE" }, { row: "4", col: "0", dest: "LAST_MAP", src: "ROUTE_5_GATE" }], mapData: { type: "Buffer", data: [22, 107, 106, 23, 2, 9, 8, 1, 24, 108, 105, 25] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_ROUTE_5", height: 4, width: 4, id: "47", Name: "UndergroundPathRoute5", blockset: "GATE", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_5" }, { row: "4", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_5" }, { row: "4", col: "4", dest: "UNDERGROUND_PATH_NORTH_SOUTH", src: "UNDERGROUND_PATH_ROUTE_5" }], mapData: { type: "Buffer", data: [6, 3, 3, 7, 17, 21, 20, 16, 8, 0, 5, 9, 14, 15, 12, 13] } }, { CONSTANT_NAME: "DAYCARE", height: 4, width: 4, id: "48", Name: "Daycare", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "DAYCARE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "DAYCARE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "ROUTE_6_GATE", height: 3, width: 4, id: "49", Name: "Route6Gate", blockset: "GATE", connections: {}, warps: [{ row: "3", col: "5", dest: "LAST_MAP", src: "ROUTE_6_GATE" }, { row: "4", col: "5", dest: "LAST_MAP", src: "ROUTE_6_GATE" }, { row: "3", col: "0", dest: "LAST_MAP", src: "ROUTE_6_GATE" }, { row: "4", col: "0", dest: "LAST_MAP", src: "ROUTE_6_GATE" }], mapData: { type: "Buffer", data: [22, 107, 106, 23, 2, 9, 8, 1, 24, 108, 105, 25] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_ROUTE_6", height: 4, width: 4, id: "4A", Name: "UndergroundPathRoute6", blockset: "GATE", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_6" }, { row: "4", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_6" }, { row: "4", col: "4", dest: "UNDERGROUND_PATH_NORTH_SOUTH", src: "UNDERGROUND_PATH_ROUTE_6" }], mapData: { type: "Buffer", data: [6, 3, 3, 7, 17, 21, 20, 16, 8, 0, 5, 9, 14, 15, 12, 13] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_ROUTE_6_COPY", height: 4, width: 4, id: "4B" }, { CONSTANT_NAME: "ROUTE_7_GATE", height: 4, width: 3, id: "4C", Name: "Route7Gate", blockset: "GATE", connections: {}, warps: [{ row: "0", col: "3", dest: "LAST_MAP", src: "ROUTE_7_GATE" }, { row: "0", col: "4", dest: "LAST_MAP", src: "ROUTE_7_GATE" }, { row: "5", col: "3", dest: "LAST_MAP", src: "ROUTE_7_GATE" }, { row: "5", col: "4", dest: "LAST_MAP", src: "ROUTE_7_GATE" }], mapData: { type: "Buffer", data: [28, 31, 29, 112, 33, 111, 110, 37, 109, 24, 30, 25] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_ROUTE_7", height: 4, width: 4, id: "4D", Name: "UndergroundPathRoute7", blockset: "GATE", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_7" }, { row: "4", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_7" }, { row: "4", col: "4", dest: "UNDERGROUND_PATH_WEST_EAST", src: "UNDERGROUND_PATH_ROUTE_7" }], mapData: { type: "Buffer", data: [6, 3, 3, 7, 17, 21, 20, 16, 8, 0, 5, 9, 14, 15, 12, 13] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_ROUTE_7_COPY", height: 4, width: 4, id: "4E", warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_7_COPY" }, { row: "4", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_7_COPY" }, { row: "4", col: "4", dest: "UNDERGROUND_PATH_WEST_EAST", src: "UNDERGROUND_PATH_ROUTE_7_COPY" }] }, { CONSTANT_NAME: "ROUTE_8_GATE", height: 4, width: 3, id: "4F", Name: "Route8Gate", blockset: "GATE", connections: {}, warps: [{ row: "0", col: "3", dest: "LAST_MAP", src: "ROUTE_8_GATE" }, { row: "0", col: "4", dest: "LAST_MAP", src: "ROUTE_8_GATE" }, { row: "5", col: "3", dest: "LAST_MAP", src: "ROUTE_8_GATE" }, { row: "5", col: "4", dest: "LAST_MAP", src: "ROUTE_8_GATE" }], mapData: { type: "Buffer", data: [28, 31, 29, 112, 33, 111, 110, 37, 109, 24, 30, 25] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_ROUTE_8", height: 4, width: 4, id: "50", Name: "UndergroundPathRoute8", blockset: "GATE", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_8" }, { row: "4", col: "7", dest: "LAST_MAP", src: "UNDERGROUND_PATH_ROUTE_8" }, { row: "4", col: "4", dest: "UNDERGROUND_PATH_WEST_EAST", src: "UNDERGROUND_PATH_ROUTE_8" }], mapData: { type: "Buffer", data: [6, 3, 3, 7, 17, 21, 20, 16, 8, 0, 5, 9, 14, 15, 12, 13] } }, { CONSTANT_NAME: "ROCK_TUNNEL_POKECENTER", height: 4, width: 7, id: "51", Name: "RockTunnelPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "ROCK_TUNNEL_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "ROCK_TUNNEL_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "ROCK_TUNNEL_1F", height: 18, width: 20, id: "52", Name: "RockTunnel1F", blockset: "CAVERN", connections: {}, warps: [{ row: "15", col: "3", dest: "LAST_MAP", src: "ROCK_TUNNEL_1F" }, { row: "15", col: "0", dest: "LAST_MAP", src: "ROCK_TUNNEL_1F" }, { row: "15", col: "33", dest: "LAST_MAP", src: "ROCK_TUNNEL_1F" }, { row: "15", col: "35", dest: "LAST_MAP", src: "ROCK_TUNNEL_1F" }, { row: "37", col: "3", dest: "ROCK_TUNNEL_B1F", src: "ROCK_TUNNEL_1F" }, { row: "5", col: "3", dest: "ROCK_TUNNEL_B1F", src: "ROCK_TUNNEL_1F" }, { row: "17", col: "11", dest: "ROCK_TUNNEL_B1F", src: "ROCK_TUNNEL_1F" }, { row: "37", col: "17", dest: "ROCK_TUNNEL_B1F", src: "ROCK_TUNNEL_1F" }], mapData: { type: "Buffer", data: [20, 22, 32, 34, 20, 25, 22, 32, 34, 20, 25, 25, 25, 22, 20, 25, 22, 2, 2, 2, 24, 26, 40, 1, 24, 25, 26, 62, 1, 28, 29, 29, 29, 30, 28, 29, 30, 1, 40, 2, 28, 30, 1, 1, 28, 29, 30, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 23, 23, 1, 1, 1, 1, 1, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 31, 31, 1, 1, 1, 1, 1, 31, 32, 34, 2, 1, 1, 2, 32, 34, 32, 34, 1, 1, 23, 23, 1, 1, 23, 1, 1, 23, 1, 40, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31, 31, 1, 1, 31, 1, 1, 31, 1, 1, 31, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 23, 1, 1, 23, 1, 1, 1, 1, 1, 2, 32, 34, 32, 34, 32, 34, 32, 34, 2, 31, 31, 1, 1, 31, 1, 1, 1, 1, 1, 1, 1, 23, 1, 1, 1, 23, 1, 1, 40, 23, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31, 1, 1, 1, 31, 1, 1, 1, 31, 31, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 1, 1, 1, 23, 1, 1, 1, 23, 23, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 31, 1, 1, 1, 31, 1, 1, 1, 31, 31, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 1, 1, 1, 23, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31, 1, 1, 1, 31, 20, 21, 21, 21, 22, 42, 1, 1, 1, 1, 20, 21, 22, 1, 1, 1, 1, 1, 1, 23, 24, 25, 25, 25, 26, 1, 1, 1, 1, 1, 24, 25, 26, 1, 1, 1, 1, 1, 1, 31, 24, 25, 25, 25, 26, 1, 1, 62, 1, 1, 24, 25, 26, 20, 21, 21, 21, 21, 21, 22, 28, 29, 29, 29, 30, 78, 81, 82, 77, 78, 28, 29, 30, 28, 29, 29, 29, 29, 29, 30] } }, { CONSTANT_NAME: "POWER_PLANT", height: 18, width: 20, id: "53", Name: "PowerPlant", blockset: "FACILITY", connections: {}, warps: [{ row: "4", col: "35", dest: "LAST_MAP", src: "POWER_PLANT" }, { row: "5", col: "35", dest: "LAST_MAP", src: "POWER_PLANT" }, { row: "0", col: "11", dest: "LAST_MAP", src: "POWER_PLANT" }], mapData: { type: "Buffer", data: [64, 97, 97, 97, 104, 101, 101, 105, 101, 101, 101, 101, 105, 101, 101, 101, 101, 101, 101, 105, 68, 7, 6, 14, 112, 7, 49, 93, 6, 7, 7, 14, 70, 6, 26, 53, 53, 25, 6, 93, 68, 14, 14, 14, 104, 42, 103, 105, 99, 43, 97, 89, 70, 56, 49, 6, 53, 28, 14, 93, 64, 99, 14, 103, 92, 56, 49, 93, 99, 14, 6, 68, 70, 6, 14, 6, 56, 14, 49, 93, 68, 14, 14, 14, 92, 6, 49, 93, 14, 14, 49, 68, 70, 56, 14, 6, 14, 6, 6, 93, 112, 14, 14, 14, 92, 56, 14, 113, 14, 14, 14, 68, 70, 14, 14, 56, 14, 49, 6, 93, 104, 101, 101, 65, 64, 65, 101, 105, 99, 43, 97, 68, 86, 73, 88, 14, 87, 73, 73, 81, 92, 7, 14, 14, 112, 14, 49, 93, 73, 73, 73, 72, 73, 73, 73, 73, 73, 88, 82, 70, 92, 14, 14, 14, 82, 14, 14, 93, 6, 29, 29, 29, 14, 29, 29, 29, 29, 14, 68, 70, 96, 97, 42, 14, 92, 6, 56, 93, 7, 6, 26, 53, 28, 53, 53, 53, 29, 14, 68, 70, 100, 14, 14, 14, 68, 7, 14, 113, 14, 29, 29, 29, 29, 29, 29, 29, 29, 14, 68, 70, 68, 49, 97, 97, 42, 43, 97, 98, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 85, 70, 68, 14, 14, 7, 6, 56, 14, 102, 7, 6, 56, 6, 6, 6, 7, 49, 6, 7, 14, 93, 104, 99, 14, 103, 104, 101, 42, 86, 14, 14, 14, 49, 7, 14, 14, 14, 7, 14, 49, 93, 92, 56, 14, 6, 107, 14, 14, 14, 14, 6, 14, 14, 14, 49, 6, 49, 6, 6, 6, 93, 92, 14, 49, 6, 107, 42, 103, 97, 97, 101, 97, 97, 64, 99, 6, 43, 97, 97, 101, 105, 68, 14, 14, 49, 92, 14, 14, 7, 6, 14, 14, 6, 68, 30, 14, 29, 29, 32, 28, 70, 72, 88, 44, 87, 72, 73, 73, 73, 73, 73, 73, 73, 72, 73, 73, 73, 73, 73, 73, 74] } }, { CONSTANT_NAME: "ROUTE_11_GATE_1F", height: 5, width: 4, id: "54", Name: "Route11Gate1F", blockset: "GATE", connections: {}, warps: [{ row: "0", col: "4", dest: "LAST_MAP", src: "ROUTE_11_GATE_1F" }, { row: "0", col: "5", dest: "LAST_MAP", src: "ROUTE_11_GATE_1F" }, { row: "7", col: "4", dest: "LAST_MAP", src: "ROUTE_11_GATE_1F" }, { row: "7", col: "5", dest: "LAST_MAP", src: "ROUTE_11_GATE_1F" }, { row: "6", col: "8", dest: "ROUTE_11_GATE_2F", src: "ROUTE_11_GATE_1F" }], mapData: { type: "Buffer", data: [28, 31, 31, 29, 50, 33, 33, 49, 102, 0, 0, 103, 41, 37, 38, 30, 24, 30, 48, 35] } }, { CONSTANT_NAME: "DIGLETTS_CAVE_ROUTE_11", height: 4, width: 4, id: "55", Name: "DiglettsCaveRoute11", blockset: "CAVERN", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "DIGLETTS_CAVE_ROUTE_11" }, { row: "3", col: "7", dest: "LAST_MAP", src: "DIGLETTS_CAVE_ROUTE_11" }, { row: "4", col: "4", dest: "DIGLETTS_CAVE", src: "DIGLETTS_CAVE_ROUTE_11" }], mapData: { type: "Buffer", data: [125, 125, 125, 125, 6, 1, 1, 125, 6, 1, 39, 125, 10, 36, 4, 125] } }, { CONSTANT_NAME: "ROUTE_11_GATE_2F", height: 4, width: 4, id: "56", Name: "Route11Gate2F", blockset: "GATE", connections: {}, warps: [{ row: "7", col: "7", dest: "ROUTE_11_GATE_1F", src: "ROUTE_11_GATE_2F" }], mapData: { type: "Buffer", data: [52, 51, 51, 53, 54, 0, 0, 55, 56, 59, 56, 59, 58, 0, 0, 57] } }, { CONSTANT_NAME: "ROUTE_12_GATE_1F", height: 4, width: 5, id: "57", Name: "Route12Gate1F", blockset: "GATE", connections: {}, warps: [{ row: "4", col: "0", dest: "LAST_MAP", src: "ROUTE_12_GATE_1F" }, { row: "5", col: "0", dest: "LAST_MAP", src: "ROUTE_12_GATE_1F" }, { row: "4", col: "7", dest: "LAST_MAP", src: "ROUTE_12_GATE_1F" }, { row: "5", col: "7", dest: "LAST_MAP", src: "ROUTE_12_GATE_1F" }, { row: "8", col: "6", dest: "ROUTE_12_GATE_2F", src: "ROUTE_12_GATE_1F" }], mapData: { type: "Buffer", data: [22, 39, 113, 43, 23, 2, 9, 0, 76, 1, 2, 9, 0, 20, 29, 24, 42, 114, 1, 35] } }, { CONSTANT_NAME: "BILLS_HOUSE", height: 4, width: 4, id: "58", Name: "BillsHouse", blockset: "INTERIOR", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "BILLS_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "BILLS_HOUSE" }], mapData: { type: "Buffer", data: [4, 5, 6, 7, 8, 9, 10, 11, 1, 2, 14, 14, 3, 12, 3, 3] } }, { CONSTANT_NAME: "VERMILION_POKECENTER", height: 4, width: 7, id: "59", Name: "VermilionPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "VERMILION_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "VERMILION_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "POKEMON_FAN_CLUB", height: 4, width: 4, id: "5A", Name: "PokemonFanClub", blockset: "INTERIOR", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "POKEMON_FAN_CLUB" }, { row: "3", col: "7", dest: "LAST_MAP", src: "POKEMON_FAN_CLUB" }], mapData: { type: "Buffer", data: [23, 18, 19, 22, 25, 16, 17, 15, 24, 20, 21, 26, 3, 12, 3, 3] } }, { CONSTANT_NAME: "VERMILION_MART", height: 4, width: 4, id: "5B", Name: "VermilionMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "VERMILION_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "VERMILION_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "VERMILION_GYM", height: 9, width: 5, id: "5C", Name: "VermilionGym", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "17", dest: "LAST_MAP", src: "VERMILION_GYM" }, { row: "5", col: "17", dest: "LAST_MAP", src: "VERMILION_GYM" }], mapData: { type: "Buffer", data: [44, 37, 37, 38, 44, 44, 5, 5, 5, 44, 42, 43, 5, 42, 43, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 5, 41, 5, 40, 5, 5, 17, 5, 16, 5, 5, 5, 4, 5, 5] } }, { CONSTANT_NAME: "VERMILION_PIDGEY_HOUSE", height: 4, width: 4, id: "5D", Name: "VermilionPidgeyHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "VERMILION_PIDGEY_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "VERMILION_PIDGEY_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "VERMILION_DOCK", height: 6, width: 14, id: "5E", Name: "VermilionDock", blockset: "SHIP_PORT", connections: {}, warps: [{ row: "14", col: "0", dest: "LAST_MAP", src: "VERMILION_DOCK" }, { row: "14", col: "2", dest: "SS_ANNE_1F", src: "VERMILION_DOCK" }], mapData: { type: "Buffer", data: [14, 12, 12, 12, 12, 12, 22, 21, 12, 12, 3, 12, 12, 14, 19, 1, 1, 1, 1, 4, 5, 6, 7, 1, 1, 1, 1, 12, 17, 13, 13, 13, 13, 8, 9, 10, 11, 13, 13, 13, 13, 12, 17, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 17, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 16, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 14] } }, { CONSTANT_NAME: "SS_ANNE_1F", height: 9, width: 20, id: "5F", Name: "SSAnne1F", blockset: "SHIP", connections: {}, warps: [{ row: "26", col: "0", dest: "VERMILION_DOCK", src: "SS_ANNE_1F" }, { row: "27", col: "0", dest: "VERMILION_DOCK", src: "SS_ANNE_1F" }, { row: "31", col: "8", dest: "SS_ANNE_1F_ROOMS", src: "SS_ANNE_1F" }, { row: "23", col: "8", dest: "SS_ANNE_1F_ROOMS", src: "SS_ANNE_1F" }, { row: "19", col: "8", dest: "SS_ANNE_1F_ROOMS", src: "SS_ANNE_1F" }, { row: "15", col: "8", dest: "SS_ANNE_1F_ROOMS", src: "SS_ANNE_1F" }, { row: "11", col: "8", dest: "SS_ANNE_1F_ROOMS", src: "SS_ANNE_1F" }, { row: "7", col: "8", dest: "SS_ANNE_1F_ROOMS", src: "SS_ANNE_1F" }, { row: "2", col: "6", dest: "SS_ANNE_2F", src: "SS_ANNE_1F" }, { row: "37", col: "15", dest: "SS_ANNE_B1F", src: "SS_ANNE_1F" }, { row: "3", col: "16", dest: "SS_ANNE_KITCHEN", src: "SS_ANNE_1F" }], mapData: { type: "Buffer", data: [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 16, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 16, 13, 12, 12, 12, 12, 12, 18, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 19, 16, 15, 5, 5, 5, 5, 17, 14, 24, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 14, 16, 1, 20, 21, 20, 21, 20, 21, 20, 21, 20, 21, 2, 2, 20, 21, 3, 22, 13, 14, 16, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 16, 13, 14, 16, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 16, 13, 14, 16, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 23, 13, 12, 20, 58, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 2, 12] } }, { CONSTANT_NAME: "SS_ANNE_2F", height: 9, width: 20, id: "60", Name: "SSAnne2F", blockset: "SHIP", connections: {}, warps: [{ row: "9", col: "11", dest: "SS_ANNE_2F_ROOMS", src: "SS_ANNE_2F" }, { row: "13", col: "11", dest: "SS_ANNE_2F_ROOMS", src: "SS_ANNE_2F" }, { row: "17", col: "11", dest: "SS_ANNE_2F_ROOMS", src: "SS_ANNE_2F" }, { row: "21", col: "11", dest: "SS_ANNE_2F_ROOMS", src: "SS_ANNE_2F" }, { row: "25", col: "11", dest: "SS_ANNE_2F_ROOMS", src: "SS_ANNE_2F" }, { row: "29", col: "11", dest: "SS_ANNE_2F_ROOMS", src: "SS_ANNE_2F" }, { row: "2", col: "4", dest: "SS_ANNE_1F", src: "SS_ANNE_2F" }, { row: "2", col: "12", dest: "SS_ANNE_3F", src: "SS_ANNE_2F" }, { row: "36", col: "4", dest: "SS_ANNE_CAPTAINS_ROOM", src: "SS_ANNE_2F" }], mapData: { type: "Buffer", data: [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 18, 5, 17, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 18, 5, 17, 14, 26, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 24, 13, 14, 16, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 16, 13, 14, 16, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 18, 19, 16, 13, 14, 16, 15, 5, 25, 5, 25, 5, 25, 5, 25, 5, 25, 5, 25, 5, 19, 16, 4, 13, 14, 24, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 12, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12] } }, { CONSTANT_NAME: "SS_ANNE_3F", height: 3, width: 10, id: "61", Name: "SSAnne3F", blockset: "SHIP", connections: {}, warps: [{ row: "0", col: "3", dest: "SS_ANNE_BOW", src: "SS_ANNE_3F" }, { row: "19", col: "3", dest: "SS_ANNE_2F", src: "SS_ANNE_3F" }], mapData: { type: "Buffer", data: [18, 5, 5, 5, 5, 5, 5, 5, 5, 17, 29, 4, 4, 4, 4, 4, 4, 4, 4, 28, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] } }, { CONSTANT_NAME: "SS_ANNE_B1F", height: 4, width: 15, id: "62", Name: "SSAnneB1F", blockset: "SHIP", connections: {}, warps: [{ row: "23", col: "3", dest: "SS_ANNE_B1F_ROOMS", src: "SS_ANNE_B1F" }, { row: "19", col: "3", dest: "SS_ANNE_B1F_ROOMS", src: "SS_ANNE_B1F" }, { row: "15", col: "3", dest: "SS_ANNE_B1F_ROOMS", src: "SS_ANNE_B1F" }, { row: "11", col: "3", dest: "SS_ANNE_B1F_ROOMS", src: "SS_ANNE_B1F" }, { row: "7", col: "3", dest: "SS_ANNE_B1F_ROOMS", src: "SS_ANNE_B1F" }, { row: "27", col: "5", dest: "SS_ANNE_1F", src: "SS_ANNE_B1F" }], mapData: { type: "Buffer", data: [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 18, 5, 5, 25, 5, 25, 5, 25, 5, 25, 5, 25, 5, 5, 17, 14, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 52, 13, 12, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 12] } }, { CONSTANT_NAME: "SS_ANNE_BOW", height: 7, width: 10, id: "63", Name: "SSAnneBow", blockset: "SHIP", connections: {}, warps: [{ row: "13", col: "6", dest: "SS_ANNE_3F", src: "SS_ANNE_BOW" }, { row: "13", col: "7", dest: "SS_ANNE_3F", src: "SS_ANNE_BOW" }], mapData: { type: "Buffer", data: [35, 35, 38, 38, 38, 38, 38, 38, 38, 38, 35, 30, 31, 36, 36, 36, 13, 12, 12, 12, 30, 31, 41, 39, 4, 4, 15, 17, 12, 12, 32, 41, 4, 4, 4, 4, 36, 13, 12, 12, 33, 34, 4, 39, 4, 4, 1, 12, 12, 12, 40, 33, 34, 4, 4, 4, 13, 12, 12, 12, 35, 40, 37, 37, 37, 37, 37, 37, 37, 37] } }, { CONSTANT_NAME: "SS_ANNE_KITCHEN", height: 8, width: 7, id: "64", Name: "SSAnneKitchen", blockset: "SHIP", connections: {}, warps: [{ row: "6", col: "0", dest: "SS_ANNE_1F", src: "SS_ANNE_KITCHEN" }], mapData: { type: "Buffer", data: [10, 10, 10, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 6, 11, 6, 11, 6, 53, 11, 42, 11, 42, 11, 42, 53, 11, 42, 11, 42, 11, 42, 53, 11, 44, 11, 44, 11, 44, 11, 11, 11, 11, 11, 11, 11, 11, 43, 45, 43, 45, 43, 45, 43] } }, { CONSTANT_NAME: "SS_ANNE_CAPTAINS_ROOM", height: 4, width: 3, id: "65", Name: "SSAnneCaptainsRoom", blockset: "SHIP", connections: {}, warps: [{ row: "0", col: "7", dest: "SS_ANNE_2F", src: "SS_ANNE_CAPTAINS_ROOM" }], mapData: { type: "Buffer", data: [48, 49, 47, 50, 51, 7, 11, 11, 7, 46, 11, 11] } }, { CONSTANT_NAME: "SS_ANNE_1F_ROOMS", height: 8, width: 12, id: "66", Name: "SSAnne1FRooms", blockset: "SHIP", connections: {}, warps: [{ row: "0", col: "0", dest: "SS_ANNE_1F", src: "SS_ANNE_1F_ROOMS" }, { row: "10", col: "0", dest: "SS_ANNE_1F", src: "SS_ANNE_1F_ROOMS" }, { row: "20", col: "0", dest: "SS_ANNE_1F", src: "SS_ANNE_1F_ROOMS" }, { row: "0", col: "10", dest: "SS_ANNE_1F", src: "SS_ANNE_1F_ROOMS" }, { row: "10", col: "10", dest: "SS_ANNE_1F", src: "SS_ANNE_1F_ROOMS" }, { row: "20", col: "10", dest: "SS_ANNE_1F", src: "SS_ANNE_1F_ROOMS" }], mapData: { type: "Buffer", data: [9, 10, 12, 12, 12, 9, 10, 12, 12, 12, 9, 10, 11, 11, 12, 12, 12, 11, 11, 12, 12, 12, 11, 11, 6, 54, 12, 12, 12, 6, 54, 12, 12, 12, 6, 54, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 10, 12, 12, 12, 9, 10, 12, 12, 12, 9, 10, 11, 11, 12, 12, 12, 11, 11, 12, 12, 12, 11, 11, 6, 54, 12, 12, 12, 6, 54, 12, 12, 12, 6, 54] } }, { CONSTANT_NAME: "SS_ANNE_2F_ROOMS", height: 8, width: 12, id: "67", Name: "SSAnne2FRooms", blockset: "SHIP", connections: {}, warps: [{ row: "2", col: "5", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "3", col: "5", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "12", col: "5", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "13", col: "5", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "22", col: "5", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "23", col: "5", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "2", col: "15", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "3", col: "15", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "12", col: "15", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "13", col: "15", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "22", col: "15", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }, { row: "23", col: "15", dest: "SS_ANNE_2F", src: "SS_ANNE_2F_ROOMS" }], mapData: { type: "Buffer", data: [55, 56, 12, 12, 12, 55, 56, 12, 12, 12, 55, 56, 59, 57, 12, 12, 12, 59, 57, 12, 12, 12, 59, 57, 11, 27, 12, 12, 12, 11, 27, 12, 12, 12, 11, 27, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 55, 56, 12, 12, 12, 55, 56, 12, 12, 12, 55, 56, 59, 57, 12, 12, 12, 59, 57, 12, 12, 12, 59, 57, 11, 27, 12, 12, 12, 11, 27, 12, 12, 12, 11, 27] } }, { CONSTANT_NAME: "SS_ANNE_B1F_ROOMS", height: 8, width: 12, id: "68", Name: "SSAnneB1FRooms", blockset: "SHIP", connections: {}, warps: [{ row: "2", col: "5", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "3", col: "5", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "12", col: "5", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "13", col: "5", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "22", col: "5", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "23", col: "5", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "2", col: "15", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "3", col: "15", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "12", col: "15", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }, { row: "13", col: "15", dest: "SS_ANNE_B1F", src: "SS_ANNE_B1F_ROOMS" }], mapData: { type: "Buffer", data: [55, 56, 12, 12, 12, 55, 56, 12, 12, 12, 55, 56, 59, 57, 12, 12, 12, 59, 57, 12, 12, 12, 59, 57, 11, 27, 12, 12, 12, 11, 27, 12, 12, 12, 11, 27, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 55, 56, 12, 12, 12, 55, 56, 12, 12, 12, 55, 56, 59, 57, 12, 12, 12, 59, 57, 12, 12, 12, 59, 57, 11, 27, 12, 12, 12, 11, 27, 12, 12, 12, 11, 27] } }, { CONSTANT_NAME: "UNUSED_MAP_69", height: 0, width: 0, id: "69" }, { CONSTANT_NAME: "UNUSED_MAP_6A", height: 0, width: 0, id: "6A" }, { CONSTANT_NAME: "UNUSED_MAP_6B", height: 0, width: 0, id: "6B" }, { CONSTANT_NAME: "VICTORY_ROAD_1F", height: 9, width: 10, id: "6C", Name: "VictoryRoad1F", blockset: "CAVERN", connections: {}, warps: [{ row: "8", col: "17", dest: "LAST_MAP", src: "VICTORY_ROAD_1F" }, { row: "9", col: "17", dest: "LAST_MAP", src: "VICTORY_ROAD_1F" }, { row: "1", col: "1", dest: "VICTORY_ROAD_2F", src: "VICTORY_ROAD_1F" }], mapData: { type: "Buffer", data: [98, 5, 125, 125, 78, 109, 116, 12, 9, 125, 77, 1, 122, 125, 10, 12, 13, 1, 1, 122, 6, 1, 20, 21, 21, 21, 21, 21, 22, 1, 125, 1, 28, 45, 29, 43, 44, 45, 30, 1, 125, 14, 106, 91, 111, 24, 26, 76, 1, 13, 77, 15, 24, 25, 112, 24, 26, 79, 5, 114, 14, 13, 102, 29, 37, 29, 30, 13, 108, 116, 12, 5, 1, 8, 1, 94, 1, 1, 7, 125, 83, 4, 4, 1, 36, 125, 4, 81, 125, 125] } }, { CONSTANT_NAME: "UNUSED_MAP_6D", height: 0, width: 0, id: "6D" }, { CONSTANT_NAME: "UNUSED_MAP_6E", height: 0, width: 0, id: "6E" }, { CONSTANT_NAME: "UNUSED_MAP_6F", height: 0, width: 0, id: "6F" }, { CONSTANT_NAME: "UNUSED_MAP_70", height: 0, width: 0, id: "70" }, { CONSTANT_NAME: "LANCES_ROOM", height: 13, width: 13, id: "71", Name: "LancesRoom", blockset: "GYM", connections: {}, warps: [{ row: "24", col: "16", dest: "AGATHAS_ROOM", src: "LANCES_ROOM" }, { row: "5", col: "0", dest: "CHAMPIONS_ROOM", src: "LANCES_ROOM" }, { row: "6", col: "0", dest: "CHAMPIONS_ROOM", src: "LANCES_ROOM" }], mapData: { type: "Buffer", data: [73, 1, 49, 50, 1, 74, 3, 3, 3, 73, 49, 50, 74, 75, 50, 5, 5, 49, 76, 3, 3, 3, 75, 5, 5, 76, 75, 50, 5, 5, 49, 76, 3, 3, 3, 75, 5, 5, 76, 75, 50, 5, 5, 49, 76, 3, 3, 3, 82, 49, 50, 111, 75, 50, 5, 5, 49, 76, 3, 3, 3, 3, 3, 3, 3, 75, 50, 5, 5, 49, 76, 3, 3, 3, 3, 3, 3, 3, 82, 86, 114, 115, 78, 111, 3, 3, 3, 3, 3, 3, 3, 3, 75, 5, 5, 76, 3, 3, 3, 73, 1, 1, 1, 74, 3, 75, 5, 5, 76, 3, 3, 3, 75, 5, 5, 5, 112, 3, 75, 5, 5, 76, 3, 3, 3, 75, 83, 70, 70, 111, 3, 75, 5, 5, 76, 3, 3, 3, 75, 76, 3, 3, 3, 3, 75, 5, 5, 85, 72, 72, 72, 91, 76, 3, 3, 3, 3, 82, 70, 70, 70, 70, 70, 70, 70, 111, 3, 3, 3] } }, { CONSTANT_NAME: "UNUSED_MAP_72", height: 0, width: 0, id: "72" }, { CONSTANT_NAME: "UNUSED_MAP_73", height: 0, width: 0, id: "73" }, { CONSTANT_NAME: "UNUSED_MAP_74", height: 0, width: 0, id: "74" }, { CONSTANT_NAME: "UNUSED_MAP_75", height: 0, width: 0, id: "75" }, { CONSTANT_NAME: "HALL_OF_FAME", height: 4, width: 5, id: "76", Name: "HallOfFame", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "7", dest: "CHAMPIONS_ROOM", src: "HALL_OF_FAME" }, { row: "5", col: "7", dest: "CHAMPIONS_ROOM", src: "HALL_OF_FAME" }], mapData: { type: "Buffer", data: [20, 20, 101, 20, 20, 24, 24, 55, 24, 24, 24, 24, 24, 24, 24, 24, 24, 108, 24, 24] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_NORTH_SOUTH", height: 24, width: 4, id: "77", Name: "UndergroundPathNorthSouth", blockset: "UNDERGROUND", connections: {}, warps: [{ row: "5", col: "4", dest: "UNDERGROUND_PATH_ROUTE_5", src: "UNDERGROUND_PATH_NORTH_SOUTH" }, { row: "2", col: "41", dest: "UNDERGROUND_PATH_ROUTE_6", src: "UNDERGROUND_PATH_NORTH_SOUTH" }], mapData: { type: "Buffer", data: [1, 1, 1, 1, 13, 9, 3, 12, 13, 4, 5, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 4, 2, 12, 13, 15, 2, 12, 1, 14, 14, 1, 1, 1, 1, 1] } }, { CONSTANT_NAME: "CHAMPIONS_ROOM", height: 4, width: 4, id: "78", Name: "ChampionsRoom", blockset: "GYM", connections: {}, warps: [{ row: "3", col: "7", dest: "LANCES_ROOM", src: "CHAMPIONS_ROOM" }, { row: "4", col: "7", dest: "LANCES_ROOM", src: "CHAMPIONS_ROOM" }, { row: "3", col: "0", dest: "HALL_OF_FAME", src: "CHAMPIONS_ROOM" }, { row: "4", col: "0", dest: "HALL_OF_FAME", src: "CHAMPIONS_ROOM" }], mapData: { type: "Buffer", data: [73, 49, 50, 74, 75, 5, 5, 76, 75, 5, 5, 76, 82, 49, 50, 111] } }, { CONSTANT_NAME: "UNDERGROUND_PATH_WEST_EAST", height: 4, width: 25, id: "79", Name: "UndergroundPathWestEast", blockset: "UNDERGROUND", connections: {}, warps: [{ row: "2", col: "5", dest: "UNDERGROUND_PATH_ROUTE_7", src: "UNDERGROUND_PATH_WEST_EAST" }, { row: "47", col: "2", dest: "UNDERGROUND_PATH_ROUTE_8", src: "UNDERGROUND_PATH_WEST_EAST" }], mapData: { type: "Buffer", data: [13, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 12, 13, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 12, 13, 15, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 12, 1, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 1] } }, { CONSTANT_NAME: "CELADON_MART_1F", height: 4, width: 10, id: "7A", Name: "CeladonMart1F", blockset: "LOBBY", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "CELADON_MART_1F" }, { row: "3", col: "7", dest: "LAST_MAP", src: "CELADON_MART_1F" }, { row: "16", col: "7", dest: "LAST_MAP", src: "CELADON_MART_1F" }, { row: "17", col: "7", dest: "LAST_MAP", src: "CELADON_MART_1F" }, { row: "12", col: "1", dest: "CELADON_MART_2F", src: "CELADON_MART_1F" }, { row: "1", col: "1", dest: "CELADON_MART_ELEVATOR", src: "CELADON_MART_1F" }], mapData: { type: "Buffer", data: [12, 13, 1, 24, 1, 25, 2, 37, 7, 1, 11, 11, 11, 20, 11, 23, 11, 11, 18, 9, 11, 11, 11, 21, 17, 38, 11, 11, 11, 9, 11, 8, 11, 11, 11, 11, 11, 11, 8, 11] } }, { CONSTANT_NAME: "CELADON_MART_2F", height: 4, width: 10, id: "7B", Name: "CeladonMart2F", blockset: "LOBBY", connections: {}, warps: [{ row: "12", col: "1", dest: "CELADON_MART_1F", src: "CELADON_MART_2F" }, { row: "16", col: "1", dest: "CELADON_MART_3F", src: "CELADON_MART_2F" }, { row: "1", col: "1", dest: "CELADON_MART_ELEVATOR", src: "CELADON_MART_2F" }], mapData: { type: "Buffer", data: [12, 13, 24, 25, 1, 1, 3, 37, 2, 1, 11, 11, 20, 23, 11, 26, 26, 11, 26, 26, 11, 11, 21, 22, 11, 30, 30, 11, 30, 30, 11, 11, 11, 11, 11, 10, 10, 11, 10, 10] } }, { CONSTANT_NAME: "CELADON_MART_3F", height: 4, width: 10, id: "7C", Name: "CeladonMart3F", blockset: "LOBBY", connections: {}, warps: [{ row: "12", col: "1", dest: "CELADON_MART_4F", src: "CELADON_MART_3F" }, { row: "16", col: "1", dest: "CELADON_MART_2F", src: "CELADON_MART_3F" }, { row: "1", col: "1", dest: "CELADON_MART_ELEVATOR", src: "CELADON_MART_3F" }], mapData: { type: "Buffer", data: [12, 13, 36, 36, 36, 36, 2, 37, 3, 14, 11, 11, 11, 11, 11, 11, 11, 11, 11, 18, 11, 4, 5, 6, 11, 11, 16, 17, 17, 17, 11, 4, 5, 6, 11, 11, 20, 11, 10, 10] } }, { CONSTANT_NAME: "CELADON_MART_4F", height: 4, width: 10, id: "7D", Name: "CeladonMart4F", blockset: "LOBBY", connections: {}, warps: [{ row: "12", col: "1", dest: "CELADON_MART_3F", src: "CELADON_MART_4F" }, { row: "16", col: "1", dest: "CELADON_MART_5F", src: "CELADON_MART_4F" }, { row: "1", col: "1", dest: "CELADON_MART_ELEVATOR", src: "CELADON_MART_4F" }], mapData: { type: "Buffer", data: [12, 13, 1, 1, 1, 1, 3, 37, 2, 1, 11, 26, 26, 26, 26, 11, 26, 26, 26, 11, 11, 30, 30, 30, 30, 11, 30, 30, 30, 11, 17, 17, 17, 17, 39, 11, 10, 10, 10, 11] } }, { CONSTANT_NAME: "CELADON_MART_ROOF", height: 4, width: 10, id: "7E", Name: "CeladonMartRoof", blockset: "LOBBY", connections: {}, warps: [{ row: "15", col: "2", dest: "CELADON_MART_5F", src: "CELADON_MART_ROOF" }], mapData: { type: "Buffer", data: [54, 28, 28, 28, 28, 27, 59, 63, 63, 65, 54, 33, 29, 31, 32, 32, 60, 67, 42, 65, 54, 32, 32, 33, 29, 31, 32, 32, 32, 65, 54, 55, 55, 55, 55, 55, 55, 55, 55, 65] } }, { CONSTANT_NAME: "CELADON_MART_ELEVATOR", height: 2, width: 2, id: "7F", Name: "CeladonMartElevator", blockset: "LOBBY", connections: {}, warps: [{ row: "1", col: "3", dest: "CELADON_MART_1F", src: "CELADON_MART_ELEVATOR" }, { row: "2", col: "3", dest: "CELADON_MART_1F", src: "CELADON_MART_ELEVATOR" }], mapData: { type: "Buffer", data: [42, 43, 40, 41] } }, { CONSTANT_NAME: "CELADON_MANSION_1F", height: 6, width: 4, id: "80", Name: "CeladonMansion1F", blockset: "MANSION", connections: {}, warps: [{ row: "4", col: "11", dest: "LAST_MAP", src: "CELADON_MANSION_1F" }, { row: "5", col: "11", dest: "LAST_MAP", src: "CELADON_MANSION_1F" }, { row: "4", col: "0", dest: "LAST_MAP", src: "CELADON_MANSION_1F" }, { row: "7", col: "1", dest: "CELADON_MANSION_2F", src: "CELADON_MANSION_1F" }, { row: "2", col: "1", dest: "CELADON_MANSION_2F", src: "CELADON_MANSION_1F" }], mapData: { type: "Buffer", data: [15, 1, 2, 3, 36, 42, 6, 7, 11, 11, 4, 7, 16, 11, 8, 7, 12, 12, 13, 7, 7, 7, 62, 7] } }, { CONSTANT_NAME: "CELADON_MANSION_2F", height: 6, width: 4, id: "81", Name: "CeladonMansion2F", blockset: "MANSION", connections: {}, warps: [{ row: "6", col: "1", dest: "CELADON_MANSION_3F", src: "CELADON_MANSION_2F" }, { row: "7", col: "1", dest: "CELADON_MANSION_1F", src: "CELADON_MANSION_2F" }, { row: "2", col: "1", dest: "CELADON_MANSION_1F", src: "CELADON_MANSION_2F" }, { row: "4", col: "1", dest: "CELADON_MANSION_3F", src: "CELADON_MANSION_2F" }], mapData: { type: "Buffer", data: [15, 20, 21, 25, 17, 17, 26, 7, 39, 11, 4, 7, 43, 18, 19, 7, 47, 12, 13, 7, 7, 7, 7, 7] } }, { CONSTANT_NAME: "CELADON_MANSION_3F", height: 6, width: 4, id: "82", Name: "CeladonMansion3F", blockset: "MANSION", connections: {}, warps: [{ row: "6", col: "1", dest: "CELADON_MANSION_2F", src: "CELADON_MANSION_3F" }, { row: "7", col: "1", dest: "CELADON_MANSION_ROOF", src: "CELADON_MANSION_3F" }, { row: "2", col: "1", dest: "CELADON_MANSION_ROOF", src: "CELADON_MANSION_3F" }, { row: "4", col: "1", dest: "CELADON_MANSION_2F", src: "CELADON_MANSION_3F" }], mapData: { type: "Buffer", data: [15, 22, 23, 24, 14, 40, 41, 7, 35, 44, 45, 7, 10, 11, 8, 7, 12, 12, 13, 7, 7, 7, 7, 7] } }, { CONSTANT_NAME: "CELADON_MANSION_ROOF", height: 6, width: 4, id: "83", Name: "CeladonMansionRoof", blockset: "MANSION", connections: {}, warps: [{ row: "6", col: "1", dest: "CELADON_MANSION_3F", src: "CELADON_MANSION_ROOF" }, { row: "2", col: "1", dest: "CELADON_MANSION_3F", src: "CELADON_MANSION_ROOF" }, { row: "2", col: "7", dest: "CELADON_MANSION_ROOF_HOUSE", src: "CELADON_MANSION_ROOF" }], mapData: { type: "Buffer", data: [69, 59, 28, 27, 61, 7, 29, 29, 33, 34, 29, 29, 37, 38, 29, 29, 51, 31, 30, 29, 32, 31, 31, 30] } }, { CONSTANT_NAME: "CELADON_MANSION_ROOF_HOUSE", height: 4, width: 4, id: "84", Name: "CeladonMansionRoofHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "CELADON_MANSION_ROOF", src: "CELADON_MANSION_ROOF_HOUSE" }, { row: "3", col: "7", dest: "CELADON_MANSION_ROOF", src: "CELADON_MANSION_ROOF_HOUSE" }], mapData: { type: "Buffer", data: [5, 18, 19, 9, 15, 20, 21, 15, 15, 24, 25, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "CELADON_POKECENTER", height: 4, width: 7, id: "85", Name: "CeladonPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "CELADON_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "CELADON_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "CELADON_GYM", height: 9, width: 5, id: "86", Name: "CeladonGym", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "17", dest: "LAST_MAP", src: "CELADON_GYM" }, { row: "5", col: "17", dest: "LAST_MAP", src: "CELADON_GYM" }], mapData: { type: "Buffer", data: [1, 1, 1, 1, 1, 51, 56, 58, 57, 51, 51, 60, 51, 61, 51, 51, 59, 63, 62, 51, 51, 52, 5, 52, 51, 53, 5, 5, 5, 54, 51, 52, 5, 52, 51, 5, 50, 5, 49, 5, 5, 5, 4, 5, 5] } }, { CONSTANT_NAME: "GAME_CORNER", height: 9, width: 10, id: "87", Name: "GameCorner", blockset: "LOBBY", connections: {}, warps: [{ row: "15", col: "17", dest: "LAST_MAP", src: "GAME_CORNER" }, { row: "16", col: "17", dest: "LAST_MAP", src: "GAME_CORNER" }, { row: "17", col: "4", dest: "ROCKET_HIDEOUT_B1F", src: "GAME_CORNER" }], mapData: { type: "Buffer", data: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 10, 10, 10, 10, 52, 42, 42, 42, 67, 42, 47, 47, 47, 51, 32, 32, 27, 27, 27, 27, 58, 32, 32, 58, 32, 32, 58, 32, 32, 58, 57, 31, 33, 57, 31, 33, 57, 31, 33, 57, 57, 31, 33, 57, 31, 33, 57, 31, 33, 57, 56, 31, 33, 56, 31, 33, 56, 31, 33, 56, 32, 32, 32, 32, 32, 32, 32, 40, 41, 32] } }, { CONSTANT_NAME: "CELADON_MART_5F", height: 4, width: 10, id: "88", Name: "CeladonMart5F", blockset: "LOBBY", connections: {}, warps: [{ row: "12", col: "1", dest: "CELADON_MART_ROOF", src: "CELADON_MART_5F" }, { row: "16", col: "1", dest: "CELADON_MART_4F", src: "CELADON_MART_5F" }, { row: "1", col: "1", dest: "CELADON_MART_ELEVATOR", src: "CELADON_MART_5F" }], mapData: { type: "Buffer", data: [12, 13, 24, 25, 1, 1, 2, 37, 3, 1, 11, 11, 20, 23, 11, 26, 26, 11, 26, 26, 11, 11, 21, 22, 11, 30, 30, 11, 30, 30, 11, 11, 11, 11, 11, 10, 10, 11, 10, 10] } }, { CONSTANT_NAME: "GAME_CORNER_PRIZE_ROOM", height: 4, width: 5, id: "89", Name: "GameCornerPrizeRoom", blockset: "LOBBY", connections: {}, warps: [{ row: "4", col: "7", dest: "LAST_MAP", src: "GAME_CORNER_PRIZE_ROOM" }, { row: "5", col: "7", dest: "LAST_MAP", src: "GAME_CORNER_PRIZE_ROOM" }], mapData: { type: "Buffer", data: [63, 64, 64, 64, 63, 62, 62, 62, 62, 62, 32, 32, 32, 32, 32, 27, 27, 61, 27, 27] } }, { CONSTANT_NAME: "CELADON_DINER", height: 4, width: 5, id: "8A", Name: "CeladonDiner", blockset: "LOBBY", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "CELADON_DINER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "CELADON_DINER" }], mapData: { type: "Buffer", data: [44, 42, 46, 50, 48, 29, 32, 33, 20, 11, 45, 32, 33, 20, 11, 49, 40, 41, 21, 17] } }, { CONSTANT_NAME: "CELADON_CHIEF_HOUSE", height: 4, width: 4, id: "8B", Name: "CeladonChiefHouse", blockset: "MANSION", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "CELADON_CHIEF_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "CELADON_CHIEF_HOUSE" }], mapData: { type: "Buffer", data: [68, 64, 63, 68, 11, 66, 67, 11, 11, 70, 71, 11, 54, 65, 11, 54] } }, { CONSTANT_NAME: "CELADON_HOTEL", height: 4, width: 7, id: "8C", Name: "CeladonHotel", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "CELADON_HOTEL" }, { row: "4", col: "7", dest: "LAST_MAP", src: "CELADON_HOTEL" }], mapData: { type: "Buffer", data: [12, 12, 12, 12, 12, 12, 14, 7, 7, 7, 7, 7, 7, 7, 8, 15, 15, 15, 15, 15, 15, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "LAVENDER_POKECENTER", height: 4, width: 7, id: "8D", Name: "LavenderPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "LAVENDER_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "LAVENDER_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "POKEMON_TOWER_1F", height: 9, width: 10, id: "8E", Name: "PokemonTower1F", blockset: "CEMETERY", connections: {}, warps: [{ row: "10", col: "17", dest: "LAST_MAP", src: "POKEMON_TOWER_1F" }, { row: "11", col: "17", dest: "LAST_MAP", src: "POKEMON_TOWER_1F" }, { row: "18", col: "9", dest: "POKEMON_TOWER_2F", src: "POKEMON_TOWER_1F" }], mapData: { type: "Buffer", data: [1, 1, 1, 3, 10, 6, 7, 3, 1, 1, 1, 1, 16, 6, 14, 14, 14, 6, 8, 1, 1, 12, 57, 14, 14, 14, 14, 14, 32, 13, 1, 10, 14, 14, 14, 14, 14, 14, 14, 7, 1, 57, 14, 14, 14, 14, 14, 14, 14, 18, 1, 28, 14, 14, 14, 14, 14, 14, 14, 30, 1, 12, 14, 14, 14, 14, 37, 63, 63, 13, 1, 1, 20, 14, 14, 14, 37, 14, 11, 1, 1, 1, 1, 5, 28, 14, 30, 5, 1, 1] } }, { CONSTANT_NAME: "POKEMON_TOWER_2F", height: 9, width: 10, id: "8F", Name: "PokemonTower2F", blockset: "CEMETERY", connections: {}, warps: [{ row: "3", col: "9", dest: "POKEMON_TOWER_3F", src: "POKEMON_TOWER_2F" }, { row: "18", col: "9", dest: "POKEMON_TOWER_1F", src: "POKEMON_TOWER_2F" }], mapData: { type: "Buffer", data: [1, 1, 1, 3, 96, 91, 97, 3, 1, 1, 1, 1, 16, 91, 81, 14, 14, 6, 8, 1, 1, 12, 94, 76, 54, 14, 54, 54, 95, 13, 1, 10, 14, 54, 82, 76, 76, 54, 14, 7, 1, 21, 14, 82, 82, 14, 82, 82, 14, 22, 1, 28, 14, 54, 82, 14, 14, 54, 14, 30, 1, 12, 87, 82, 82, 82, 14, 79, 88, 13, 1, 1, 20, 29, 54, 54, 54, 29, 11, 1, 1, 1, 1, 5, 83, 86, 84, 5, 1, 1] } }, { CONSTANT_NAME: "POKEMON_TOWER_3F", height: 9, width: 10, id: "90", Name: "PokemonTower3F", blockset: "CEMETERY", connections: {}, warps: [{ row: "3", col: "9", dest: "POKEMON_TOWER_2F", src: "POKEMON_TOWER_3F" }, { row: "18", col: "9", dest: "POKEMON_TOWER_4F", src: "POKEMON_TOWER_3F" }], mapData: { type: "Buffer", data: [1, 1, 1, 3, 10, 6, 7, 3, 1, 1, 1, 1, 16, 91, 81, 14, 14, 6, 8, 1, 1, 12, 57, 19, 79, 79, 79, 79, 88, 13, 1, 10, 14, 80, 14, 14, 14, 19, 23, 7, 1, 17, 14, 80, 14, 82, 14, 81, 14, 18, 1, 28, 14, 80, 14, 14, 14, 81, 14, 30, 1, 12, 57, 78, 14, 76, 76, 77, 76, 13, 1, 1, 20, 86, 14, 14, 14, 86, 11, 1, 1, 1, 1, 5, 83, 86, 84, 5, 1, 1] } }, { CONSTANT_NAME: "POKEMON_TOWER_4F", height: 9, width: 10, id: "91", Name: "PokemonTower4F", blockset: "CEMETERY", connections: {}, warps: [{ row: "3", col: "9", dest: "POKEMON_TOWER_5F", src: "POKEMON_TOWER_4F" }, { row: "18", col: "9", dest: "POKEMON_TOWER_3F", src: "POKEMON_TOWER_4F" }], mapData: { type: "Buffer", data: [1, 1, 1, 3, 10, 6, 7, 3, 1, 1, 1, 1, 9, 91, 81, 14, 14, 6, 8, 1, 1, 12, 94, 19, 23, 81, 79, 76, 95, 13, 1, 10, 14, 19, 23, 102, 79, 78, 77, 7, 1, 21, 79, 14, 79, 77, 79, 14, 14, 22, 1, 28, 14, 14, 103, 78, 79, 19, 103, 30, 1, 12, 57, 102, 19, 14, 19, 23, 32, 13, 1, 1, 20, 29, 23, 78, 79, 29, 11, 1, 1, 1, 1, 5, 83, 85, 30, 5, 1, 1] } }, { CONSTANT_NAME: "POKEMON_TOWER_5F", height: 9, width: 10, id: "92", Name: "PokemonTower5F", blockset: "CEMETERY", connections: {}, warps: [{ row: "3", col: "9", dest: "POKEMON_TOWER_4F", src: "POKEMON_TOWER_5F" }, { row: "18", col: "9", dest: "POKEMON_TOWER_6F", src: "POKEMON_TOWER_5F" }], mapData: { type: "Buffer", data: [1, 1, 1, 3, 10, 6, 7, 3, 1, 1, 1, 1, 16, 91, 101, 54, 54, 6, 8, 1, 1, 12, 87, 105, 76, 54, 76, 106, 88, 13, 1, 58, 54, 54, 79, 79, 54, 54, 14, 7, 1, 17, 80, 82, 54, 51, 54, 82, 81, 18, 1, 28, 80, 54, 54, 79, 76, 54, 14, 30, 1, 12, 94, 103, 79, 14, 79, 104, 95, 13, 1, 1, 20, 29, 54, 54, 54, 29, 11, 1, 1, 1, 1, 5, 28, 29, 30, 5, 1, 1] } }, { CONSTANT_NAME: "POKEMON_TOWER_6F", height: 9, width: 10, id: "93", Name: "PokemonTower6F", blockset: "CEMETERY", connections: {}, warps: [{ row: "18", col: "9", dest: "POKEMON_TOWER_5F", src: "POKEMON_TOWER_6F" }, { row: "9", col: "16", dest: "POKEMON_TOWER_7F", src: "POKEMON_TOWER_6F" }], mapData: { type: "Buffer", data: [1, 1, 1, 3, 96, 91, 97, 3, 1, 1, 1, 1, 16, 93, 6, 54, 54, 6, 8, 1, 1, 12, 94, 78, 76, 54, 82, 54, 95, 13, 1, 10, 54, 54, 54, 54, 82, 54, 76, 7, 1, 90, 82, 80, 79, 79, 76, 54, 54, 22, 1, 28, 79, 54, 76, 76, 79, 23, 79, 30, 1, 12, 87, 54, 79, 54, 79, 81, 88, 13, 1, 1, 20, 29, 79, 54, 82, 29, 11, 1, 1, 1, 1, 5, 48, 29, 30, 5, 1, 1] } }, { CONSTANT_NAME: "POKEMON_TOWER_7F", height: 9, width: 10, id: "94", Name: "PokemonTower7F", blockset: "CEMETERY", connections: {}, warps: [{ row: "9", col: "16", dest: "POKEMON_TOWER_6F", src: "POKEMON_TOWER_7F" }], mapData: { type: "Buffer", data: [1, 1, 1, 3, 2, 2, 2, 3, 1, 1, 1, 1, 16, 2, 108, 14, 109, 2, 8, 1, 1, 12, 2, 2, 57, 14, 32, 2, 2, 13, 1, 2, 2, 2, 57, 14, 32, 2, 2, 2, 1, 2, 2, 2, 57, 14, 32, 2, 53, 2, 1, 2, 2, 2, 57, 14, 32, 2, 2, 2, 1, 12, 2, 2, 28, 14, 30, 2, 2, 13, 1, 1, 20, 2, 2, 14, 2, 2, 11, 1, 1, 1, 1, 5, 49, 29, 30, 5, 1, 1] } }, { CONSTANT_NAME: "MR_FUJIS_HOUSE", height: 4, width: 4, id: "95", Name: "MrFujisHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "MR_FUJIS_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "MR_FUJIS_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "LAVENDER_MART", height: 4, width: 4, id: "96", Name: "LavenderMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "LAVENDER_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "LAVENDER_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "LAVENDER_CUBONE_HOUSE", height: 4, width: 4, id: "97", Name: "LavenderCuboneHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "LAVENDER_CUBONE_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "LAVENDER_CUBONE_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "FUCHSIA_MART", height: 4, width: 4, id: "98", Name: "FuchsiaMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "FUCHSIA_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "FUCHSIA_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "FUCHSIA_BILLS_GRANDPAS_HOUSE", height: 4, width: 4, id: "99", Name: "FuchsiaBillsGrandpasHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "FUCHSIA_BILLS_GRANDPAS_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "FUCHSIA_BILLS_GRANDPAS_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "FUCHSIA_POKECENTER", height: 4, width: 7, id: "9A", Name: "FuchsiaPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "FUCHSIA_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "FUCHSIA_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "WARDENS_HOUSE", height: 4, width: 5, id: "9B", Name: "WardensHouse", blockset: "LAB", connections: {}, warps: [{ row: "4", col: "7", dest: "LAST_MAP", src: "WARDENS_HOUSE" }, { row: "5", col: "7", dest: "LAST_MAP", src: "WARDENS_HOUSE" }], mapData: { type: "Buffer", data: [1, 1, 1, 1, 1, 41, 7, 32, 29, 30, 7, 7, 7, 7, 7, 13, 7, 12, 7, 14] } }, { CONSTANT_NAME: "SAFARI_ZONE_GATE", height: 3, width: 4, id: "9C", Name: "SafariZoneGate", blockset: "GATE", connections: {}, warps: [{ row: "3", col: "5", dest: "LAST_MAP", src: "SAFARI_ZONE_GATE" }, { row: "4", col: "5", dest: "LAST_MAP", src: "SAFARI_ZONE_GATE" }, { row: "3", col: "0", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_GATE" }, { row: "4", col: "0", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_GATE" }], mapData: { type: "Buffer", data: [22, 107, 106, 23, 2, 9, 8, 1, 24, 108, 105, 25] } }, { CONSTANT_NAME: "FUCHSIA_GYM", height: 9, width: 5, id: "9D", Name: "FuchsiaGym", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "17", dest: "LAST_MAP", src: "FUCHSIA_GYM" }, { row: "5", col: "17", dest: "LAST_MAP", src: "FUCHSIA_GYM" }], mapData: { type: "Buffer", data: [1, 1, 1, 1, 1, 5, 45, 46, 48, 5, 45, 5, 47, 48, 5, 47, 45, 5, 47, 5, 5, 45, 45, 47, 5, 46, 47, 5, 48, 5, 5, 45, 45, 45, 5, 5, 50, 5, 49, 5, 5, 5, 4, 5, 5] } }, { CONSTANT_NAME: "FUCHSIA_MEETING_ROOM", height: 4, width: 7, id: "9E", Name: "FuchsiaMeetingRoom", blockset: "LAB", connections: {}, warps: [{ row: "4", col: "7", dest: "LAST_MAP", src: "FUCHSIA_MEETING_ROOM" }, { row: "5", col: "7", dest: "LAST_MAP", src: "FUCHSIA_MEETING_ROOM" }], mapData: { type: "Buffer", data: [6, 6, 1, 3, 1, 53, 1, 7, 7, 56, 57, 7, 15, 7, 52, 7, 54, 55, 55, 55, 55, 13, 7, 12, 7, 7, 7, 14] } }, { CONSTANT_NAME: "SEAFOAM_ISLANDS_B1F", height: 9, width: 15, id: "9F", Name: "SeafoamIslandsB1F", blockset: "CAVERN", connections: {}, warps: [{ row: "4", col: "2", dest: "SEAFOAM_ISLANDS_B2F", src: "SEAFOAM_ISLANDS_B1F" }, { row: "7", col: "5", dest: "SEAFOAM_ISLANDS_1F", src: "SEAFOAM_ISLANDS_B1F" }, { row: "13", col: "7", dest: "SEAFOAM_ISLANDS_B2F", src: "SEAFOAM_ISLANDS_B1F" }, { row: "19", col: "15", dest: "SEAFOAM_ISLANDS_B2F", src: "SEAFOAM_ISLANDS_B1F" }, { row: "23", col: "15", dest: "SEAFOAM_ISLANDS_1F", src: "SEAFOAM_ISLANDS_B1F" }, { row: "25", col: "11", dest: "SEAFOAM_ISLANDS_B2F", src: "SEAFOAM_ISLANDS_B1F" }, { row: "25", col: "3", dest: "SEAFOAM_ISLANDS_1F", src: "SEAFOAM_ISLANDS_B1F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 46, 20, 21, 21, 21, 22, 46, 46, 46, 46, 46, 46, 1, 39, 1, 1, 24, 25, 44, 45, 30, 1, 1, 62, 1, 46, 46, 1, 20, 124, 22, 24, 25, 26, 1, 1, 109, 1, 1, 1, 46, 46, 1, 24, 44, 30, 24, 60, 26, 1, 119, 109, 120, 1, 1, 46, 46, 1, 102, 30, 20, 25, 25, 26, 1, 1, 76, 94, 94, 94, 46, 46, 1, 1, 1, 24, 25, 25, 25, 21, 22, 1, 1, 40, 1, 46, 46, 1, 1, 1, 102, 29, 29, 29, 45, 30, 1, 1, 1, 1, 46, 46, 1, 1, 1, 1, 1, 109, 1, 1, 40, 109, 62, 1, 1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46] } }, { CONSTANT_NAME: "SEAFOAM_ISLANDS_B2F", height: 9, width: 15, id: "A0", Name: "SeafoamIslandsB2F", blockset: "CAVERN", connections: {}, warps: [{ row: "5", col: "3", dest: "SEAFOAM_ISLANDS_B1F", src: "SEAFOAM_ISLANDS_B2F" }, { row: "5", col: "13", dest: "SEAFOAM_ISLANDS_B3F", src: "SEAFOAM_ISLANDS_B2F" }, { row: "13", col: "7", dest: "SEAFOAM_ISLANDS_B1F", src: "SEAFOAM_ISLANDS_B2F" }, { row: "19", col: "15", dest: "SEAFOAM_ISLANDS_B1F", src: "SEAFOAM_ISLANDS_B2F" }, { row: "25", col: "3", dest: "SEAFOAM_ISLANDS_B3F", src: "SEAFOAM_ISLANDS_B2F" }, { row: "25", col: "11", dest: "SEAFOAM_ISLANDS_B1F", src: "SEAFOAM_ISLANDS_B2F" }, { row: "25", col: "14", dest: "SEAFOAM_ISLANDS_B3F", src: "SEAFOAM_ISLANDS_B2F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 1, 62, 1, 1, 1, 1, 1, 1, 1, 1, 20, 60, 22, 46, 46, 1, 1, 1, 1, 20, 21, 22, 1, 1, 1, 28, 45, 30, 46, 46, 1, 1, 1, 1, 24, 61, 26, 1, 120, 82, 119, 1, 1, 46, 46, 20, 21, 21, 21, 25, 25, 25, 21, 21, 22, 1, 1, 1, 46, 46, 28, 29, 41, 29, 29, 29, 43, 25, 25, 26, 20, 124, 22, 46, 46, 1, 40, 1, 1, 1, 1, 28, 45, 29, 30, 24, 25, 26, 46, 46, 1, 1, 1, 1, 1, 1, 16, 1, 62, 1, 28, 121, 30, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46] } }, { CONSTANT_NAME: "SEAFOAM_ISLANDS_B3F", height: 9, width: 15, id: "A1", Name: "SeafoamIslandsB3F", blockset: "CAVERN", connections: {}, warps: [{ row: "5", col: "12", dest: "SEAFOAM_ISLANDS_B2F", src: "SEAFOAM_ISLANDS_B3F" }, { row: "8", col: "6", dest: "SEAFOAM_ISLANDS_B4F", src: "SEAFOAM_ISLANDS_B3F" }, { row: "25", col: "4", dest: "SEAFOAM_ISLANDS_B4F", src: "SEAFOAM_ISLANDS_B3F" }, { row: "25", col: "3", dest: "SEAFOAM_ISLANDS_B2F", src: "SEAFOAM_ISLANDS_B3F" }, { row: "25", col: "14", dest: "SEAFOAM_ISLANDS_B2F", src: "SEAFOAM_ISLANDS_B3F" }, { row: "20", col: "17", dest: "SEAFOAM_ISLANDS_B4F", src: "SEAFOAM_ISLANDS_B3F" }, { row: "21", col: "17", dest: "SEAFOAM_ISLANDS_B4F", src: "SEAFOAM_ISLANDS_B3F" }], mapData: { type: "Buffer", data: [20, 21, 21, 21, 22, 2, 2, 118, 2, 2, 20, 21, 21, 21, 22, 24, 25, 25, 25, 26, 118, 118, 118, 118, 118, 24, 25, 61, 25, 26, 24, 25, 44, 41, 30, 20, 21, 21, 22, 118, 28, 29, 121, 29, 30, 24, 25, 26, 1, 39, 24, 44, 45, 30, 118, 20, 21, 21, 21, 22, 24, 25, 25, 21, 21, 25, 26, 118, 118, 118, 28, 45, 43, 25, 26, 24, 25, 25, 44, 29, 43, 26, 118, 118, 118, 118, 118, 24, 25, 26, 28, 29, 97, 30, 1, 24, 25, 21, 21, 22, 118, 20, 25, 25, 26, 1, 1, 12, 15, 1, 28, 29, 29, 41, 30, 118, 28, 97, 29, 30, 1, 120, 6, 119, 15, 1, 1, 1, 1, 122, 118, 109, 1, 1, 1] } }, { CONSTANT_NAME: "SEAFOAM_ISLANDS_B4F", height: 9, width: 15, id: "A2", Name: "SeafoamIslandsB4F", blockset: "CAVERN", connections: {}, warps: [{ row: "20", col: "17", dest: "SEAFOAM_ISLANDS_B3F", src: "SEAFOAM_ISLANDS_B4F" }, { row: "21", col: "17", dest: "SEAFOAM_ISLANDS_B3F", src: "SEAFOAM_ISLANDS_B4F" }, { row: "11", col: "7", dest: "SEAFOAM_ISLANDS_B3F", src: "SEAFOAM_ISLANDS_B4F" }, { row: "25", col: "4", dest: "SEAFOAM_ISLANDS_B3F", src: "SEAFOAM_ISLANDS_B4F" }], mapData: { type: "Buffer", data: [46, 118, 20, 21, 21, 22, 118, 20, 21, 21, 21, 117, 21, 22, 46, 46, 118, 28, 45, 29, 30, 118, 24, 25, 25, 25, 25, 25, 26, 46, 46, 118, 118, 118, 118, 118, 118, 24, 44, 29, 29, 45, 97, 30, 46, 46, 118, 118, 20, 21, 124, 21, 25, 26, 118, 118, 118, 118, 118, 46, 46, 118, 118, 24, 25, 25, 25, 44, 30, 118, 118, 118, 118, 118, 46, 46, 118, 118, 102, 29, 29, 43, 26, 118, 118, 118, 118, 118, 118, 46, 46, 118, 118, 118, 118, 118, 24, 26, 118, 118, 118, 118, 118, 118, 46, 46, 118, 118, 20, 117, 21, 25, 25, 21, 22, 118, 118, 118, 118, 46, 46, 2, 118, 28, 29, 29, 29, 29, 29, 30, 118, 2, 76, 2, 46] } }, { CONSTANT_NAME: "VERMILION_OLD_ROD_HOUSE", height: 4, width: 4, id: "A3", Name: "VermilionOldRodHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "VERMILION_OLD_ROD_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "VERMILION_OLD_ROD_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "FUCHSIA_GOOD_ROD_HOUSE", height: 4, width: 4, id: "A4", Name: "FuchsiaGoodRodHouse", blockset: "SHIP", connections: {}, warps: [{ row: "2", col: "0", dest: "LAST_MAP", src: "FUCHSIA_GOOD_ROD_HOUSE" }, { row: "2", col: "7", dest: "LAST_MAP", src: "FUCHSIA_GOOD_ROD_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "FUCHSIA_GOOD_ROD_HOUSE" }], mapData: { type: "Buffer", data: [61, 9, 61, 61, 11, 11, 7, 6, 11, 11, 11, 44, 11, 27, 11, 53] } }, { CONSTANT_NAME: "POKEMON_MANSION_1F", height: 14, width: 15, id: "A5", Name: "PokemonMansion1F", blockset: "FACILITY", connections: {}, warps: [{ row: "4", col: "27", dest: "LAST_MAP", src: "POKEMON_MANSION_1F" }, { row: "5", col: "27", dest: "LAST_MAP", src: "POKEMON_MANSION_1F" }, { row: "6", col: "27", dest: "LAST_MAP", src: "POKEMON_MANSION_1F" }, { row: "7", col: "27", dest: "LAST_MAP", src: "POKEMON_MANSION_1F" }, { row: "5", col: "10", dest: "POKEMON_MANSION_2F", src: "POKEMON_MANSION_1F" }, { row: "21", col: "23", dest: "POKEMON_MANSION_B1F", src: "POKEMON_MANSION_1F" }, { row: "26", col: "27", dest: "LAST_MAP", src: "POKEMON_MANSION_1F" }, { row: "27", col: "27", dest: "LAST_MAP", src: "POKEMON_MANSION_1F" }], mapData: { type: "Buffer", data: [64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 92, 6, 14, 14, 83, 14, 17, 17, 17, 17, 17, 14, 14, 14, 93, 92, 119, 14, 71, 70, 14, 14, 14, 14, 14, 14, 64, 99, 14, 93, 68, 14, 67, 14, 70, 14, 83, 88, 14, 87, 88, 85, 14, 14, 70, 80, 73, 73, 88, 6, 7, 70, 14, 14, 14, 6, 56, 71, 14, 93, 68, 17, 58, 59, 10, 14, 70, 14, 67, 67, 49, 56, 14, 49, 93, 68, 17, 63, 59, 10, 83, 74, 73, 73, 73, 88, 6, 14, 87, 81, 68, 17, 63, 59, 10, 70, 14, 14, 14, 6, 7, 14, 14, 14, 93, 68, 17, 63, 59, 10, 70, 14, 14, 14, 72, 14, 88, 14, 87, 81, 68, 17, 63, 59, 10, 70, 14, 11, 11, 11, 14, 6, 82, 7, 93, 68, 17, 63, 59, 10, 70, 14, 14, 14, 14, 14, 14, 68, 14, 70, 68, 17, 63, 59, 10, 70, 14, 11, 11, 11, 78, 14, 68, 14, 70, 68, 17, 63, 59, 10, 70, 14, 14, 14, 14, 14, 14, 6, 14, 70, 72, 88, 63, 59, 87, 74, 73, 73, 73, 73, 73, 73, 6, 14, 6] } }, { CONSTANT_NAME: "CINNABAR_GYM", height: 9, width: 10, id: "A6", Name: "CinnabarGym", blockset: "FACILITY", connections: {}, warps: [{ row: "16", col: "17", dest: "LAST_MAP", src: "CINNABAR_GYM" }, { row: "17", col: "17", dest: "LAST_MAP", src: "CINNABAR_GYM" }], mapData: { type: "Buffer", data: [64, 97, 97, 64, 64, 97, 65, 65, 65, 65, 68, 14, 14, 68, 68, 14, 14, 89, 14, 14, 68, 14, 14, 68, 68, 14, 14, 68, 14, 14, 107, 99, 14, 68, 107, 99, 14, 107, 99, 14, 68, 14, 14, 68, 68, 14, 14, 68, 14, 14, 68, 14, 14, 68, 68, 14, 14, 80, 88, 14, 107, 99, 14, 68, 107, 99, 14, 68, 69, 14, 68, 14, 14, 72, 85, 14, 14, 68, 14, 14, 68, 14, 14, 14, 14, 14, 14, 68, 44, 14] } }, { CONSTANT_NAME: "CINNABAR_LAB", height: 4, width: 9, id: "A7", Name: "CinnabarLab", blockset: "LAB", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "CINNABAR_LAB" }, { row: "3", col: "7", dest: "LAST_MAP", src: "CINNABAR_LAB" }, { row: "8", col: "4", dest: "CINNABAR_LAB_TRADE_ROOM", src: "CINNABAR_LAB" }, { row: "12", col: "4", dest: "CINNABAR_LAB_METRONOME_ROOM", src: "CINNABAR_LAB" }, { row: "16", col: "4", dest: "CINNABAR_LAB_FOSSIL_ROOM", src: "CINNABAR_LAB" }], mapData: { type: "Buffer", data: [23, 23, 23, 23, 23, 23, 23, 23, 23, 9, 3, 10, 23, 23, 23, 23, 23, 23, 7, 7, 7, 25, 24, 1, 24, 1, 24, 7, 12, 7, 7, 7, 7, 7, 7, 7] } }, { CONSTANT_NAME: "CINNABAR_LAB_TRADE_ROOM", height: 4, width: 4, id: "A8", Name: "CinnabarLabTradeRoom", blockset: "LAB", connections: {}, warps: [{ row: "2", col: "7", dest: "CINNABAR_LAB", src: "CINNABAR_LAB_TRADE_ROOM" }, { row: "3", col: "7", dest: "CINNABAR_LAB", src: "CINNABAR_LAB_TRADE_ROOM" }], mapData: { type: "Buffer", data: [9, 3, 1, 10, 7, 16, 17, 7, 7, 20, 21, 7, 13, 12, 7, 14] } }, { CONSTANT_NAME: "CINNABAR_LAB_METRONOME_ROOM", height: 4, width: 4, id: "A9", Name: "CinnabarLabMetronomeRoom", blockset: "LAB", connections: {}, warps: [{ row: "2", col: "7", dest: "CINNABAR_LAB", src: "CINNABAR_LAB_METRONOME_ROOM" }, { row: "3", col: "7", dest: "CINNABAR_LAB", src: "CINNABAR_LAB_METRONOME_ROOM" }], mapData: { type: "Buffer", data: [4, 4, 5, 6, 7, 7, 7, 7, 8, 7, 7, 6, 7, 12, 7, 7] } }, { CONSTANT_NAME: "CINNABAR_LAB_FOSSIL_ROOM", height: 4, width: 4, id: "AA", Name: "CinnabarLabFossilRoom", blockset: "LAB", connections: {}, warps: [{ row: "2", col: "7", dest: "CINNABAR_LAB", src: "CINNABAR_LAB_FOSSIL_ROOM" }, { row: "3", col: "7", dest: "CINNABAR_LAB", src: "CINNABAR_LAB_FOSSIL_ROOM" }], mapData: { type: "Buffer", data: [18, 19, 22, 2, 11, 11, 7, 7, 8, 8, 7, 15, 7, 12, 7, 7] } }, { CONSTANT_NAME: "CINNABAR_POKECENTER", height: 4, width: 7, id: "AB", Name: "CinnabarPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "CINNABAR_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "CINNABAR_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "CINNABAR_MART", height: 4, width: 4, id: "AC", Name: "CinnabarMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "CINNABAR_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "CINNABAR_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "CINNABAR_MART_COPY", height: 4, width: 4, id: "AD" }, { CONSTANT_NAME: "INDIGO_PLATEAU_LOBBY", height: 6, width: 8, id: "AE", Name: "IndigoPlateauLobby", blockset: "POKECENTER", connections: {}, warps: [{ row: "7", col: "11", dest: "LAST_MAP", src: "INDIGO_PLATEAU_LOBBY" }, { row: "8", col: "11", dest: "LAST_MAP", src: "INDIGO_PLATEAU_LOBBY" }, { row: "8", col: "0", dest: "LORELEIS_ROOM", src: "INDIGO_PLATEAU_LOBBY" }], mapData: { type: "Buffer", data: [19, 18, 12, 12, 13, 0, 0, 0, 22, 15, 30, 31, 31, 36, 36, 36, 24, 15, 32, 16, 1, 2, 13, 13, 23, 15, 33, 4, 5, 7, 34, 35, 29, 29, 15, 15, 15, 15, 15, 27, 25, 15, 15, 10, 11, 15, 14, 14] } }, { CONSTANT_NAME: "COPYCATS_HOUSE_1F", height: 4, width: 4, id: "AF", Name: "CopycatsHouse1F", blockset: "REDS_HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "COPYCATS_HOUSE_1F" }, { row: "3", col: "7", dest: "LAST_MAP", src: "COPYCATS_HOUSE_1F" }, { row: "7", col: "1", dest: "COPYCATS_HOUSE_2F", src: "COPYCATS_HOUSE_1F" }], mapData: { type: "Buffer", data: [4, 9, 5, 7, 15, 15, 15, 15, 15, 1, 2, 15, 15, 11, 15, 15] } }, { CONSTANT_NAME: "COPYCATS_HOUSE_2F", height: 4, width: 4, id: "B0", Name: "CopycatsHouse2F", blockset: "REDS_HOUSE", connections: {}, warps: [{ row: "7", col: "1", dest: "COPYCATS_HOUSE_1F", src: "COPYCATS_HOUSE_2F" }], mapData: { type: "Buffer", data: [16, 17, 5, 8, 15, 15, 15, 15, 15, 13, 15, 15, 12, 15, 15, 18] } }, { CONSTANT_NAME: "FIGHTING_DOJO", height: 6, width: 5, id: "B1", Name: "FightingDojo", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "11", dest: "LAST_MAP", src: "FIGHTING_DOJO" }, { row: "5", col: "11", dest: "LAST_MAP", src: "FIGHTING_DOJO" }], mapData: { type: "Buffer", data: [73, 74, 103, 73, 74, 75, 81, 5, 80, 76, 75, 5, 5, 5, 76, 75, 5, 5, 5, 76, 75, 50, 5, 49, 76, 82, 70, 4, 70, 111] } }, { CONSTANT_NAME: "SAFFRON_GYM", height: 9, width: 10, id: "B2", Name: "SaffronGym", blockset: "FACILITY", connections: {}, warps: [{ row: "8", col: "17", dest: "LAST_MAP", src: "SAFFRON_GYM" }, { row: "9", col: "17", dest: "LAST_MAP", src: "SAFFRON_GYM" }, { row: "1", col: "3", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "5", col: "3", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "1", col: "5", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "5", col: "5", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "1", col: "9", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "5", col: "9", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "1", col: "11", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "5", col: "11", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "1", col: "15", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "5", col: "15", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "1", col: "17", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "5", col: "17", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "9", col: "3", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "11", col: "3", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "9", col: "5", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "11", col: "5", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "11", col: "11", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "11", col: "15", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "15", col: "3", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "19", col: "3", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "15", col: "5", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "19", col: "5", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "15", col: "9", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "19", col: "9", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "15", col: "11", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "19", col: "11", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "15", col: "15", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "19", col: "15", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "15", col: "17", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }, { row: "19", col: "17", dest: "SAFFRON_GYM", src: "SAFFRON_GYM" }], mapData: { type: "Buffer", data: [65, 65, 65, 64, 65, 65, 66, 65, 65, 65, 47, 14, 47, 68, 47, 47, 70, 47, 14, 47, 47, 14, 47, 68, 47, 47, 70, 47, 14, 47, 65, 65, 65, 64, 65, 65, 66, 65, 65, 65, 47, 14, 47, 68, 14, 14, 70, 47, 14, 47, 47, 14, 47, 68, 14, 47, 70, 47, 14, 47, 65, 65, 65, 64, 65, 65, 66, 65, 65, 65, 47, 14, 47, 68, 69, 47, 70, 47, 14, 47, 47, 14, 47, 68, 44, 14, 70, 47, 14, 47] } }, { CONSTANT_NAME: "SAFFRON_PIDGEY_HOUSE", height: 4, width: 4, id: "B3", Name: "SaffronPidgeyHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "SAFFRON_PIDGEY_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "SAFFRON_PIDGEY_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "SAFFRON_MART", height: 4, width: 4, id: "B4", Name: "SaffronMart", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "SAFFRON_MART" }, { row: "4", col: "7", dest: "LAST_MAP", src: "SAFFRON_MART" }], mapData: { type: "Buffer", data: [18, 19, 19, 9, 22, 15, 20, 20, 24, 25, 21, 21, 23, 26, 11, 15] } }, { CONSTANT_NAME: "SILPH_CO_1F", height: 9, width: 15, id: "B5", Name: "SilphCo1F", blockset: "FACILITY", connections: {}, warps: [{ row: "10", col: "17", dest: "LAST_MAP", src: "SILPH_CO_1F" }, { row: "11", col: "17", dest: "LAST_MAP", src: "SILPH_CO_1F" }, { row: "26", col: "0", dest: "SILPH_CO_2F", src: "SILPH_CO_1F" }, { row: "20", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_1F" }, { row: "16", col: "10", dest: "SILPH_CO_3F", src: "SILPH_CO_1F" }], mapData: { type: "Buffer", data: [60, 61, 61, 127, 61, 61, 61, 61, 61, 61, 124, 61, 61, 125, 62, 126, 34, 34, 35, 14, 14, 29, 14, 14, 29, 14, 14, 14, 9, 70, 68, 14, 14, 14, 14, 30, 91, 28, 30, 91, 28, 14, 14, 14, 70, 68, 13, 14, 14, 32, 91, 91, 91, 91, 91, 91, 57, 14, 9, 70, 68, 14, 14, 14, 14, 26, 91, 24, 26, 91, 24, 14, 14, 14, 70, 68, 13, 14, 14, 14, 14, 25, 14, 14, 25, 14, 14, 14, 9, 70, 68, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 70, 68, 11, 11, 11, 14, 14, 14, 14, 14, 14, 14, 11, 11, 11, 70, 72, 73, 73, 73, 88, 44, 87, 73, 73, 73, 73, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SAFFRON_POKECENTER", height: 4, width: 7, id: "B6", Name: "SaffronPokecenter", blockset: "POKECENTER", connections: {}, warps: [{ row: "3", col: "7", dest: "LAST_MAP", src: "SAFFRON_POKECENTER" }, { row: "4", col: "7", dest: "LAST_MAP", src: "SAFFRON_POKECENTER" }], mapData: { type: "Buffer", data: [32, 16, 1, 2, 12, 13, 13, 33, 4, 5, 7, 7, 34, 35, 8, 15, 15, 15, 15, 15, 27, 14, 10, 11, 14, 15, 15, 14] } }, { CONSTANT_NAME: "MR_PSYCHICS_HOUSE", height: 4, width: 4, id: "B7", Name: "MrPsychicsHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "MR_PSYCHICS_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "MR_PSYCHICS_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "ROUTE_15_GATE_1F", height: 5, width: 4, id: "B8", Name: "Route15Gate1F", blockset: "GATE", connections: {}, warps: [{ row: "0", col: "4", dest: "LAST_MAP", src: "ROUTE_15_GATE_1F" }, { row: "0", col: "5", dest: "LAST_MAP", src: "ROUTE_15_GATE_1F" }, { row: "7", col: "4", dest: "LAST_MAP", src: "ROUTE_15_GATE_1F" }, { row: "7", col: "5", dest: "LAST_MAP", src: "ROUTE_15_GATE_1F" }, { row: "6", col: "8", dest: "ROUTE_15_GATE_2F", src: "ROUTE_15_GATE_1F" }], mapData: { type: "Buffer", data: [28, 31, 31, 29, 50, 33, 33, 49, 102, 0, 0, 103, 41, 37, 38, 30, 24, 30, 48, 35] } }, { CONSTANT_NAME: "ROUTE_15_GATE_2F", height: 4, width: 4, id: "B9", Name: "Route15Gate2F", blockset: "GATE", connections: {}, warps: [{ row: "7", col: "7", dest: "ROUTE_15_GATE_1F", src: "ROUTE_15_GATE_2F" }], mapData: { type: "Buffer", data: [52, 51, 51, 53, 54, 0, 0, 55, 56, 59, 56, 59, 58, 0, 0, 57] } }, { CONSTANT_NAME: "ROUTE_16_GATE_1F", height: 7, width: 4, id: "BA", Name: "Route16Gate1F", blockset: "GATE", connections: {}, warps: [{ row: "0", col: "8", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "0", col: "9", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "7", col: "8", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "7", col: "9", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "0", col: "2", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "0", col: "3", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "7", col: "2", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "7", col: "3", dest: "LAST_MAP", src: "ROUTE_16_GATE_1F" }, { row: "6", col: "12", dest: "ROUTE_16_GATE_2F", src: "ROUTE_16_GATE_1F" }], mapData: { type: "Buffer", data: [104, 104, 104, 104, 102, 0, 0, 103, 28, 31, 31, 29, 50, 33, 33, 49, 102, 0, 0, 103, 41, 37, 38, 30, 24, 30, 48, 35] } }, { CONSTANT_NAME: "ROUTE_16_GATE_2F", height: 4, width: 4, id: "BB", Name: "Route16Gate2F", blockset: "GATE", connections: {}, warps: [{ row: "7", col: "7", dest: "ROUTE_16_GATE_1F", src: "ROUTE_16_GATE_2F" }], mapData: { type: "Buffer", data: [52, 51, 51, 53, 54, 0, 0, 55, 56, 59, 56, 59, 58, 0, 0, 57] } }, { CONSTANT_NAME: "ROUTE_16_FLY_HOUSE", height: 4, width: 4, id: "BC", Name: "Route16FlyHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "ROUTE_16_FLY_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "ROUTE_16_FLY_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "ROUTE_12_SUPER_ROD_HOUSE", height: 4, width: 4, id: "BD", Name: "Route12SuperRodHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "ROUTE_12_SUPER_ROD_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "ROUTE_12_SUPER_ROD_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "ROUTE_18_GATE_1F", height: 5, width: 4, id: "BE", Name: "Route18Gate1F", blockset: "GATE", connections: {}, warps: [{ row: "0", col: "4", dest: "LAST_MAP", src: "ROUTE_18_GATE_1F" }, { row: "0", col: "5", dest: "LAST_MAP", src: "ROUTE_18_GATE_1F" }, { row: "7", col: "4", dest: "LAST_MAP", src: "ROUTE_18_GATE_1F" }, { row: "7", col: "5", dest: "LAST_MAP", src: "ROUTE_18_GATE_1F" }, { row: "6", col: "8", dest: "ROUTE_18_GATE_2F", src: "ROUTE_18_GATE_1F" }], mapData: { type: "Buffer", data: [28, 31, 31, 29, 50, 33, 33, 49, 102, 0, 0, 103, 41, 37, 38, 30, 24, 30, 48, 35] } }, { CONSTANT_NAME: "ROUTE_18_GATE_2F", height: 4, width: 4, id: "BF", Name: "Route18Gate2F", blockset: "GATE", connections: {}, warps: [{ row: "7", col: "7", dest: "ROUTE_18_GATE_1F", src: "ROUTE_18_GATE_2F" }], mapData: { type: "Buffer", data: [52, 51, 51, 53, 54, 0, 0, 55, 56, 59, 56, 59, 58, 0, 0, 57] } }, { CONSTANT_NAME: "SEAFOAM_ISLANDS_1F", height: 9, width: 15, id: "C0", Name: "SeafoamIslands1F", blockset: "CAVERN", connections: {}, warps: [{ row: "4", col: "17", dest: "LAST_MAP", src: "SEAFOAM_ISLANDS_1F" }, { row: "5", col: "17", dest: "LAST_MAP", src: "SEAFOAM_ISLANDS_1F" }, { row: "26", col: "17", dest: "LAST_MAP", src: "SEAFOAM_ISLANDS_1F" }, { row: "27", col: "17", dest: "LAST_MAP", src: "SEAFOAM_ISLANDS_1F" }, { row: "7", col: "5", dest: "SEAFOAM_ISLANDS_B1F", src: "SEAFOAM_ISLANDS_1F" }, { row: "25", col: "3", dest: "SEAFOAM_ISLANDS_B1F", src: "SEAFOAM_ISLANDS_1F" }, { row: "23", col: "15", dest: "SEAFOAM_ISLANDS_B1F", src: "SEAFOAM_ISLANDS_1F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 40, 1, 46, 46, 24, 25, 60, 25, 44, 29, 29, 29, 29, 45, 30, 1, 1, 46, 46, 24, 25, 25, 25, 26, 1, 1, 120, 1, 109, 1, 119, 1, 46, 46, 24, 25, 25, 25, 26, 1, 1, 1, 1, 109, 1, 1, 1, 46, 46, 28, 29, 41, 29, 30, 1, 1, 1, 1, 76, 94, 94, 94, 46, 46, 1, 1, 1, 1, 1, 1, 1, 1, 1, 109, 1, 1, 1, 46, 46, 1, 1, 1, 1, 1, 1, 1, 1, 1, 109, 40, 1, 1, 46, 46, 46, 36, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 36, 46] } }, { CONSTANT_NAME: "ROUTE_22_GATE", height: 4, width: 5, id: "C1", Name: "Route22Gate", blockset: "GATE", connections: {}, warps: [{ row: "4", col: "7", dest: "LAST_MAP", src: "ROUTE_22_GATE" }, { row: "5", col: "7", dest: "LAST_MAP", src: "ROUTE_22_GATE" }, { row: "4", col: "0", dest: "LAST_MAP", src: "ROUTE_22_GATE" }, { row: "5", col: "0", dest: "LAST_MAP", src: "ROUTE_22_GATE" }], mapData: { type: "Buffer", data: [3, 46, 40, 47, 3, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 44, 4, 45, 0] } }, { CONSTANT_NAME: "VICTORY_ROAD_2F", height: 9, width: 15, id: "C2", Name: "VictoryRoad2F", blockset: "CAVERN", connections: {}, warps: [{ row: "0", col: "8", dest: "VICTORY_ROAD_1F", src: "VICTORY_ROAD_2F" }, { row: "29", col: "7", dest: "LAST_MAP", src: "VICTORY_ROAD_2F" }, { row: "29", col: "8", dest: "LAST_MAP", src: "VICTORY_ROAD_2F" }, { row: "23", col: "7", dest: "VICTORY_ROAD_3F", src: "VICTORY_ROAD_2F" }, { row: "25", col: "14", dest: "VICTORY_ROAD_3F", src: "VICTORY_ROAD_2F" }, { row: "27", col: "7", dest: "VICTORY_ROAD_3F", src: "VICTORY_ROAD_2F" }, { row: "1", col: "1", dest: "VICTORY_ROAD_3F", src: "VICTORY_ROAD_2F" }], mapData: { type: "Buffer", data: [98, 96, 96, 96, 96, 96, 96, 6, 96, 96, 96, 96, 96, 96, 7, 6, 96, 15, 96, 96, 96, 96, 6, 96, 96, 96, 96, 96, 96, 7, 8, 5, 14, 8, 6, 96, 96, 6, 96, 5, 5, 5, 6, 96, 7, 1, 96, 96, 96, 6, 96, 96, 6, 96, 96, 96, 62, 8, 98, 99, 35, 96, 20, 55, 21, 21, 21, 22, 96, 96, 96, 96, 6, 96, 103, 6, 96, 84, 49, 87, 49, 50, 26, 96, 96, 96, 96, 5, 5, 5, 77, 96, 96, 96, 6, 96, 24, 25, 21, 21, 21, 38, 21, 22, 96, 6, 17, 96, 96, 6, 96, 28, 45, 29, 29, 45, 37, 97, 30, 96, 101, 4, 11, 125, 101, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96] } }, { CONSTANT_NAME: "ROUTE_12_GATE_2F", height: 4, width: 4, id: "C3", Name: "Route12Gate2F", blockset: "GATE", connections: {}, warps: [{ row: "7", col: "7", dest: "ROUTE_12_GATE_1F", src: "ROUTE_12_GATE_2F" }], mapData: { type: "Buffer", data: [52, 51, 51, 53, 54, 0, 0, 55, 56, 59, 56, 59, 58, 0, 0, 57] } }, { CONSTANT_NAME: "VERMILION_TRADE_HOUSE", height: 4, width: 4, id: "C4", Name: "VermilionTradeHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "VERMILION_TRADE_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "VERMILION_TRADE_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "DIGLETTS_CAVE", height: 18, width: 20, id: "C5", Name: "DiglettsCave", blockset: "CAVERN", connections: {}, warps: [{ row: "5", col: "5", dest: "DIGLETTS_CAVE_ROUTE_2", src: "DIGLETTS_CAVE" }, { row: "37", col: "31", dest: "DIGLETTS_CAVE_ROUTE_11", src: "DIGLETTS_CAVE" }], mapData: { type: "Buffer", data: [25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 44, 29, 43, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 62, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 28, 29, 43, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 1, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 1, 1, 28, 29, 43, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 21, 22, 1, 1, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 1, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 21, 22, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 28, 29, 29, 29, 29, 29, 43, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 1, 1, 1, 1, 1, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 1, 1, 1, 1, 1, 1, 1, 28, 29, 29, 29, 29, 29, 43, 25, 25, 25, 25, 25, 25, 21, 21, 21, 21, 21, 22, 1, 1, 1, 1, 1, 1, 62, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 21, 21, 21, 21, 22, 1, 1, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 21, 21, 25] } }, { CONSTANT_NAME: "VICTORY_ROAD_3F", height: 9, width: 15, id: "C6", Name: "VictoryRoad3F", blockset: "CAVERN", connections: {}, warps: [{ row: "23", col: "7", dest: "VICTORY_ROAD_2F", src: "VICTORY_ROAD_3F" }, { row: "26", col: "8", dest: "VICTORY_ROAD_2F", src: "VICTORY_ROAD_3F" }, { row: "27", col: "15", dest: "VICTORY_ROAD_2F", src: "VICTORY_ROAD_3F" }, { row: "2", col: "0", dest: "VICTORY_ROAD_2F", src: "VICTORY_ROAD_3F" }], mapData: { type: "Buffer", data: [77, 35, 116, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 7, 8, 13, 13, 96, 20, 21, 21, 21, 21, 22, 96, 96, 96, 12, 7, 6, 108, 11, 96, 24, 44, 29, 29, 45, 30, 96, 96, 2, 14, 7, 106, 107, 107, 111, 24, 26, 96, 96, 96, 96, 96, 40, 8, 5, 9, 102, 29, 43, 112, 24, 26, 96, 96, 15, 8, 13, 4, 6, 39, 7, 6, 96, 28, 37, 29, 30, 96, 96, 96, 96, 7, 96, 17, 14, 7, 6, 96, 96, 96, 96, 96, 6, 5, 5, 5, 5, 96, 6, 96, 7, 6, 96, 96, 96, 96, 96, 2, 96, 96, 96, 96, 105, 6, 40, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 10, 4, 2] } }, { CONSTANT_NAME: "ROCKET_HIDEOUT_B1F", height: 14, width: 15, id: "C7", Name: "RocketHideoutB1F", blockset: "FACILITY", connections: {}, warps: [{ row: "23", col: "2", dest: "ROCKET_HIDEOUT_B2F", src: "ROCKET_HIDEOUT_B1F" }, { row: "21", col: "2", dest: "GAME_CORNER", src: "ROCKET_HIDEOUT_B1F" }, { row: "24", col: "19", dest: "ROCKET_HIDEOUT_ELEVATOR", src: "ROCKET_HIDEOUT_B1F" }, { row: "21", col: "24", dest: "ROCKET_HIDEOUT_B2F", src: "ROCKET_HIDEOUT_B1F" }, { row: "25", col: "19", dest: "ROCKET_HIDEOUT_ELEVATOR", src: "ROCKET_HIDEOUT_B1F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 64, 65, 65, 66, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 68, 110, 111, 70, 46, 46, 46, 46, 46, 46, 64, 65, 65, 65, 65, 99, 14, 14, 103, 65, 66, 46, 46, 46, 46, 68, 14, 14, 14, 14, 14, 14, 14, 14, 14, 70, 46, 46, 46, 46, 64, 42, 43, 66, 13, 14, 9, 64, 42, 43, 66, 46, 46, 46, 46, 68, 14, 14, 70, 13, 14, 9, 68, 14, 14, 70, 46, 46, 46, 46, 68, 71, 71, 70, 13, 14, 9, 68, 71, 71, 70, 46, 46, 46, 46, 18, 14, 14, 70, 13, 14, 9, 18, 14, 14, 70, 46, 46, 46, 46, 64, 65, 65, 65, 65, 65, 65, 66, 14, 103, 66, 46, 46, 46, 46, 18, 14, 52, 52, 52, 14, 14, 70, 44, 87, 74, 46, 46, 46, 46, 18, 14, 54, 54, 54, 14, 14, 70, 46, 46, 46, 46, 46, 46, 46, 18, 14, 54, 54, 54, 14, 14, 70, 46, 46, 46, 46, 46, 46, 46, 18, 14, 55, 55, 55, 14, 111, 70, 46, 46, 46, 46, 46, 46, 46, 72, 73, 73, 73, 73, 73, 73, 74, 46, 46, 46] } }, { CONSTANT_NAME: "ROCKET_HIDEOUT_B2F", height: 14, width: 15, id: "C8", Name: "RocketHideoutB2F", blockset: "FACILITY", connections: {}, warps: [{ row: "27", col: "8", dest: "ROCKET_HIDEOUT_B1F", src: "ROCKET_HIDEOUT_B2F" }, { row: "21", col: "8", dest: "ROCKET_HIDEOUT_B3F", src: "ROCKET_HIDEOUT_B2F" }, { row: "24", col: "19", dest: "ROCKET_HIDEOUT_ELEVATOR", src: "ROCKET_HIDEOUT_B2F" }, { row: "21", col: "22", dest: "ROCKET_HIDEOUT_B1F", src: "ROCKET_HIDEOUT_B2F" }, { row: "25", col: "19", dest: "ROCKET_HIDEOUT_ELEVATOR", src: "ROCKET_HIDEOUT_B2F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 64, 65, 65, 122, 65, 65, 65, 65, 65, 64, 65, 66, 65, 65, 66, 68, 19, 27, 10, 27, 27, 27, 28, 30, 85, 111, 70, 13, 110, 70, 121, 57, 38, 25, 19, 23, 2, 14, 15, 14, 14, 70, 13, 14, 70, 68, 10, 26, 30, 23, 32, 39, 21, 19, 14, 14, 86, 13, 14, 70, 121, 25, 3, 14, 2, 2, 53, 19, 23, 89, 14, 14, 14, 14, 70, 68, 25, 23, 53, 41, 3, 3, 2, 23, 64, 65, 65, 65, 65, 66, 68, 19, 27, 14, 27, 2, 15, 41, 23, 85, 14, 83, 44, 87, 74, 68, 24, 17, 21, 32, 41, 29, 32, 14, 14, 14, 70, 46, 46, 46, 68, 32, 23, 23, 2, 14, 15, 32, 14, 89, 110, 70, 46, 46, 46, 68, 17, 17, 23, 41, 38, 25, 19, 32, 68, 14, 70, 46, 46, 46, 72, 73, 51, 51, 51, 51, 51, 51, 51, 72, 73, 74, 46, 46, 46] } }, { CONSTANT_NAME: "ROCKET_HIDEOUT_B3F", height: 14, width: 15, id: "C9", Name: "RocketHideoutB3F", blockset: "FACILITY", connections: {}, warps: [{ row: "25", col: "6", dest: "ROCKET_HIDEOUT_B2F", src: "ROCKET_HIDEOUT_B3F" }, { row: "19", col: "18", dest: "ROCKET_HIDEOUT_B4F", src: "ROCKET_HIDEOUT_B3F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 46, 46, 46, 46, 68, 14, 14, 14, 14, 14, 14, 14, 110, 14, 70, 46, 46, 46, 46, 64, 65, 65, 65, 65, 99, 90, 73, 88, 14, 70, 46, 46, 46, 46, 121, 19, 27, 38, 19, 25, 70, 14, 14, 14, 70, 46, 46, 46, 46, 121, 38, 17, 19, 2, 53, 22, 14, 87, 73, 81, 46, 46, 46, 46, 68, 53, 32, 38, 14, 19, 70, 14, 14, 14, 70, 46, 46, 46, 46, 68, 29, 3, 39, 41, 23, 22, 14, 14, 14, 70, 46, 46, 46, 46, 68, 3, 14, 2, 53, 111, 70, 73, 73, 73, 74, 46, 46, 46, 46, 121, 25, 23, 10, 96, 42, 113, 98, 46, 46, 46, 46, 46, 46, 46, 68, 14, 14, 41, 100, 14, 14, 102, 46, 46, 46, 46, 46, 46, 46, 64, 65, 42, 103, 112, 14, 14, 70, 46, 46, 46, 46, 46, 46, 46, 72, 73, 73, 73, 73, 73, 73, 74, 46, 46, 46] } }, { CONSTANT_NAME: "ROCKET_HIDEOUT_B4F", height: 12, width: 15, id: "CA", Name: "RocketHideoutB4F", blockset: "FACILITY", connections: {}, warps: [{ row: "19", col: "10", dest: "ROCKET_HIDEOUT_B3F", src: "ROCKET_HIDEOUT_B4F" }, { row: "24", col: "15", dest: "ROCKET_HIDEOUT_ELEVATOR", src: "ROCKET_HIDEOUT_B4F" }, { row: "25", col: "15", dest: "ROCKET_HIDEOUT_ELEVATOR", src: "ROCKET_HIDEOUT_B4F" }], mapData: { type: "Buffer", data: [46, 46, 46, 46, 96, 97, 97, 97, 64, 65, 66, 97, 97, 97, 66, 46, 46, 46, 46, 100, 14, 14, 14, 112, 14, 70, 14, 14, 14, 70, 46, 46, 46, 46, 68, 71, 71, 14, 82, 14, 70, 14, 71, 71, 70, 46, 46, 46, 46, 80, 73, 73, 73, 68, 14, 70, 13, 14, 14, 70, 46, 46, 46, 46, 68, 14, 14, 11, 68, 14, 70, 13, 14, 14, 102, 46, 46, 46, 46, 68, 71, 14, 9, 68, 110, 70, 88, 14, 87, 81, 46, 46, 46, 46, 68, 71, 14, 103, 112, 83, 74, 14, 14, 14, 70, 46, 46, 46, 46, 68, 14, 14, 14, 14, 70, 14, 83, 44, 87, 74, 46, 46, 46, 46, 96, 97, 97, 97, 97, 99, 14, 70, 46, 46, 46, 46, 46, 46, 46, 100, 14, 14, 14, 14, 14, 14, 70, 46, 46, 46, 46, 46, 46, 46, 68, 14, 71, 71, 11, 13, 14, 70, 46, 46, 46, 46, 46, 46, 46, 72, 73, 73, 73, 73, 73, 73, 74, 46, 46, 46] } }, { CONSTANT_NAME: "ROCKET_HIDEOUT_ELEVATOR", height: 4, width: 3, id: "CB", Name: "RocketHideoutElevator", blockset: "LOBBY", connections: {}, warps: [{ row: "2", col: "1", dest: "ROCKET_HIDEOUT_B1F", src: "ROCKET_HIDEOUT_ELEVATOR" }, { row: "3", col: "1", dest: "ROCKET_HIDEOUT_B1F", src: "ROCKET_HIDEOUT_ELEVATOR" }], mapData: { type: "Buffer", data: [68, 77, 71, 74, 76, 75, 74, 32, 75, 72, 70, 73] } }, { CONSTANT_NAME: "UNUSED_MAP_CC", height: 0, width: 0, id: "CC" }, { CONSTANT_NAME: "UNUSED_MAP_CD", height: 0, width: 0, id: "CD" }, { CONSTANT_NAME: "UNUSED_MAP_CE", height: 0, width: 0, id: "CE" }, { CONSTANT_NAME: "SILPH_CO_2F", height: 9, width: 15, id: "CF", Name: "SilphCo2F", blockset: "FACILITY", connections: {}, warps: [{ row: "24", col: "0", dest: "SILPH_CO_1F", src: "SILPH_CO_2F" }, { row: "26", col: "0", dest: "SILPH_CO_3F", src: "SILPH_CO_2F" }, { row: "20", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_2F" }, { row: "3", col: "3", dest: "SILPH_CO_3F", src: "SILPH_CO_2F" }, { row: "13", col: "3", dest: "SILPH_CO_8F", src: "SILPH_CO_2F" }, { row: "27", col: "15", dest: "SILPH_CO_8F", src: "SILPH_CO_2F" }, { row: "9", col: "15", dest: "SILPH_CO_6F", src: "SILPH_CO_2F" }], mapData: { type: "Buffer", data: [64, 97, 97, 97, 97, 66, 61, 61, 61, 61, 124, 61, 36, 125, 62, 68, 47, 14, 14, 14, 70, 47, 14, 14, 14, 14, 14, 14, 14, 70, 64, 99, 14, 103, 97, 97, 97, 97, 97, 97, 65, 99, 14, 103, 66, 68, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 70, 68, 14, 14, 14, 14, 14, 14, 123, 14, 123, 9, 64, 97, 97, 98, 64, 99, 14, 103, 65, 66, 14, 54, 14, 54, 9, 85, 14, 14, 102, 68, 123, 14, 11, 11, 70, 14, 54, 14, 54, 14, 14, 14, 14, 70, 68, 55, 14, 14, 47, 70, 14, 55, 14, 55, 14, 89, 71, 47, 70, 72, 73, 73, 73, 73, 74, 73, 73, 73, 73, 73, 72, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_3F", height: 9, width: 15, id: "D0", Name: "SilphCo3F", blockset: "FACILITY", connections: {}, warps: [{ row: "26", col: "0", dest: "SILPH_CO_2F", src: "SILPH_CO_3F" }, { row: "24", col: "0", dest: "SILPH_CO_4F", src: "SILPH_CO_3F" }, { row: "20", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_3F" }, { row: "23", col: "11", dest: "SILPH_CO_3F", src: "SILPH_CO_3F" }, { row: "3", col: "3", dest: "SILPH_CO_5F", src: "SILPH_CO_3F" }, { row: "3", col: "15", dest: "SILPH_CO_5F", src: "SILPH_CO_3F" }, { row: "27", col: "3", dest: "SILPH_CO_2F", src: "SILPH_CO_3F" }, { row: "3", col: "11", dest: "SILPH_CO_9F", src: "SILPH_CO_3F" }, { row: "11", col: "11", dest: "SILPH_CO_7F", src: "SILPH_CO_3F" }, { row: "27", col: "15", dest: "SILPH_CO_3F", src: "SILPH_CO_3F" }], mapData: { type: "Buffer", data: [60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 124, 61, 125, 36, 62, 68, 47, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 47, 70, 96, 97, 97, 65, 66, 97, 65, 97, 66, 14, 90, 97, 97, 97, 98, 100, 14, 52, 14, 86, 14, 14, 14, 86, 14, 86, 14, 14, 14, 102, 68, 14, 54, 14, 14, 14, 71, 14, 14, 14, 14, 14, 14, 71, 70, 68, 47, 55, 14, 90, 47, 14, 14, 90, 14, 90, 47, 67, 67, 70, 80, 73, 73, 73, 74, 73, 73, 73, 74, 14, 86, 73, 73, 73, 81, 68, 47, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 47, 70, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_4F", height: 9, width: 15, id: "D1", Name: "SilphCo4F", blockset: "FACILITY", connections: {}, warps: [{ row: "24", col: "0", dest: "SILPH_CO_3F", src: "SILPH_CO_4F" }, { row: "26", col: "0", dest: "SILPH_CO_5F", src: "SILPH_CO_4F" }, { row: "20", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_4F" }, { row: "11", col: "7", dest: "SILPH_CO_10F", src: "SILPH_CO_4F" }, { row: "17", col: "3", dest: "SILPH_CO_6F", src: "SILPH_CO_4F" }, { row: "3", col: "15", dest: "SILPH_CO_10F", src: "SILPH_CO_4F" }, { row: "17", col: "11", dest: "SILPH_CO_10F", src: "SILPH_CO_4F" }], mapData: { type: "Buffer", data: [60, 61, 61, 61, 62, 97, 97, 97, 97, 60, 124, 61, 36, 125, 62, 68, 53, 53, 30, 70, 14, 14, 14, 47, 68, 14, 14, 14, 14, 70, 68, 53, 53, 53, 70, 14, 71, 71, 14, 68, 64, 99, 14, 103, 66, 68, 53, 26, 53, 70, 47, 14, 14, 14, 68, 68, 13, 52, 9, 70, 68, 24, 14, 53, 70, 99, 14, 103, 97, 68, 68, 14, 54, 14, 70, 68, 14, 14, 14, 70, 14, 14, 14, 47, 68, 68, 13, 54, 9, 70, 64, 99, 14, 103, 65, 99, 14, 103, 65, 112, 68, 14, 54, 14, 70, 68, 47, 14, 14, 14, 14, 14, 14, 14, 14, 68, 13, 55, 9, 70, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 72, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_5F", height: 9, width: 15, id: "D2", Name: "SilphCo5F", blockset: "FACILITY", connections: {}, warps: [{ row: "24", col: "0", dest: "SILPH_CO_6F", src: "SILPH_CO_5F" }, { row: "26", col: "0", dest: "SILPH_CO_4F", src: "SILPH_CO_5F" }, { row: "20", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_5F" }, { row: "27", col: "3", dest: "SILPH_CO_7F", src: "SILPH_CO_5F" }, { row: "9", col: "15", dest: "SILPH_CO_9F", src: "SILPH_CO_5F" }, { row: "11", col: "5", dest: "SILPH_CO_3F", src: "SILPH_CO_5F" }, { row: "3", col: "15", dest: "SILPH_CO_3F", src: "SILPH_CO_5F" }], mapData: { type: "Buffer", data: [64, 97, 97, 66, 61, 61, 61, 61, 61, 61, 124, 61, 125, 36, 62, 68, 14, 14, 86, 14, 9, 13, 14, 14, 14, 14, 14, 14, 47, 70, 68, 14, 14, 14, 14, 47, 14, 90, 65, 65, 99, 14, 103, 66, 70, 68, 14, 14, 90, 14, 96, 97, 66, 14, 14, 71, 71, 123, 70, 70, 80, 73, 73, 81, 14, 100, 14, 86, 14, 14, 14, 14, 54, 70, 70, 68, 14, 14, 86, 14, 68, 14, 14, 14, 14, 14, 14, 54, 70, 70, 68, 26, 53, 14, 14, 68, 14, 90, 14, 14, 71, 71, 71, 70, 70, 68, 47, 53, 90, 47, 72, 73, 74, 73, 73, 73, 73, 73, 74, 70, 72, 73, 73, 74, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_6F", height: 9, width: 13, id: "D3", Name: "SilphCo6F", blockset: "FACILITY", connections: {}, warps: [{ row: "16", col: "0", dest: "SILPH_CO_7F", src: "SILPH_CO_6F" }, { row: "14", col: "0", dest: "SILPH_CO_5F", src: "SILPH_CO_6F" }, { row: "18", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_6F" }, { row: "3", col: "3", dest: "SILPH_CO_4F", src: "SILPH_CO_6F" }, { row: "23", col: "3", dest: "SILPH_CO_2F", src: "SILPH_CO_6F" }], mapData: { type: "Buffer", data: [96, 97, 66, 61, 61, 61, 61, 36, 125, 124, 61, 61, 62, 100, 47, 86, 14, 14, 14, 14, 14, 14, 14, 14, 47, 70, 68, 14, 14, 14, 96, 97, 65, 65, 99, 14, 103, 66, 70, 18, 14, 12, 14, 100, 14, 52, 52, 52, 52, 52, 70, 70, 64, 65, 66, 14, 68, 14, 54, 55, 55, 55, 54, 70, 70, 68, 24, 86, 14, 18, 14, 54, 52, 52, 52, 54, 70, 70, 68, 28, 14, 14, 18, 14, 55, 55, 55, 55, 55, 70, 70, 68, 26, 90, 14, 103, 99, 14, 103, 65, 65, 65, 99, 70, 72, 73, 74, 73, 73, 73, 73, 73, 73, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_7F", height: 9, width: 13, id: "D4", Name: "SilphCo7F", blockset: "FACILITY", connections: {}, warps: [{ row: "16", col: "0", dest: "SILPH_CO_8F", src: "SILPH_CO_7F" }, { row: "22", col: "0", dest: "SILPH_CO_6F", src: "SILPH_CO_7F" }, { row: "18", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_7F" }, { row: "5", col: "7", dest: "SILPH_CO_11F", src: "SILPH_CO_7F" }, { row: "5", col: "3", dest: "SILPH_CO_3F", src: "SILPH_CO_7F" }, { row: "21", col: "15", dest: "SILPH_CO_5F", src: "SILPH_CO_7F" }], mapData: { type: "Buffer", data: [64, 65, 97, 96, 65, 65, 16, 66, 125, 124, 61, 36, 62, 68, 14, 47, 100, 34, 34, 35, 113, 14, 14, 14, 14, 70, 68, 14, 71, 68, 14, 14, 14, 12, 90, 99, 14, 103, 66, 68, 14, 47, 64, 99, 14, 103, 66, 70, 13, 14, 52, 70, 64, 97, 97, 68, 52, 14, 52, 70, 70, 13, 14, 54, 70, 68, 14, 14, 68, 54, 14, 54, 70, 70, 13, 14, 55, 70, 68, 9, 13, 68, 55, 14, 55, 70, 70, 99, 14, 103, 66, 68, 14, 14, 72, 73, 73, 73, 74, 70, 14, 47, 14, 70, 72, 73, 73, 73, 73, 73, 73, 73, 74, 87, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_8F", height: 9, width: 13, id: "D5", Name: "SilphCo8F", blockset: "FACILITY", connections: {}, warps: [{ row: "16", col: "0", dest: "SILPH_CO_9F", src: "SILPH_CO_8F" }, { row: "14", col: "0", dest: "SILPH_CO_7F", src: "SILPH_CO_8F" }, { row: "18", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_8F" }, { row: "3", col: "11", dest: "SILPH_CO_8F", src: "SILPH_CO_8F" }, { row: "3", col: "15", dest: "SILPH_CO_2F", src: "SILPH_CO_8F" }, { row: "11", col: "5", dest: "SILPH_CO_2F", src: "SILPH_CO_8F" }, { row: "11", col: "9", dest: "SILPH_CO_8F", src: "SILPH_CO_8F" }], mapData: { type: "Buffer", data: [64, 65, 65, 66, 97, 97, 98, 36, 125, 124, 61, 61, 62, 68, 52, 52, 70, 14, 14, 102, 14, 14, 14, 14, 14, 70, 68, 54, 54, 70, 14, 47, 70, 14, 64, 65, 65, 65, 66, 68, 54, 54, 86, 14, 87, 81, 14, 68, 67, 67, 9, 70, 68, 55, 54, 14, 14, 47, 70, 14, 68, 14, 14, 14, 70, 68, 47, 55, 90, 14, 71, 70, 14, 68, 71, 14, 9, 70, 80, 73, 73, 74, 14, 87, 74, 14, 72, 88, 14, 87, 81, 18, 47, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 70, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 74] } }, { CONSTANT_NAME: "POKEMON_MANSION_2F", height: 14, width: 15, id: "D6", Name: "PokemonMansion2F", blockset: "FACILITY", connections: {}, warps: [{ row: "5", col: "10", dest: "POKEMON_MANSION_1F", src: "POKEMON_MANSION_2F" }, { row: "7", col: "10", dest: "POKEMON_MANSION_3F", src: "POKEMON_MANSION_2F" }, { row: "25", col: "14", dest: "POKEMON_MANSION_3F", src: "POKEMON_MANSION_2F" }, { row: "6", col: "1", dest: "POKEMON_MANSION_3F", src: "POKEMON_MANSION_2F" }], mapData: { type: "Buffer", data: [104, 101, 101, 106, 66, 65, 65, 66, 65, 65, 65, 64, 97, 101, 105, 92, 6, 14, 14, 86, 14, 14, 70, 14, 71, 14, 112, 14, 7, 93, 92, 14, 14, 14, 14, 14, 14, 86, 88, 14, 87, 6, 56, 14, 70, 68, 14, 67, 67, 90, 14, 14, 14, 14, 14, 14, 49, 6, 6, 70, 80, 73, 73, 73, 74, 14, 9, 96, 99, 14, 103, 6, 65, 101, 105, 68, 119, 111, 110, 14, 14, 9, 100, 14, 14, 14, 56, 14, 14, 70, 68, 14, 14, 90, 56, 83, 73, 6, 6, 88, 14, 56, 14, 87, 81, 107, 97, 42, 93, 56, 70, 6, 6, 6, 14, 14, 6, 110, 14, 70, 68, 14, 49, 6, 6, 70, 14, 108, 1, 31, 31, 31, 31, 31, 79, 107, 97, 97, 66, 14, 70, 14, 108, 1, 1, 1, 1, 1, 1, 1, 68, 14, 14, 86, 14, 86, 14, 108, 1, 1, 1, 1, 1, 1, 1, 68, 71, 71, 14, 14, 83, 14, 108, 1, 1, 1, 1, 1, 1, 1, 68, 14, 14, 90, 14, 70, 14, 108, 1, 1, 1, 1, 1, 1, 1, 72, 73, 73, 74, 73, 74, 31, 109, 1, 1, 1, 1, 1, 1, 1] } }, { CONSTANT_NAME: "POKEMON_MANSION_3F", height: 9, width: 15, id: "D7", Name: "PokemonMansion3F", blockset: "FACILITY", connections: {}, warps: [{ row: "7", col: "10", dest: "POKEMON_MANSION_2F", src: "POKEMON_MANSION_3F" }, { row: "6", col: "1", dest: "POKEMON_MANSION_2F", src: "POKEMON_MANSION_3F" }, { row: "25", col: "14", dest: "POKEMON_MANSION_2F", src: "POKEMON_MANSION_3F" }], mapData: { type: "Buffer", data: [64, 65, 65, 115, 65, 101, 101, 66, 97, 97, 97, 64, 6, 6, 6, 68, 14, 14, 14, 14, 14, 6, 86, 14, 14, 14, 85, 14, 6, 6, 92, 56, 14, 14, 49, 119, 14, 14, 14, 71, 14, 14, 14, 49, 6, 92, 6, 6, 6, 6, 14, 14, 90, 14, 14, 49, 56, 14, 14, 70, 92, 6, 56, 14, 103, 105, 13, 86, 73, 6, 6, 6, 73, 73, 81, 68, 6, 14, 111, 14, 93, 13, 14, 7, 14, 14, 56, 14, 14, 70, 68, 7, 14, 71, 49, 93, 73, 6, 14, 116, 87, 82, 87, 73, 81, 92, 6, 14, 14, 6, 93, 1, 1, 1, 1, 1, 68, 111, 14, 70, 72, 73, 73, 6, 6, 6, 1, 1, 1, 1, 1, 72, 73, 73, 74] } }, { CONSTANT_NAME: "POKEMON_MANSION_B1F", height: 14, width: 15, id: "D8", Name: "PokemonMansionB1F", blockset: "FACILITY", connections: {}, warps: [{ row: "23", col: "22", dest: "POKEMON_MANSION_1F", src: "POKEMON_MANSION_B1F" }], mapData: { type: "Buffer", data: [96, 97, 97, 97, 66, 97, 97, 97, 97, 98, 65, 65, 65, 65, 66, 100, 14, 14, 14, 70, 14, 14, 14, 14, 102, 119, 67, 67, 67, 70, 68, 14, 71, 14, 86, 88, 14, 87, 73, 74, 73, 88, 14, 87, 81, 68, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 70, 64, 99, 14, 103, 66, 65, 65, 65, 65, 65, 65, 65, 66, 14, 70, 68, 11, 14, 11, 70, 14, 14, 14, 14, 14, 14, 14, 70, 14, 70, 68, 14, 14, 14, 70, 14, 14, 14, 14, 14, 14, 14, 70, 14, 70, 68, 11, 14, 11, 70, 14, 14, 14, 14, 14, 14, 14, 70, 14, 70, 80, 73, 73, 73, 74, 14, 90, 97, 14, 97, 89, 14, 86, 14, 81, 68, 14, 14, 14, 14, 14, 70, 14, 14, 14, 68, 14, 14, 14, 70, 68, 14, 14, 14, 14, 14, 86, 14, 71, 14, 68, 14, 14, 14, 70, 68, 14, 14, 14, 14, 14, 14, 14, 14, 14, 68, 110, 14, 14, 70, 68, 14, 14, 14, 14, 14, 90, 14, 14, 119, 68, 14, 14, 14, 70, 72, 73, 73, 73, 73, 73, 74, 73, 73, 73, 72, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SAFARI_ZONE_EAST", height: 13, width: 15, id: "D9", Name: "SafariZoneEast", blockset: "FOREST", connections: {}, warps: [{ row: "0", col: "4", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_EAST" }, { row: "0", col: "5", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_EAST" }, { row: "0", col: "22", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_EAST" }, { row: "0", col: "23", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_EAST" }, { row: "25", col: "9", dest: "SAFARI_ZONE_EAST_REST_HOUSE", src: "SAFARI_ZONE_EAST" }], mapData: { type: "Buffer", data: [72, 125, 125, 125, 5, 5, 5, 5, 5, 5, 125, 5, 5, 5, 73, 76, 124, 124, 27, 37, 1, 1, 1, 36, 27, 35, 1, 1, 1, 7, 86, 27, 27, 33, 27, 60, 61, 61, 61, 62, 37, 1, 1, 1, 7, 72, 125, 125, 125, 125, 68, 71, 69, 83, 70, 37, 37, 36, 36, 126, 127, 35, 40, 40, 34, 27, 27, 2, 44, 41, 44, 41, 25, 28, 126, 6, 40, 1, 1, 32, 80, 81, 81, 81, 82, 27, 27, 27, 33, 126, 6, 40, 1, 1, 40, 1, 1, 1, 85, 60, 61, 61, 61, 62, 2, 127, 37, 40, 40, 36, 80, 81, 81, 79, 68, 63, 67, 71, 70, 2, 76, 124, 124, 44, 27, 84, 45, 45, 45, 45, 64, 66, 44, 27, 126, 2, 2, 2, 127, 44, 60, 61, 61, 61, 61, 74, 66, 27, 27, 126, 125, 125, 125, 127, 44, 68, 71, 69, 69, 69, 71, 70, 1, 34, 126, 86, 44, 51, 76, 124, 124, 124, 124, 127, 37, 1, 1, 1, 36, 126, 124, 124, 124, 124, 124, 124, 124, 4, 4, 4, 4, 4, 4, 124, 77] } }, { CONSTANT_NAME: "SAFARI_ZONE_NORTH", height: 18, width: 20, id: "DA", Name: "SafariZoneNorth", blockset: "FOREST", connections: {}, warps: [{ row: "2", col: "35", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_NORTH" }, { row: "3", col: "35", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_NORTH" }, { row: "8", col: "35", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_NORTH" }, { row: "9", col: "35", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_NORTH" }, { row: "20", col: "35", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_NORTH" }, { row: "21", col: "35", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_NORTH" }, { row: "39", col: "30", dest: "SAFARI_ZONE_EAST", src: "SAFARI_ZONE_NORTH" }, { row: "39", col: "31", dest: "SAFARI_ZONE_EAST", src: "SAFARI_ZONE_NORTH" }, { row: "35", col: "3", dest: "SAFARI_ZONE_NORTH_REST_HOUSE", src: "SAFARI_ZONE_NORTH" }], mapData: { type: "Buffer", data: [2, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 5, 5, 5, 5, 2, 127, 35, 34, 35, 34, 27, 27, 27, 27, 27, 27, 27, 27, 27, 35, 1, 36, 25, 28, 126, 127, 37, 1, 1, 36, 126, 125, 125, 2, 125, 2, 125, 125, 125, 1, 1, 27, 27, 33, 126, 127, 35, 1, 1, 34, 126, 27, 27, 27, 27, 27, 27, 27, 27, 37, 1, 34, 27, 27, 126, 2, 37, 36, 37, 92, 82, 27, 27, 27, 27, 27, 27, 27, 27, 27, 37, 1, 34, 27, 126, 127, 27, 41, 44, 90, 91, 1, 34, 2, 53, 53, 53, 53, 53, 53, 53, 37, 1, 27, 126, 127, 44, 27, 27, 90, 91, 1, 34, 127, 41, 41, 27, 27, 27, 27, 27, 60, 61, 61, 62, 127, 41, 92, 82, 40, 1, 1, 36, 127, 27, 27, 27, 27, 27, 27, 27, 68, 71, 63, 66, 127, 27, 90, 91, 37, 36, 37, 27, 127, 27, 27, 27, 27, 44, 41, 27, 27, 27, 64, 66, 127, 44, 90, 91, 27, 27, 27, 27, 127, 44, 27, 27, 27, 27, 44, 27, 27, 27, 64, 66, 127, 41, 126, 41, 27, 27, 27, 60, 61, 61, 61, 61, 62, 27, 27, 27, 41, 27, 64, 66, 127, 27, 126, 35, 35, 1, 34, 64, 65, 67, 69, 71, 70, 27, 27, 27, 27, 27, 64, 66, 127, 27, 21, 1, 92, 82, 1, 64, 65, 66, 1, 1, 34, 60, 61, 61, 61, 61, 74, 66, 127, 27, 126, 1, 90, 91, 36, 68, 71, 70, 1, 1, 1, 68, 71, 69, 69, 69, 69, 70, 127, 27, 126, 37, 90, 91, 27, 27, 126, 37, 1, 1, 1, 33, 27, 27, 27, 27, 27, 29, 127, 41, 126, 27, 27, 27, 51, 27, 126, 44, 1, 1, 1, 34, 41, 41, 27, 41, 27, 87, 127, 44, 126, 27, 44, 27, 27, 27, 126, 51, 27, 36, 37, 36, 27, 27, 27, 27, 27, 29, 73, 89, 72, 73, 89, 72, 57, 57, 57, 73, 89, 72, 125, 125, 125, 125, 125, 125, 125, 125] } }, { CONSTANT_NAME: "SAFARI_ZONE_WEST", height: 13, width: 15, id: "DB", Name: "SafariZoneWest", blockset: "FOREST", connections: {}, warps: [{ row: "20", col: "0", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_WEST" }, { row: "21", col: "0", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_WEST" }, { row: "26", col: "0", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_WEST" }, { row: "27", col: "0", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_WEST" }, { row: "29", col: "22", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_WEST" }, { row: "29", col: "23", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_WEST" }, { row: "3", col: "3", dest: "SAFARI_ZONE_SECRET_HOUSE", src: "SAFARI_ZONE_WEST" }, { row: "11", col: "11", dest: "SAFARI_ZONE_WEST_REST_HOUSE", src: "SAFARI_ZONE_WEST" }], mapData: { type: "Buffer", data: [2, 27, 27, 2, 124, 124, 124, 124, 124, 2, 88, 2, 2, 88, 2, 43, 25, 28, 42, 27, 27, 27, 27, 51, 27, 27, 27, 127, 41, 126, 43, 27, 27, 42, 27, 46, 27, 27, 27, 41, 27, 27, 127, 33, 126, 43, 27, 27, 27, 27, 60, 61, 61, 62, 41, 27, 27, 127, 41, 126, 43, 46, 27, 27, 27, 68, 69, 63, 66, 27, 41, 41, 127, 27, 126, 126, 92, 81, 81, 82, 25, 28, 64, 66, 27, 27, 27, 127, 27, 126, 126, 90, 45, 45, 91, 27, 33, 64, 66, 27, 27, 27, 127, 41, 126, 2, 27, 27, 27, 27, 27, 27, 64, 75, 61, 61, 62, 27, 27, 126, 127, 27, 60, 61, 61, 61, 61, 74, 67, 69, 83, 70, 27, 44, 126, 127, 35, 68, 71, 69, 69, 69, 69, 70, 27, 27, 27, 27, 27, 126, 127, 1, 1, 1, 1, 1, 1, 1, 1, 127, 44, 27, 44, 27, 126, 127, 27, 37, 1, 1, 36, 37, 36, 27, 127, 27, 27, 33, 27, 87, 2, 125, 125, 125, 125, 124, 124, 124, 125, 124, 124, 125, 125, 125, 125] } }, { CONSTANT_NAME: "SAFARI_ZONE_CENTER", height: 13, width: 15, id: "DC", Name: "SafariZoneCenter", blockset: "FOREST", connections: {}, warps: [{ row: "14", col: "25", dest: "SAFARI_ZONE_GATE", src: "SAFARI_ZONE_CENTER" }, { row: "15", col: "25", dest: "SAFARI_ZONE_GATE", src: "SAFARI_ZONE_CENTER" }, { row: "0", col: "10", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_CENTER" }, { row: "0", col: "11", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_CENTER" }, { row: "14", col: "0", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_CENTER" }, { row: "15", col: "0", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_CENTER" }, { row: "29", col: "10", dest: "SAFARI_ZONE_EAST", src: "SAFARI_ZONE_CENTER" }, { row: "29", col: "11", dest: "SAFARI_ZONE_EAST", src: "SAFARI_ZONE_CENTER" }, { row: "17", col: "19", dest: "SAFARI_ZONE_CENTER_REST_HOUSE", src: "SAFARI_ZONE_CENTER" }], mapData: { type: "Buffer", data: [126, 125, 125, 125, 125, 2, 125, 88, 125, 125, 125, 125, 125, 125, 127, 127, 27, 35, 34, 44, 126, 27, 27, 35, 34, 35, 34, 41, 27, 126, 127, 35, 1, 1, 34, 126, 41, 35, 1, 1, 1, 1, 34, 27, 126, 127, 37, 1, 36, 27, 126, 27, 37, 1, 36, 37, 1, 36, 44, 126, 127, 27, 36, 35, 92, 81, 81, 81, 81, 81, 82, 124, 124, 124, 2, 86, 27, 27, 1, 90, 93, 27, 46, 27, 85, 91, 27, 46, 27, 87, 127, 46, 27, 37, 90, 94, 81, 81, 81, 79, 91, 1, 34, 27, 126, 127, 27, 44, 124, 124, 39, 38, 23, 39, 38, 27, 37, 1, 34, 126, 2, 125, 125, 27, 27, 27, 27, 27, 27, 27, 27, 1, 1, 34, 126, 127, 27, 35, 1, 1, 34, 44, 27, 25, 28, 27, 35, 1, 36, 126, 127, 44, 37, 1, 1, 36, 27, 27, 27, 33, 27, 35, 36, 44, 126, 127, 27, 41, 37, 1, 1, 36, 33, 44, 44, 35, 36, 27, 27, 126, 126, 39, 23, 38, 23, 23, 38, 88, 39, 23, 23, 39, 23, 38, 127] } }, { CONSTANT_NAME: "SAFARI_ZONE_CENTER_REST_HOUSE", height: 4, width: 4, id: "DD", Name: "SafariZoneCenterRestHouse", blockset: "GATE", connections: {}, warps: [{ row: "2", col: "7", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_CENTER_REST_HOUSE" }, { row: "3", col: "7", dest: "SAFARI_ZONE_CENTER", src: "SAFARI_ZONE_CENTER_REST_HOUSE" }], mapData: { type: "Buffer", data: [3, 7, 77, 77, 59, 56, 0, 0, 59, 56, 17, 33, 0, 11, 8, 1] } }, { CONSTANT_NAME: "SAFARI_ZONE_SECRET_HOUSE", height: 4, width: 4, id: "DE", Name: "SafariZoneSecretHouse", blockset: "LAB", connections: {}, warps: [{ row: "2", col: "7", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_SECRET_HOUSE" }, { row: "3", col: "7", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_SECRET_HOUSE" }], mapData: { type: "Buffer", data: [22, 18, 19, 22, 2, 7, 7, 2, 7, 7, 7, 7, 7, 12, 7, 7] } }, { CONSTANT_NAME: "SAFARI_ZONE_WEST_REST_HOUSE", height: 4, width: 4, id: "DF", Name: "SafariZoneWestRestHouse", blockset: "GATE", connections: {}, warps: [{ row: "2", col: "7", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_WEST_REST_HOUSE" }, { row: "3", col: "7", dest: "SAFARI_ZONE_WEST", src: "SAFARI_ZONE_WEST_REST_HOUSE" }], mapData: { type: "Buffer", data: [3, 7, 77, 77, 59, 56, 0, 0, 59, 56, 17, 33, 0, 11, 8, 1] } }, { CONSTANT_NAME: "SAFARI_ZONE_EAST_REST_HOUSE", height: 4, width: 4, id: "E0", Name: "SafariZoneEastRestHouse", blockset: "GATE", connections: {}, warps: [{ row: "2", col: "7", dest: "SAFARI_ZONE_EAST", src: "SAFARI_ZONE_EAST_REST_HOUSE" }, { row: "3", col: "7", dest: "SAFARI_ZONE_EAST", src: "SAFARI_ZONE_EAST_REST_HOUSE" }], mapData: { type: "Buffer", data: [3, 7, 77, 77, 59, 56, 0, 0, 59, 56, 17, 33, 0, 11, 8, 1] } }, { CONSTANT_NAME: "SAFARI_ZONE_NORTH_REST_HOUSE", height: 4, width: 4, id: "E1", Name: "SafariZoneNorthRestHouse", blockset: "GATE", connections: {}, warps: [{ row: "2", col: "7", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_NORTH_REST_HOUSE" }, { row: "3", col: "7", dest: "SAFARI_ZONE_NORTH", src: "SAFARI_ZONE_NORTH_REST_HOUSE" }], mapData: { type: "Buffer", data: [3, 7, 77, 77, 59, 56, 0, 0, 59, 56, 17, 33, 0, 11, 8, 1] } }, { CONSTANT_NAME: "CERULEAN_CAVE_2F", height: 9, width: 15, id: "E2", Name: "CeruleanCave2F", blockset: "CAVERN", connections: {}, warps: [{ row: "29", col: "1", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CAVE_2F" }, { row: "22", col: "6", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CAVE_2F" }, { row: "19", col: "7", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CAVE_2F" }, { row: "9", col: "1", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CAVE_2F" }, { row: "1", col: "3", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CAVE_2F" }, { row: "3", col: "11", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CAVE_2F" }], mapData: { type: "Buffer", data: [125, 8, 5, 14, 40, 8, 5, 5, 5, 9, 14, 4, 7, 8, 40, 40, 6, 5, 5, 5, 6, 6, 6, 9, 15, 13, 13, 7, 10, 15, 15, 5, 5, 5, 6, 5, 14, 5, 7, 8, 14, 11, 13, 4, 6, 8, 5, 5, 15, 5, 5, 10, 125, 7, 40, 11, 35, 8, 14, 4, 14, 8, 5, 5, 5, 5, 14, 12, 5, 5, 5, 6, 6, 9, 5, 7, 40, 6, 5, 5, 9, 7, 5, 5, 5, 5, 14, 9, 7, 7, 12, 9, 8, 5, 9, 11, 7, 15, 6, 5, 5, 9, 7, 7, 12, 8, 7, 14, 125, 4, 7, 15, 6, 5, 5, 8, 7, 7, 4, 13, 6, 5, 5, 13, 4, 12, 14, 5, 5, 5, 6, 5, 5, 14, 11] } }, { CONSTANT_NAME: "CERULEAN_CAVE_B1F", height: 9, width: 15, id: "E3", Name: "CeruleanCaveB1F", blockset: "CAVERN", connections: {}, warps: [{ row: "3", col: "6", dest: "CERULEAN_CAVE_1F", src: "CERULEAN_CAVE_B1F" }], mapData: { type: "Buffer", data: [20, 21, 21, 21, 21, 21, 21, 22, 20, 21, 22, 20, 21, 21, 22, 24, 25, 44, 29, 29, 29, 45, 30, 28, 45, 30, 24, 25, 78, 26, 24, 25, 26, 8, 5, 1, 1, 5, 1, 4, 114, 24, 48, 50, 26, 28, 97, 30, 14, 20, 21, 21, 21, 22, 20, 21, 125, 26, 102, 30, 8, 14, 13, 11, 24, 68, 43, 23, 26, 24, 44, 29, 30, 118, 2, 13, 32, 34, 23, 24, 112, 24, 31, 26, 102, 30, 118, 118, 118, 125, 12, 7, 2, 31, 102, 88, 102, 29, 30, 118, 23, 118, 20, 21, 22, 23, 1, 8, 1, 94, 116, 118, 118, 116, 118, 31, 118, 28, 41, 30, 31, 12, 1, 13, 2, 32, 34, 118, 118, 118, 83, 118, 118, 118, 118] } }, { CONSTANT_NAME: "CERULEAN_CAVE_1F", height: 9, width: 15, id: "E4", Name: "CeruleanCave1F", blockset: "CAVERN", connections: {}, warps: [{ row: "24", col: "17", dest: "LAST_MAP", src: "CERULEAN_CAVE_1F" }, { row: "25", col: "17", dest: "LAST_MAP", src: "CERULEAN_CAVE_1F" }, { row: "27", col: "1", dest: "CERULEAN_CAVE_2F", src: "CERULEAN_CAVE_1F" }, { row: "23", col: "7", dest: "CERULEAN_CAVE_2F", src: "CERULEAN_CAVE_1F" }, { row: "18", col: "9", dest: "CERULEAN_CAVE_2F", src: "CERULEAN_CAVE_1F" }, { row: "7", col: "1", dest: "CERULEAN_CAVE_2F", src: "CERULEAN_CAVE_1F" }, { row: "1", col: "3", dest: "CERULEAN_CAVE_2F", src: "CERULEAN_CAVE_1F" }, { row: "3", col: "11", dest: "CERULEAN_CAVE_2F", src: "CERULEAN_CAVE_1F" }, { row: "0", col: "6", dest: "CERULEAN_CAVE_B1F", src: "CERULEAN_CAVE_1F" }], mapData: { type: "Buffer", data: [32, 34, 20, 124, 21, 21, 21, 21, 22, 2, 2, 20, 21, 124, 22, 98, 9, 28, 29, 29, 29, 29, 45, 30, 8, 125, 102, 29, 29, 30, 2, 4, 12, 23, 2, 78, 95, 118, 118, 118, 118, 118, 118, 118, 118, 35, 16, 4, 31, 118, 118, 118, 118, 114, 125, 20, 124, 21, 113, 118, 20, 21, 21, 22, 118, 20, 21, 21, 21, 127, 24, 44, 45, 88, 118, 24, 61, 44, 30, 118, 24, 25, 116, 25, 26, 102, 30, 118, 118, 118, 102, 29, 30, 8, 118, 102, 29, 43, 125, 26, 6, 15, 95, 20, 22, 1, 15, 32, 34, 118, 118, 2, 28, 45, 30, 1, 1, 1, 24, 26, 10, 1, 1, 15, 5, 5, 5, 14, 13, 125, 32, 34, 36, 28, 30] } }, { CONSTANT_NAME: "NAME_RATERS_HOUSE", height: 4, width: 4, id: "E5", Name: "NameRatersHouse", blockset: "HOUSE", connections: {}, warps: [{ row: "2", col: "7", dest: "LAST_MAP", src: "NAME_RATERS_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "NAME_RATERS_HOUSE" }], mapData: { type: "Buffer", data: [4, 14, 5, 9, 15, 1, 2, 15, 15, 12, 13, 15, 6, 11, 15, 7] } }, { CONSTANT_NAME: "CERULEAN_BADGE_HOUSE", height: 4, width: 4, id: "E6", Name: "CeruleanBadgeHouse", blockset: "SHIP", connections: {}, warps: [{ row: "2", col: "0", dest: "LAST_MAP", src: "CERULEAN_BADGE_HOUSE" }, { row: "2", col: "7", dest: "LAST_MAP", src: "CERULEAN_BADGE_HOUSE" }, { row: "3", col: "7", dest: "LAST_MAP", src: "CERULEAN_BADGE_HOUSE" }], mapData: { type: "Buffer", data: [61, 9, 61, 61, 11, 11, 7, 6, 11, 11, 11, 44, 11, 27, 11, 53] } }, { CONSTANT_NAME: "UNUSED_MAP_E7", height: 0, width: 0, id: "E7" }, { CONSTANT_NAME: "ROCK_TUNNEL_B1F", height: 18, width: 20, id: "E8", Name: "RockTunnelB1F", blockset: "CAVERN", connections: {}, warps: [{ row: "33", col: "25", dest: "ROCK_TUNNEL_1F", src: "ROCK_TUNNEL_B1F" }, { row: "27", col: "3", dest: "ROCK_TUNNEL_1F", src: "ROCK_TUNNEL_B1F" }, { row: "23", col: "11", dest: "ROCK_TUNNEL_1F", src: "ROCK_TUNNEL_B1F" }, { row: "3", col: "3", dest: "ROCK_TUNNEL_1F", src: "ROCK_TUNNEL_B1F" }], mapData: { type: "Buffer", data: [23, 2, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 31, 62, 1, 23, 1, 1, 23, 1, 1, 1, 1, 1, 23, 62, 1, 1, 1, 1, 1, 2, 23, 1, 1, 31, 1, 1, 31, 1, 1, 1, 1, 1, 31, 1, 1, 1, 1, 1, 1, 23, 31, 1, 1, 23, 1, 1, 23, 1, 1, 23, 1, 1, 23, 1, 1, 23, 23, 1, 1, 31, 23, 1, 1, 31, 1, 1, 31, 1, 1, 31, 2, 2, 31, 1, 1, 31, 31, 1, 1, 23, 31, 1, 1, 1, 1, 1, 23, 1, 1, 1, 1, 62, 23, 1, 1, 1, 1, 1, 1, 31, 23, 1, 1, 1, 1, 1, 31, 1, 1, 1, 1, 1, 31, 1, 1, 1, 1, 1, 1, 23, 31, 1, 1, 23, 1, 1, 1, 1, 1, 23, 32, 34, 32, 34, 32, 34, 1, 1, 1, 31, 23, 1, 1, 31, 1, 1, 1, 1, 1, 31, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 31, 1, 1, 23, 1, 1, 2, 1, 1, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31, 23, 1, 1, 31, 1, 1, 2, 1, 1, 31, 1, 1, 1, 32, 34, 32, 34, 32, 34, 23, 31, 2, 2, 2, 1, 1, 32, 34, 32, 34, 1, 1, 1, 23, 1, 1, 1, 1, 1, 31, 23, 1, 1, 1, 1, 1, 23, 1, 1, 1, 1, 1, 1, 31, 1, 1, 62, 1, 1, 23, 31, 1, 1, 1, 1, 1, 31, 1, 1, 1, 1, 1, 1, 23, 1, 1, 1, 1, 1, 31, 23, 32, 34, 32, 34, 32, 34, 1, 1, 32, 34, 32, 34, 31, 1, 1, 1, 1, 1, 23, 31, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 31, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 32, 34, 2, 31] } }, { CONSTANT_NAME: "SILPH_CO_9F", height: 9, width: 13, id: "E9", Name: "SilphCo9F", blockset: "FACILITY", connections: {}, warps: [{ row: "14", col: "0", dest: "SILPH_CO_10F", src: "SILPH_CO_9F" }, { row: "16", col: "0", dest: "SILPH_CO_8F", src: "SILPH_CO_9F" }, { row: "18", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_9F" }, { row: "9", col: "3", dest: "SILPH_CO_3F", src: "SILPH_CO_9F" }, { row: "17", col: "15", dest: "SILPH_CO_5F", src: "SILPH_CO_9F" }], mapData: { type: "Buffer", data: [64, 65, 65, 65, 65, 66, 65, 125, 36, 124, 61, 61, 62, 68, 14, 14, 14, 47, 70, 14, 14, 14, 14, 14, 14, 70, 68, 90, 103, 65, 65, 66, 14, 64, 99, 14, 103, 89, 70, 68, 86, 14, 71, 71, 70, 14, 68, 14, 52, 14, 18, 70, 68, 14, 14, 103, 64, 66, 13, 68, 14, 55, 14, 18, 70, 68, 90, 14, 14, 85, 86, 13, 64, 99, 14, 103, 66, 70, 80, 74, 67, 67, 14, 14, 14, 68, 71, 123, 14, 86, 70, 68, 67, 67, 67, 89, 90, 14, 68, 47, 71, 14, 14, 70, 72, 73, 73, 73, 72, 74, 73, 72, 73, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_10F", height: 9, width: 8, id: "EA", Name: "SilphCo10F", blockset: "FACILITY", connections: {}, warps: [{ row: "8", col: "0", dest: "SILPH_CO_9F", src: "SILPH_CO_10F" }, { row: "10", col: "0", dest: "SILPH_CO_11F", src: "SILPH_CO_10F" }, { row: "12", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_10F" }, { row: "9", col: "11", dest: "SILPH_CO_4F", src: "SILPH_CO_10F" }, { row: "13", col: "15", dest: "SILPH_CO_4F", src: "SILPH_CO_10F" }, { row: "13", col: "7", dest: "SILPH_CO_4F", src: "SILPH_CO_10F" }], mapData: { type: "Buffer", data: [60, 61, 61, 61, 36, 125, 124, 62, 68, 14, 14, 14, 14, 14, 14, 70, 68, 14, 14, 90, 99, 14, 103, 66, 68, 14, 14, 70, 13, 14, 47, 70, 64, 42, 43, 66, 99, 14, 103, 66, 68, 53, 24, 70, 47, 14, 123, 70, 68, 30, 53, 70, 14, 123, 55, 70, 68, 10, 30, 70, 14, 55, 47, 70, 72, 73, 73, 74, 73, 73, 73, 74] } }, { CONSTANT_NAME: "SILPH_CO_11F", height: 9, width: 9, id: "EB", Name: "SilphCo11F", blockset: "INTERIOR", connections: {}, warps: [{ row: "9", col: "0", dest: "SILPH_CO_10F", src: "SILPH_CO_11F" }, { row: "13", col: "0", dest: "SILPH_CO_ELEVATOR", src: "SILPH_CO_11F" }, { row: "5", col: "5", dest: "LAST_MAP", src: "SILPH_CO_11F" }, { row: "3", col: "2", dest: "SILPH_CO_7F", src: "SILPH_CO_11F" }], mapData: { type: "Buffer", data: [33, 34, 33, 34, 30, 34, 29, 34, 35, 36, 57, 50, 49, 49, 49, 52, 14, 40, 36, 14, 51, 18, 19, 22, 53, 14, 40, 36, 14, 36, 16, 17, 14, 42, 14, 40, 36, 14, 36, 20, 21, 3, 42, 14, 40, 36, 14, 36, 14, 3, 3, 42, 14, 40, 36, 14, 55, 3, 54, 56, 42, 14, 40, 36, 14, 14, 14, 36, 14, 42, 14, 40, 37, 38, 38, 38, 37, 38, 46, 38, 39] } }, { CONSTANT_NAME: "SILPH_CO_ELEVATOR", height: 2, width: 2, id: "EC", Name: "SilphCoElevator", blockset: "LOBBY", connections: {}, warps: [{ row: "1", col: "3", dest: "UNUSED_MAP_ED", src: "SILPH_CO_ELEVATOR" }, { row: "2", col: "3", dest: "UNUSED_MAP_ED", src: "SILPH_CO_ELEVATOR" }], mapData: { type: "Buffer", data: [42, 43, 40, 41] } }, { CONSTANT_NAME: "UNUSED_MAP_ED", height: 0, width: 0, id: "ED" }, { CONSTANT_NAME: "UNUSED_MAP_EE", height: 0, width: 0, id: "EE" }, { CONSTANT_NAME: "TRADE_CENTER", height: 4, width: 5, id: "EF", Name: "TradeCenter", blockset: "CLUB", connections: {}, warps: [], mapData: { type: "Buffer", data: [27, 30, 19, 30, 23, 10, 16, 31, 18, 10, 32, 33, 28, 34, 35, 10, 24, 25, 26, 10] } }, { CONSTANT_NAME: "COLOSSEUM", height: 4, width: 5, id: "F0", Name: "Colosseum", blockset: "CLUB", connections: {}, warps: [], mapData: { type: "Buffer", data: [27, 23, 19, 27, 23, 10, 16, 17, 18, 10, 10, 20, 21, 22, 10, 10, 24, 25, 26, 10] } }, { CONSTANT_NAME: "UNUSED_MAP_F1", height: 0, width: 0, id: "F1" }, { CONSTANT_NAME: "UNUSED_MAP_F2", height: 0, width: 0, id: "F2" }, { CONSTANT_NAME: "UNUSED_MAP_F3", height: 0, width: 0, id: "F3" }, { CONSTANT_NAME: "UNUSED_MAP_F4", height: 0, width: 0, id: "F4" }, { CONSTANT_NAME: "LORELEIS_ROOM", height: 6, width: 5, id: "F5", Name: "LoreleisRoom", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "11", dest: "INDIGO_PLATEAU_LOBBY", src: "LORELEIS_ROOM" }, { row: "5", col: "11", dest: "INDIGO_PLATEAU_LOBBY", src: "LORELEIS_ROOM" }, { row: "4", col: "0", dest: "BRUNOS_ROOM", src: "LORELEIS_ROOM" }, { row: "5", col: "0", dest: "BRUNOS_ROOM", src: "LORELEIS_ROOM" }], mapData: { type: "Buffer", data: [33, 33, 36, 33, 33, 2, 24, 24, 24, 2, 2, 24, 24, 24, 2, 2, 32, 5, 32, 2, 2, 26, 5, 2, 2, 2, 68, 5, 68, 2] } }, { CONSTANT_NAME: "BRUNOS_ROOM", height: 6, width: 5, id: "F6", Name: "BrunosRoom", blockset: "GYM", connections: {}, warps: [{ row: "4", col: "11", dest: "LORELEIS_ROOM", src: "BRUNOS_ROOM" }, { row: "5", col: "11", dest: "LORELEIS_ROOM", src: "BRUNOS_ROOM" }, { row: "4", col: "0", dest: "AGATHAS_ROOM", src: "BRUNOS_ROOM" }, { row: "5", col: "0", dest: "AGATHAS_ROOM", src: "BRUNOS_ROOM" }], mapData: { type: "Buffer", data: [1, 1, 5, 1, 1, 8, 5, 5, 5, 10, 12, 18, 5, 19, 13, 12, 10, 5, 11, 12, 8, 7, 5, 12, 8, 13, 17, 5, 10, 13] } }, { CONSTANT_NAME: "AGATHAS_ROOM", height: 6, width: 5, id: "F7", Name: "AgathasRoom", blockset: "CEMETERY", connections: {}, warps: [{ row: "4", col: "11", dest: "BRUNOS_ROOM", src: "AGATHAS_ROOM" }, { row: "5", col: "11", dest: "BRUNOS_ROOM", src: "AGATHAS_ROOM" }, { row: "4", col: "0", dest: "LANCES_ROOM", src: "AGATHAS_ROOM" }, { row: "5", col: "0", dest: "LANCES_ROOM", src: "AGATHAS_ROOM" }], mapData: { type: "Buffer", data: [71, 71, 54, 71, 71, 103, 54, 54, 78, 101, 82, 78, 54, 101, 82, 101, 103, 54, 101, 101, 82, 75, 54, 101, 82, 103, 82, 54, 104, 104] } }];
    }
  });

  // src/gfx.json
  var require_gfx = __commonJS({
    "src/gfx.json"(exports, module) {
      module.exports = { cavern: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [4, 41, 41, 7, 49, 5, 5, 23, 49, 5, 5, 23, 40, 16, 16, 17] }, { type: "Buffer", data: [60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [2, 3, 32, 32, 18, 19, 32, 32, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [2, 3, 32, 32, 18, 19, 32, 32, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [2, 3, 32, 32, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [2, 3, 32, 32, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 4, 41, 41, 4, 49, 5, 5, 49, 49, 5, 5, 49, 49, 5, 5] }, { type: "Buffer", data: [41, 41, 41, 41, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] }, { type: "Buffer", data: [41, 41, 7, 32, 5, 5, 23, 7, 5, 5, 23, 23, 5, 5, 23, 23] }, { type: "Buffer", data: [4, 41, 41, 7, 49, 5, 5, 23, 49, 5, 5, 23, 49, 5, 5, 23] }, { type: "Buffer", data: [49, 49, 5, 5, 49, 49, 5, 5, 49, 49, 5, 5, 49, 49, 5, 5] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] }, { type: "Buffer", data: [5, 5, 23, 23, 5, 5, 23, 23, 5, 5, 23, 23, 5, 5, 23, 23] }, { type: "Buffer", data: [49, 5, 5, 23, 49, 5, 5, 23, 49, 5, 5, 23, 49, 5, 5, 23] }, { type: "Buffer", data: [49, 49, 5, 5, 49, 49, 5, 5, 49, 40, 16, 16, 40, 16, 16, 16] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [5, 5, 23, 23, 5, 5, 23, 23, 16, 16, 17, 23, 16, 16, 16, 17] }, { type: "Buffer", data: [49, 5, 5, 23, 49, 5, 5, 23, 49, 5, 5, 23, 40, 16, 16, 17] }, { type: "Buffer", data: [4, 41, 41, 41, 49, 5, 5, 5, 49, 5, 5, 5, 40, 16, 16, 16] }, { type: "Buffer", data: [41, 41, 41, 41, 5, 5, 5, 5, 5, 5, 5, 5, 16, 16, 16, 16] }, { type: "Buffer", data: [41, 41, 41, 7, 5, 5, 5, 23, 5, 5, 5, 23, 16, 16, 16, 17] }, { type: "Buffer", data: [8, 9, 2, 3, 24, 25, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33] }, { type: "Buffer", data: [5, 5, 6, 39, 5, 5, 36, 1, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [2, 3, 41, 41, 18, 19, 5, 5, 2, 3, 5, 5, 18, 19, 5, 5] }, { type: "Buffer", data: [8, 9, 32, 32, 24, 25, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 8, 9, 32, 32, 24, 25] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 21, 22, 21, 22, 21, 22, 21, 22] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 14, 15, 32, 32, 30, 31] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 16, 38, 5, 5, 38, 49, 5, 5] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 37, 16, 5, 5, 23, 37] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 16, 16, 21, 22, 16, 16, 21, 22] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [6, 39, 6, 39, 36, 1, 36, 1, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [5, 5, 37, 16, 5, 5, 23, 37, 5, 5, 23, 23, 5, 5, 23, 23] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [16, 38, 5, 5, 38, 49, 5, 5, 49, 49, 5, 5, 49, 49, 5, 5] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [6, 39, 5, 5, 36, 1, 5, 5, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [5, 5, 6, 39, 5, 5, 36, 1, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [6, 39, 5, 5, 36, 1, 5, 5, 6, 39, 5, 5, 36, 1, 5, 5] }, { type: "Buffer", data: [5, 5, 6, 39, 5, 5, 36, 1, 5, 5, 6, 39, 5, 5, 36, 1] }, { type: "Buffer", data: [6, 39, 6, 39, 36, 1, 36, 1, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 5, 5, 5, 5, 5, 5, 5, 5] }, { type: "Buffer", data: [6, 39, 5, 5, 36, 1, 5, 5, 16, 16, 5, 5, 16, 16, 5, 5] }, { type: "Buffer", data: [5, 5, 6, 39, 5, 5, 36, 1, 5, 5, 16, 16, 5, 5, 16, 16] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 9, 5, 5, 24, 25] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 11, 5, 5, 26, 27] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 10, 11, 32, 32, 26, 27] }, { type: "Buffer", data: [60, 60, 60, 60, 60, 60, 60, 60, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 38, 5, 5, 38, 49, 5, 5] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 5, 5, 5, 5, 5, 5, 5, 5] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 5, 5, 37, 16, 5, 5, 23, 37] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 37, 16, 16, 16, 23, 37, 16, 16] }, { type: "Buffer", data: [5, 5, 5, 5, 5, 5, 5, 5, 16, 16, 16, 38, 16, 16, 38, 49] }, { type: "Buffer", data: [16, 16, 16, 38, 16, 16, 38, 49, 32, 32, 49, 49, 32, 32, 49, 49] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [23, 23, 32, 32, 23, 23, 32, 32, 23, 23, 32, 32, 23, 23, 32, 32] }, { type: "Buffer", data: [32, 32, 49, 49, 32, 32, 49, 49, 32, 32, 49, 49, 32, 32, 49, 49] }, { type: "Buffer", data: [23, 23, 32, 32, 23, 23, 32, 32, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [32, 32, 49, 49, 32, 32, 49, 49, 6, 39, 6, 39, 36, 1, 36, 1] }, { type: "Buffer", data: [12, 13, 32, 32, 28, 29, 32, 32, 12, 13, 12, 13, 28, 29, 28, 29] }, { type: "Buffer", data: [2, 3, 12, 13, 18, 19, 28, 29, 2, 3, 12, 13, 18, 19, 28, 29] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 2, 3, 12, 13, 18, 19, 28, 29] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 12, 13, 32, 32, 28, 29, 32, 32] }, { type: "Buffer", data: [33, 33, 32, 32, 33, 33, 32, 32, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [12, 13, 12, 13, 28, 29, 28, 29, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [12, 13, 12, 13, 28, 29, 28, 29, 12, 13, 12, 13, 28, 29, 28, 29] }, { type: "Buffer", data: [2, 3, 12, 13, 18, 19, 28, 29, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [49, 40, 21, 22, 40, 16, 21, 22, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [41, 41, 16, 16, 5, 5, 16, 16, 5, 5, 42, 42, 5, 5, 42, 42] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [23, 23, 2, 3, 23, 23, 18, 19, 17, 23, 2, 3, 16, 17, 18, 19] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 7, 32, 2, 3, 23, 7, 18, 19] }, { type: "Buffer", data: [16, 16, 42, 42, 16, 16, 42, 42, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 41, 41, 41, 41, 5, 5, 5, 5] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 41, 41, 32, 32, 5, 5, 32, 32] }, { type: "Buffer", data: [7, 32, 32, 32, 23, 7, 32, 32, 41, 41, 41, 41, 5, 5, 5, 5] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 12, 13, 12, 13, 28, 29, 28, 29] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 12, 13, 12, 13, 28, 29, 28, 29] }, { type: "Buffer", data: [42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42] }, { type: "Buffer", data: [5, 5, 10, 11, 5, 5, 26, 27, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 2, 3, 10, 11, 18, 19, 26, 27] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 32, 32, 33, 33, 32, 32, 33, 33] }, { type: "Buffer", data: [32, 32, 41, 41, 32, 32, 5, 5, 32, 32, 5, 5, 32, 32, 5, 5] }, { type: "Buffer", data: [2, 3, 43, 44, 18, 19, 45, 46, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [49, 49, 5, 5, 49, 49, 5, 5, 49, 40, 21, 22, 40, 16, 21, 22] }, { type: "Buffer", data: [32, 32, 33, 33, 32, 32, 33, 33, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 47, 47, 32, 32, 34, 34, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 47, 47, 32, 32, 34, 34] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 4, 41, 41, 4, 49, 5, 5] }, { type: "Buffer", data: [12, 13, 12, 13, 28, 29, 28, 29, 41, 41, 41, 41, 5, 5, 5, 5] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 43, 44, 32, 32, 45, 46] }, { type: "Buffer", data: [12, 13, 32, 32, 28, 29, 32, 32, 12, 13, 32, 32, 28, 29, 32, 32] }, { type: "Buffer", data: [12, 13, 12, 13, 28, 29, 28, 29, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 7, 32, 32, 32, 23, 7, 32, 32] }, { type: "Buffer", data: [23, 23, 2, 3, 23, 23, 18, 19, 23, 23, 2, 3, 23, 23, 18, 19] }, { type: "Buffer", data: [7, 32, 2, 3, 23, 7, 18, 19, 23, 23, 2, 3, 23, 23, 18, 19] }, { type: "Buffer", data: [12, 13, 2, 3, 28, 29, 18, 19, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [23, 23, 32, 32, 23, 23, 32, 32, 23, 23, 32, 32, 23, 23, 32, 32] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 12, 13, 2, 3, 28, 29, 18, 19] }, { type: "Buffer", data: [41, 41, 41, 41, 5, 5, 5, 5, 5, 5, 14, 15, 5, 5, 30, 31] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [47, 47, 32, 32, 34, 34, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 47, 47, 32, 32, 34, 34, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [5, 5, 8, 9, 5, 5, 24, 25, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [12, 13, 12, 13, 28, 29, 28, 29, 32, 32, 12, 13, 32, 32, 28, 29] }, { type: "Buffer", data: [49, 49, 5, 5, 49, 49, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] }, { type: "Buffer", data: [41, 41, 41, 41, 5, 5, 5, 5, 5, 5, 10, 11, 5, 5, 26, 27] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [23, 23, 32, 32, 23, 23, 32, 32, 5, 5, 41, 41, 5, 5, 5, 5] }, { type: "Buffer", data: [41, 41, 7, 32, 5, 5, 23, 7, 10, 11, 23, 23, 26, 27, 23, 23] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 33, 136, 139, 34, 33, 136, 139, 42, 139, 136, 1, 162, 3, 119, 117, 85, 127, 87, 194, 126, 168, 204, 146, 50, 136, 232, 162, 226, 106, 232, 170, 253, 85, 35, 117, 138, 254, 41, 187, 170, 238, 170, 183, 153, 239, 102, 183, 85, 85, 85, 95, 87, 240, 92, 26, 92, 24, 112, 225, 113, 130, 236, 99, 170, 168, 170, 42, 168, 170, 170, 42, 154, 153, 170, 106, 136, 170, 162, 41, 221, 221, 72, 136, 226, 34, 72, 136, 234, 136, 72, 2, 98, 0, 72, 138, 213, 85, 245, 85, 175, 213, 94, 181, 158, 181, 231, 173, 105, 237, 231, 183, 86, 101, 91, 245, 103, 63, 91, 63, 95, 16, 95, 63, 127, 63, 127, 16, 85, 101, 95, 213, 252, 213, 252, 213, 4, 245, 252, 245, 252, 253, 4, 253, 87, 255, 91, 16, 103, 63, 91, 63, 87, 16, 87, 63, 87, 63, 87, 16, 255, 229, 4, 213, 252, 213, 252, 213, 4, 213, 252, 213, 252, 213, 4, 213, 87, 229, 124, 55, 122, 175, 123, 236, 252, 60, 92, 3, 112, 2, 112, 2, 126, 101, 195, 215, 204, 117, 50, 117, 2, 119, 200, 221, 63, 247, 48, 53, 86, 103, 121, 158, 127, 255, 213, 85, 192, 0, 238, 190, 207, 62, 234, 160, 214, 101, 185, 151, 255, 253, 85, 87, 0, 3, 235, 235, 251, 15, 0, 3, 61, 92, 151, 240, 156, 48, 116, 14, 122, 13, 218, 151, 250, 151, 221, 223, 61, 95, 151, 255, 156, 15, 116, 3, 122, 7, 218, 157, 250, 189, 221, 245, 226, 170, 254, 154, 251, 18, 226, 217, 233, 100, 239, 153, 126, 213, 91, 191, 153, 239, 170, 119, 142, 223, 103, 183, 25, 223, 102, 247, 87, 189, 254, 229, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 213, 170, 213, 170, 213, 85, 255, 255, 213, 170, 213, 170, 213, 85, 255, 255, 170, 171, 170, 171, 85, 87, 255, 255, 170, 171, 170, 171, 85, 87, 255, 255, 223, 95, 255, 215, 174, 189, 174, 173, 107, 107, 91, 247, 119, 173, 222, 175, 127, 191, 127, 191, 111, 85, 95, 127, 87, 255, 85, 127, 85, 85, 85, 85, 254, 253, 254, 253, 85, 245, 253, 245, 255, 213, 253, 85, 85, 85, 85, 85, 87, 191, 91, 191, 103, 90, 91, 127, 87, 245, 85, 85, 85, 85, 85, 85, 254, 229, 254, 213, 165, 213, 253, 213, 95, 213, 85, 85, 85, 85, 85, 85, 213, 8, 213, 80, 221, 223, 127, 119, 215, 223, 85, 254, 85, 119, 117, 85, 200, 61, 194, 167, 0, 42, 128, 90, 103, 119, 157, 223, 247, 127, 127, 213, 112, 0, 235, 187, 192, 0, 127, 255, 213, 125, 85, 254, 85, 127, 117, 95, 0, 3, 187, 171, 0, 3, 255, 253, 117, 119, 189, 221, 253, 119, 245, 85, 86, 101, 121, 151, 102, 85, 89, 85, 213, 119, 85, 221, 85, 119, 117, 85, 153, 153, 68, 102, 17, 145, 102, 70, 17, 145, 68, 70, 17, 145, 102, 102, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 85, 245, 92, 141, 114, 39, 120, 155, 221, 109, 87, 247, 85, 119, 117, 85, 226, 34, 72, 136, 226, 34, 72, 136, 234, 136, 72, 2, 98, 0, 119, 117, 218, 89, 105, 215, 156, 16, 176, 48, 66, 194, 103, 74, 176, 230, 208, 25, 230, 103, 49, 118, 135, 220, 103, 234, 27, 184, 108, 162, 94, 12, 232, 131, 221, 213, 136, 139, 34, 33, 136, 139, 42, 139, 136, 1, 162, 3, 136, 137, 106, 172, 215, 240, 92, 12, 180, 3, 186, 5, 250, 149, 126, 151, 87, 223, 125, 221, 200, 139, 162, 34, 138, 168, 154, 153, 170, 106, 170, 170, 106, 106, 117, 119, 221, 221, 119, 119, 221, 93, 87, 119, 221, 221, 119, 119, 221, 213, 86, 101, 121, 151, 102, 95, 89, 240, 215, 5, 87, 26, 92, 104, 124, 104, 86, 101, 121, 151, 246, 85, 15, 85, 80, 247, 164, 221, 41, 55, 41, 53, 92, 106, 124, 106, 103, 26, 91, 5, 213, 240, 85, 223, 85, 119, 117, 85, 169, 53, 169, 55, 164, 213, 80, 213, 15, 119, 245, 221, 85, 119, 117, 85, 86, 101, 249, 159, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 125, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 218, 89, 105, 215, 220, 16, 112, 48, 194, 194, 71, 74, 240, 230, 80, 25, 85, 85, 85, 95, 85, 252, 87, 218, 95, 24, 124, 161, 114, 134, 232, 161, 255, 255, 162, 42, 68, 85, 17, 85, 70, 100, 25, 144, 102, 64, 153, 1, 213, 85, 117, 85, 95, 85, 87, 213, 86, 245, 85, 117, 86, 109, 89, 151, 226, 35, 214, 132, 217, 18, 114, 89, 93, 100, 87, 144, 85, 192, 85, 127, 230, 103, 50, 52, 136, 81, 33, 38, 136, 85, 33, 21, 85, 85, 255, 255, 238, 239, 51, 119, 142, 223, 103, 189, 25, 245, 102, 213, 87, 85, 253, 85, 168, 138, 162, 42, 136, 170, 34, 170, 138, 168, 42, 160, 170, 128, 170, 2, 218, 33, 218, 138, 54, 32, 196, 0, 50, 0, 232, 162, 226, 0, 232, 130, 70, 87, 81, 87, 86, 86, 85, 155, 86, 102, 85, 151, 86, 103, 89, 151, 86, 101, 85, 85, 102, 85, 89, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 85, 127, 87, 234, 94, 170, 122, 154, 122, 170, 234, 170, 234, 106, 218, 170, 253, 85, 171, 213, 170, 181, 169, 189, 170, 237, 170, 183, 153, 239, 102, 183, 234, 170, 222, 102, 254, 153, 250, 85, 237, 213, 247, 119, 125, 223, 87, 255, 153, 239, 102, 119, 158, 223, 103, 191, 85, 223, 119, 119, 221, 253, 255, 213, 170, 168, 170, 42, 168, 170, 170, 42, 154, 153, 170, 106, 136, 170, 162, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, cemetery: { blocks: [{ type: "Buffer", data: [71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 17, 17, 9, 10, 17, 17, 25, 26] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [9, 10, 17, 17, 25, 26, 17, 17, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [17, 17, 9, 10, 17, 17, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 17, 17, 25, 26, 17, 17] }, { type: "Buffer", data: [17, 17, 9, 10, 17, 17, 25, 26, 17, 17, 9, 10, 17, 17, 25, 26] }, { type: "Buffer", data: [9, 10, 17, 17, 25, 26, 17, 17, 9, 10, 17, 17, 25, 26, 17, 17] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [16, 16, 16, 16, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [17, 17, 9, 10, 17, 17, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 11, 12, 25, 26, 27, 28] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 3, 4, 9, 10, 19, 20, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 6, 1, 1, 21, 22] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 17, 17, 9, 10, 17, 17, 25, 26] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 3, 4, 25, 26, 19, 20] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 11, 12, 9, 10, 27, 28, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 5, 6, 1, 1, 21, 22, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 16, 16, 25, 26, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 16, 16, 16, 16, 1, 1, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 16, 16, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 3, 4, 1, 1, 19, 20, 1, 1] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 11, 12, 1, 1, 27, 28, 1, 1] }, { type: "Buffer", data: [2, 2, 2, 2, 18, 18, 18, 18, 16, 16, 16, 16, 1, 1, 1, 1] }, { type: "Buffer", data: [2, 2, 13, 14, 18, 18, 29, 30, 16, 16, 29, 30, 1, 1, 29, 30] }, { type: "Buffer", data: [2, 2, 2, 2, 18, 18, 18, 18, 16, 16, 16, 16, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 29, 30, 1, 1, 29, 30, 1, 1, 29, 30, 1, 1, 29, 30] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 15, 15, 15, 15, 31, 31, 31, 31] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 15, 15, 25, 26, 31, 31] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 15, 15, 9, 10, 31, 31, 25, 26] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 29, 30, 1, 1, 29, 30, 15, 15, 15, 15, 31, 31, 31, 31] }, { type: "Buffer", data: [13, 2, 2, 14, 33, 32, 32, 35, 49, 48, 48, 51, 61, 62, 61, 62] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [9, 10, 31, 31, 25, 26, 31, 31, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [31, 31, 9, 10, 31, 31, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 3, 4, 25, 26, 19, 20, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 11, 12, 25, 26, 27, 28, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [3, 4, 1, 1, 19, 20, 1, 1, 3, 4, 1, 1, 19, 20, 1, 1] }, { type: "Buffer", data: [34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 16, 16, 16, 16, 1, 1, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [7, 8, 7, 8, 23, 24, 23, 24, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 9, 10, 17, 17, 25, 26] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 9, 10, 17, 17, 25, 26, 17, 17] }, { type: "Buffer", data: [9, 10, 17, 17, 25, 26, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [2, 2, 2, 2, 18, 18, 18, 18, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [45, 42, 42, 42, 43, 44, 58, 58, 43, 44, 16, 16, 43, 44, 1, 1] }, { type: "Buffer", data: [42, 42, 42, 42, 58, 58, 58, 58, 16, 16, 16, 16, 1, 1, 1, 1] }, { type: "Buffer", data: [42, 42, 42, 46, 58, 58, 43, 44, 16, 16, 43, 44, 1, 1, 43, 44] }, { type: "Buffer", data: [40, 41, 40, 41, 56, 57, 56, 57, 56, 57, 56, 57, 72, 73, 72, 73] }, { type: "Buffer", data: [43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 39, 47, 1, 1, 55, 63, 1, 1, 61, 62, 1, 1] }, { type: "Buffer", data: [1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44] }, { type: "Buffer", data: [32, 32, 32, 32, 48, 48, 48, 48, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [43, 44, 1, 1, 43, 44, 1, 1, 45, 42, 42, 42, 59, 58, 58, 58] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 42, 42, 42, 42, 58, 58, 58, 58] }, { type: "Buffer", data: [1, 1, 43, 44, 1, 1, 43, 44, 42, 42, 42, 46, 58, 58, 58, 60] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 39, 47, 1, 1, 55, 63, 1, 1, 61, 62] }, { type: "Buffer", data: [5, 6, 5, 6, 21, 22, 21, 22, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [5, 6, 1, 1, 21, 22, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 5, 6, 1, 1, 21, 22, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 5, 6, 5, 6, 21, 22, 21, 22] }, { type: "Buffer", data: [1, 1, 5, 6, 1, 1, 21, 22, 1, 1, 5, 6, 1, 1, 21, 22] }, { type: "Buffer", data: [5, 6, 1, 1, 21, 22, 1, 1, 5, 6, 1, 1, 21, 22, 1, 1] }, { type: "Buffer", data: [5, 6, 5, 6, 21, 22, 21, 22, 5, 6, 5, 6, 21, 22, 21, 22] }, { type: "Buffer", data: [9, 10, 5, 6, 25, 26, 21, 22, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [5, 6, 9, 10, 21, 22, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [5, 6, 1, 1, 21, 22, 1, 1, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [5, 6, 5, 6, 21, 22, 21, 22, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 5, 6, 25, 26, 21, 22] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 5, 6, 9, 10, 21, 22, 25, 26] }, { type: "Buffer", data: [5, 6, 9, 10, 21, 22, 25, 26, 5, 6, 9, 10, 21, 22, 25, 26] }, { type: "Buffer", data: [9, 10, 5, 6, 25, 26, 21, 22, 9, 10, 5, 6, 25, 26, 21, 22] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 5, 6, 5, 6, 21, 22, 21, 22] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 1, 1, 5, 6, 1, 1, 21, 22] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 5, 6, 1, 1, 21, 22, 1, 1] }, { type: "Buffer", data: [9, 10, 5, 6, 25, 26, 21, 22, 9, 10, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [5, 6, 9, 10, 21, 22, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 5, 6, 25, 26, 21, 22] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 5, 6, 9, 10, 21, 22, 25, 26] }, { type: "Buffer", data: [1, 1, 5, 6, 1, 1, 21, 22, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 1, 1, 5, 6, 1, 1, 21, 22] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 5, 6, 1, 1, 21, 22, 1, 1] }, { type: "Buffer", data: [1, 1, 5, 6, 1, 1, 21, 22, 5, 6, 1, 1, 21, 22, 1, 1] }, { type: "Buffer", data: [5, 6, 1, 1, 21, 22, 1, 1, 1, 1, 5, 6, 1, 1, 21, 22] }, { type: "Buffer", data: [5, 6, 1, 1, 21, 22, 1, 1, 5, 6, 5, 6, 21, 22, 21, 22] }, { type: "Buffer", data: [1, 1, 5, 6, 1, 1, 21, 22, 5, 6, 5, 6, 21, 22, 21, 22] }, { type: "Buffer", data: [5, 6, 5, 6, 21, 22, 21, 22, 5, 6, 1, 1, 21, 22, 1, 1] }, { type: "Buffer", data: [5, 6, 5, 6, 21, 22, 21, 22, 1, 1, 5, 6, 1, 1, 21, 22] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 16, 16, 5, 6, 1, 1, 21, 22] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 39, 47, 9, 10, 55, 63, 25, 26, 61, 62] }, { type: "Buffer", data: [1, 1, 9, 10, 39, 47, 25, 26, 55, 63, 9, 10, 61, 62, 25, 26] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 8, 0, 32, 0, 128, 2, 128, 8, 32, 32, 8, 128, 2, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 0, 0, 0, 0, 0, 63, 0, 48, 255, 240, 192, 48, 192, 48, 192, 178, 15, 255, 12, 3, 252, 3, 12, 3, 12, 3, 44, 3, 172, 3, 172, 3, 0, 0, 0, 255, 3, 34, 3, 136, 3, 85, 3, 106, 3, 101, 63, 106, 0, 0, 255, 0, 34, 192, 136, 192, 85, 192, 169, 192, 89, 192, 169, 252, 170, 170, 255, 255, 234, 170, 234, 170, 255, 255, 229, 102, 223, 255, 222, 102, 170, 170, 255, 255, 170, 171, 170, 171, 255, 255, 85, 87, 255, 247, 85, 119, 255, 255, 234, 170, 229, 85, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 255, 255, 170, 171, 85, 91, 0, 27, 0, 27, 0, 27, 0, 27, 0, 27, 255, 255, 255, 255, 255, 255, 255, 255, 192, 63, 192, 63, 192, 58, 192, 58, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 175, 255, 175, 255, 255, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 3, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 255, 255, 0, 0, 170, 170, 255, 255, 255, 255, 170, 170, 170, 170, 255, 255, 102, 136, 153, 34, 102, 136, 153, 34, 136, 102, 34, 153, 136, 102, 34, 153, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 170, 170, 170, 85, 85, 255, 255, 85, 85, 255, 255, 255, 255, 255, 255, 194, 186, 202, 186, 234, 186, 234, 191, 234, 181, 255, 245, 213, 85, 213, 85, 172, 3, 175, 255, 173, 87, 253, 87, 85, 87, 85, 87, 85, 87, 85, 87, 51, 102, 59, 106, 51, 85, 59, 255, 58, 170, 53, 85, 53, 85, 63, 255, 89, 204, 169, 236, 85, 204, 255, 236, 170, 172, 85, 92, 85, 92, 255, 252, 221, 153, 221, 101, 223, 255, 221, 102, 221, 153, 223, 255, 213, 85, 255, 255, 149, 119, 85, 119, 255, 247, 153, 119, 85, 119, 255, 247, 85, 87, 255, 255, 228, 0, 229, 85, 234, 170, 255, 255, 229, 85, 229, 85, 229, 85, 255, 255, 0, 27, 85, 91, 170, 171, 255, 255, 85, 91, 85, 91, 85, 91, 255, 255, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 255, 255, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 255, 255, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 221, 221, 119, 119, 221, 221, 119, 119, 221, 221, 119, 119, 221, 221, 119, 119, 255, 255, 170, 170, 170, 170, 85, 85, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 202, 170, 202, 170, 213, 85, 255, 255, 215, 0, 215, 0, 215, 0, 0, 0, 21, 84, 16, 4, 16, 4, 16, 4, 16, 4, 21, 84, 0, 0, 255, 255, 170, 167, 170, 167, 85, 87, 255, 255, 0, 215, 0, 215, 0, 215, 0, 63, 0, 58, 0, 58, 0, 58, 0, 58, 0, 58, 0, 58, 0, 58, 254, 170, 174, 170, 174, 170, 174, 170, 174, 170, 174, 170, 174, 170, 174, 170, 200, 62, 194, 167, 0, 42, 128, 90, 103, 119, 157, 223, 247, 126, 191, 234, 0, 3, 15, 60, 58, 220, 14, 87, 3, 117, 13, 77, 61, 85, 195, 244, 255, 255, 202, 170, 202, 170, 255, 255, 213, 85, 213, 255, 255, 128, 249, 170, 255, 255, 170, 163, 170, 163, 255, 255, 85, 87, 255, 87, 2, 255, 170, 111, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 170, 170, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 255, 192, 0, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 234, 170, 255, 255, 0, 3, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 170, 163, 192, 0, 60, 240, 55, 108, 213, 176, 93, 192, 113, 112, 85, 124, 159, 195, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 85, 85, 255, 255, 215, 0, 215, 0, 215, 0, 215, 0, 215, 255, 255, 255, 213, 229, 255, 255, 136, 136, 34, 34, 137, 152, 17, 17, 152, 137, 34, 34, 136, 136, 34, 34, 0, 215, 0, 215, 0, 215, 0, 215, 255, 215, 255, 255, 91, 87, 255, 255, 255, 255, 2, 167, 0, 167, 0, 39, 255, 255, 170, 167, 170, 167, 170, 167, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 213, 8, 213, 80, 221, 223, 191, 119, 151, 223, 169, 126, 170, 151, 170, 170, 201, 207, 55, 112, 15, 95, 55, 64, 231, 192, 237, 240, 236, 79, 235, 245, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 255, 255, 85, 85, 170, 170, 85, 85, 85, 85, 170, 170, 85, 85, 255, 255, 255, 255, 229, 85, 234, 170, 229, 85, 229, 85, 234, 170, 229, 85, 255, 255, 255, 255, 85, 91, 170, 171, 85, 91, 85, 91, 170, 171, 85, 91, 255, 255, 255, 255, 202, 170, 203, 255, 203, 0, 203, 0, 203, 255, 122, 170, 95, 255, 255, 255, 170, 151, 255, 215, 0, 215, 0, 215, 255, 215, 170, 157, 255, 245, 243, 75, 13, 220, 245, 240, 1, 220, 3, 219, 15, 123, 241, 59, 95, 235, 170, 170, 170, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 0, 0, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 146, 41, 104, 134, 146, 41, 104, 134, 146, 41, 104, 134, 146, 41, 104, 134, 255, 255, 192, 0, 192, 0, 192, 0, 255, 255, 234, 170, 234, 170, 234, 170, 255, 255, 213, 85, 63, 255, 53, 117, 50, 191, 50, 186, 63, 250, 0, 0, 255, 255, 85, 85, 255, 255, 85, 85, 255, 255, 170, 170, 170, 170, 0, 0, 255, 255, 85, 87, 255, 252, 93, 92, 254, 172, 174, 172, 175, 252, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 202, 170, 202, 170, 255, 255, 213, 85, 213, 85, 213, 85, 255, 255, 255, 255, 170, 163, 170, 163, 255, 255, 85, 87, 85, 87, 85, 87, 255, 255, 213, 85, 223, 255, 223, 95, 221, 247, 221, 247, 223, 95, 223, 255, 213, 85, 85, 87, 255, 247, 245, 247, 223, 119, 223, 119, 245, 247, 255, 247, 85, 87, 255, 255, 213, 85, 213, 85, 213, 85, 213, 85, 213, 85, 221, 213, 255, 255, 255, 255, 85, 87, 85, 87, 85, 87, 85, 87, 85, 87, 87, 119, 255, 255, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 230, 103, 49, 116, 135, 209, 103, 230, 27, 181, 110, 245, 95, 159, 254, 171, 255, 255, 85, 85, 255, 255, 174, 186, 172, 58, 87, 213, 0, 0, 255, 255, 255, 255, 213, 87, 255, 255, 222, 183, 220, 55, 215, 215, 192, 3, 255, 255, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 171, 234, 172, 58, 186, 175, 187, 236, 188, 60, 172, 3, 176, 2, 176, 2, 190, 170, 195, 234, 204, 122, 50, 122, 2, 122, 200, 218, 63, 214, 48, 54, 0, 2, 0, 8, 0, 32, 0, 128, 2, 128, 10, 96, 155, 250, 253, 95, 255, 255, 192, 3, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 255, 255, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 170, 170, 85, 85, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 192, 3, 255, 255, 85, 85, 170, 170, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 255, 255, 255, 255, 234, 170, 234, 170, 234, 170, 255, 255, 192, 0, 192, 0, 192, 0, 255, 255, 170, 167, 170, 167, 170, 167, 255, 255, 42, 167, 10, 167, 2, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, club: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [15, 31, 15, 31, 31, 15, 31, 15, 10, 10, 10, 10, 26, 26, 26, 26] }, { type: "Buffer", data: [3, 6, 6, 6, 19, 6, 7, 8, 15, 31, 7, 8, 31, 15, 7, 8] }, { type: "Buffer", data: [6, 6, 6, 6, 6, 6, 6, 6, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [6, 1, 2, 3, 6, 17, 18, 19, 11, 12, 14, 31, 27, 28, 9, 15] }, { type: "Buffer", data: [6, 6, 1, 2, 6, 6, 17, 18, 15, 11, 12, 14, 30, 27, 28, 9] }, { type: "Buffer", data: [15, 31, 7, 8, 31, 15, 7, 8, 15, 31, 7, 8, 31, 15, 23, 24] }, { type: "Buffer", data: [15, 31, 15, 31, 31, 15, 31, 15, 54, 16, 16, 5, 23, 24, 23, 24] }, { type: "Buffer", data: [15, 11, 12, 14, 30, 27, 28, 9, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [29, 13, 15, 31, 21, 22, 31, 15, 15, 31, 29, 13, 31, 15, 21, 22] }, { type: "Buffer", data: [15, 31, 15, 31, 31, 15, 31, 15, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [15, 11, 12, 14, 30, 27, 28, 9, 15, 11, 12, 14, 30, 27, 28, 9] }, { type: "Buffer", data: [32, 33, 15, 31, 34, 35, 31, 15, 36, 37, 15, 31, 38, 39, 31, 15] }, { type: "Buffer", data: [15, 31, 32, 33, 31, 15, 34, 35, 15, 31, 36, 37, 31, 15, 38, 39] }, { type: "Buffer", data: [25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25] }, { type: "Buffer", data: [15, 31, 15, 31, 31, 15, 31, 15, 25, 25, 25, 25, 25, 25, 25, 25] }, { type: "Buffer", data: [15, 31, 15, 41, 31, 15, 41, 41, 15, 41, 41, 15, 41, 41, 15, 15] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 15, 15, 15, 15, 15, 64, 65, 15] }, { type: "Buffer", data: [40, 15, 15, 31, 40, 40, 31, 15, 15, 40, 40, 31, 15, 15, 40, 40] }, { type: "Buffer", data: [6, 48, 49, 6, 6, 50, 51, 6, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [46, 46, 42, 43, 46, 46, 38, 39, 40, 40, 15, 15, 31, 40, 40, 15] }, { type: "Buffer", data: [59, 60, 61, 62, 55, 56, 57, 58, 15, 15, 15, 15, 15, 15, 15, 15] }, { type: "Buffer", data: [42, 43, 47, 47, 38, 39, 47, 47, 15, 15, 41, 41, 15, 41, 41, 15] }, { type: "Buffer", data: [6, 6, 52, 52, 6, 6, 52, 52, 15, 31, 53, 53, 31, 15, 31, 15] }, { type: "Buffer", data: [15, 31, 40, 40, 31, 15, 31, 40, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [45, 45, 45, 45, 45, 45, 45, 45, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [41, 41, 15, 31, 41, 15, 31, 15, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [52, 52, 6, 6, 52, 52, 6, 6, 53, 53, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [71, 72, 73, 74, 23, 24, 23, 24, 15, 15, 15, 15, 15, 15, 15, 15] }, { type: "Buffer", data: [41, 44, 44, 40, 44, 44, 44, 44, 15, 15, 15, 15, 31, 15, 15, 31] }, { type: "Buffer", data: [63, 68, 68, 69, 66, 67, 67, 70, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 15, 15, 15, 15, 15, 15, 15, 15] }, { type: "Buffer", data: [15, 31, 15, 41, 31, 15, 31, 40, 15, 31, 15, 31, 31, 15, 31, 15] }, { type: "Buffer", data: [41, 46, 42, 43, 40, 46, 38, 39, 40, 40, 15, 15, 31, 40, 40, 15] }, { type: "Buffer", data: [42, 43, 47, 40, 38, 39, 47, 41, 15, 15, 41, 41, 15, 41, 41, 15] }, { type: "Buffer", data: [40, 31, 15, 31, 41, 15, 31, 15, 15, 31, 15, 31, 31, 15, 31, 15] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 175, 254, 173, 87, 93, 87, 175, 255, 172, 139, 174, 35, 92, 139, 189, 170, 215, 170, 253, 170, 195, 85, 253, 254, 171, 43, 255, 215, 3, 254, 170, 170, 170, 170, 170, 170, 85, 85, 170, 170, 170, 170, 170, 170, 95, 213, 136, 136, 47, 255, 142, 170, 44, 0, 140, 240, 44, 51, 140, 0, 47, 255, 255, 254, 0, 3, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 170, 170, 170, 170, 170, 85, 85, 170, 170, 170, 170, 170, 170, 85, 85, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 213, 92, 95, 212, 112, 55, 208, 31, 215, 95, 250, 189, 255, 252, 159, 208, 0, 0, 85, 85, 102, 102, 0, 0, 102, 102, 153, 153, 102, 102, 153, 153, 0, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 15, 0, 7, 7, 255, 208, 0, 48, 0, 112, 0, 192, 252, 243, 43, 191, 107, 205, 215, 207, 252, 3, 240, 3, 12, 15, 12, 15, 12, 247, 12, 119, 12, 119, 12, 247, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 191, 47, 127, 255, 252, 15, 240, 3, 244, 199, 125, 95, 191, 255, 87, 245, 252, 58, 107, 250, 236, 7, 220, 199, 236, 199, 107, 250, 170, 234, 87, 245, 255, 254, 255, 253, 240, 63, 192, 15, 211, 31, 245, 125, 255, 254, 95, 213, 0, 0, 255, 192, 170, 192, 0, 192, 48, 213, 60, 212, 0, 208, 255, 192, 13, 123, 13, 122, 13, 207, 15, 181, 15, 255, 14, 170, 14, 170, 15, 255, 247, 12, 247, 108, 119, 172, 126, 176, 255, 192, 173, 64, 173, 64, 253, 64, 255, 255, 192, 0, 255, 255, 229, 85, 229, 85, 229, 85, 229, 85, 255, 255, 255, 255, 0, 3, 255, 255, 85, 91, 85, 91, 85, 91, 85, 91, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 102, 102, 153, 153, 102, 102, 153, 153, 0, 0, 153, 153, 85, 85, 0, 0, 57, 95, 23, 253, 220, 13, 244, 55, 245, 215, 126, 175, 63, 255, 7, 246, 60, 48, 3, 252, 204, 3, 206, 239, 206, 239, 67, 241, 1, 208, 171, 250, 0, 0, 0, 0, 0, 0, 0, 0, 15, 255, 13, 85, 13, 95, 15, 240, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 3, 255, 12, 0, 12, 0, 12, 0, 14, 170, 14, 255, 14, 199, 254, 255, 255, 192, 0, 48, 0, 48, 0, 48, 170, 176, 255, 176, 255, 176, 255, 191, 206, 255, 206, 255, 206, 170, 205, 85, 206, 170, 205, 85, 223, 255, 244, 68, 255, 183, 255, 191, 170, 183, 255, 127, 170, 183, 85, 119, 255, 247, 68, 31, 246, 85, 244, 68, 222, 170, 223, 255, 55, 95, 15, 240, 3, 10, 12, 170, 85, 31, 1, 31, 170, 183, 255, 247, 245, 221, 15, 240, 160, 192, 170, 48, 12, 170, 12, 170, 13, 10, 3, 80, 0, 245, 0, 223, 0, 202, 0, 63, 170, 48, 170, 48, 160, 112, 5, 192, 95, 0, 247, 0, 163, 0, 252, 0, 80, 0, 84, 0, 21, 0, 5, 64, 1, 80, 0, 84, 0, 21, 0, 5, 0, 5, 0, 21, 0, 84, 1, 80, 5, 64, 21, 0, 84, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 240, 3, 10, 12, 170, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 15, 0, 160, 192, 170, 48, 85, 85, 85, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 85, 85, 80, 0, 80, 0, 80, 0, 80, 0, 80, 0, 80, 0, 80, 0, 80, 0, 0, 5, 0, 5, 0, 5, 0, 5, 0, 5, 0, 5, 0, 5, 0, 5, 85, 85, 0, 0, 63, 252, 48, 12, 48, 12, 48, 4, 63, 127, 51, 112, 85, 85, 0, 0, 192, 0, 251, 176, 192, 8, 0, 12, 252, 200, 12, 240, 63, 112, 63, 112, 0, 63, 0, 51, 0, 63, 0, 63, 0, 0, 85, 85, 12, 192, 12, 0, 252, 0, 252, 0, 252, 0, 248, 0, 0, 0, 85, 85, 208, 7, 208, 7, 208, 7, 208, 7, 208, 7, 208, 7, 208, 7, 208, 7, 48, 12, 15, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 212, 7, 197, 85, 207, 255, 250, 170, 229, 85, 191, 255, 102, 103, 153, 155, 229, 87, 213, 87, 149, 87, 85, 87, 85, 87, 255, 255, 85, 85, 255, 255, 213, 91, 213, 87, 213, 86, 213, 85, 213, 85, 255, 255, 85, 85, 255, 255, 208, 23, 85, 83, 255, 243, 170, 175, 85, 91, 255, 254, 217, 153, 230, 102, 143, 255, 52, 71, 197, 95, 212, 79, 197, 95, 196, 79, 197, 95, 196, 15, 195, 44, 64, 235, 3, 215, 3, 87, 13, 87, 13, 87, 57, 87, 53, 87, 56, 195, 235, 1, 215, 192, 213, 192, 213, 112, 213, 112, 213, 108, 213, 92, 255, 248, 209, 30, 245, 83, 241, 23, 245, 83, 241, 19, 245, 83, 240, 19, 191, 255, 176, 0, 185, 85, 113, 85, 177, 85, 177, 85, 177, 85, 113, 85, 0, 255, 3, 207, 15, 44, 15, 43, 63, 43, 55, 43, 243, 43, 211, 47, 255, 0, 243, 192, 56, 240, 232, 240, 232, 252, 232, 220, 232, 207, 248, 199, 177, 85, 177, 85, 177, 85, 113, 85, 177, 85, 176, 0, 191, 255, 85, 85, 74, 168, 64, 0, 64, 0, 85, 85, 85, 85, 0, 0, 255, 255, 85, 85, 255, 255, 0, 0, 85, 85, 85, 85, 64, 0, 68, 0, 68, 68, 64, 0, 255, 254, 0, 14, 85, 110, 85, 77, 85, 78, 85, 78, 85, 78, 85, 77, 85, 78, 85, 78, 85, 78, 85, 77, 85, 78, 0, 14, 255, 254, 85, 85, 191, 255, 194, 255, 203, 17, 203, 85, 203, 17, 203, 255, 201, 255, 202, 85, 255, 255, 240, 0, 14, 170, 14, 170, 14, 170, 254, 170, 246, 170, 90, 170, 255, 255, 0, 15, 170, 176, 170, 176, 170, 176, 170, 191, 170, 159, 170, 165, 255, 254, 255, 131, 68, 231, 85, 231, 68, 231, 255, 231, 255, 103, 85, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, facility: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [1, 1, 32, 48, 1, 1, 32, 48, 33, 49, 1, 1, 33, 49, 1, 1] }, { type: "Buffer", data: [1, 1, 49, 49, 1, 1, 48, 48, 49, 49, 1, 1, 48, 48, 1, 1] }, { type: "Buffer", data: [1, 1, 34, 34, 1, 1, 82, 82, 1, 1, 82, 82, 1, 1, 34, 34] }, { type: "Buffer", data: [34, 34, 1, 1, 82, 82, 1, 1, 82, 82, 1, 1, 34, 34, 1, 1] }, { type: "Buffer", data: [83, 84, 83, 84, 54, 38, 54, 38, 83, 84, 83, 84, 54, 38, 54, 38] }, { type: "Buffer", data: [83, 84, 83, 84, 54, 38, 54, 38, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [66, 82, 82, 66, 66, 82, 82, 66, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 5, 6, 1, 1, 21, 22, 1, 1, 7, 15, 1, 1, 23, 31] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [5, 6, 5, 6, 21, 22, 21, 22, 7, 15, 7, 15, 23, 31, 23, 31] }, { type: "Buffer", data: [5, 6, 45, 46, 21, 22, 43, 44, 7, 15, 43, 44, 23, 31, 43, 44] }, { type: "Buffer", data: [5, 6, 1, 1, 21, 22, 1, 1, 7, 15, 1, 1, 23, 31, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 33, 33, 1, 1, 32, 32, 1, 1, 33, 33, 1, 1, 32, 32] }, { type: "Buffer", data: [42, 42, 42, 42, 58, 58, 58, 58, 13, 14, 1, 1, 29, 30, 1, 1] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [43, 44, 5, 6, 43, 44, 21, 22, 43, 44, 7, 15, 43, 44, 23, 31] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 94, 94, 1, 1, 94, 94, 1, 1] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 1, 1, 33, 49, 1, 1, 33, 49] }, { type: "Buffer", data: [94, 94, 9, 10, 94, 94, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [9, 10, 43, 44, 25, 26, 43, 44, 9, 10, 43, 44, 25, 26, 43, 44] }, { type: "Buffer", data: [33, 49, 9, 10, 33, 49, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 33, 33, 1, 1, 32, 32, 1, 1] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [64, 64, 64, 64, 80, 80, 80, 80, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 11, 12, 1, 1, 27, 28, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 18, 18, 18, 18] }, { type: "Buffer", data: [29, 30, 1, 1, 29, 30, 1, 1, 29, 30, 1, 1, 18, 18, 1, 1] }, { type: "Buffer", data: [11, 12, 87, 87, 27, 28, 89, 89, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [29, 30, 1, 1, 29, 30, 1, 1, 29, 30, 1, 1, 29, 30, 1, 1] }, { type: "Buffer", data: [1, 1, 9, 10, 1, 1, 25, 26, 49, 49, 1, 1, 48, 48, 1, 1] }, { type: "Buffer", data: [1, 1, 49, 49, 1, 1, 48, 48, 33, 49, 1, 1, 33, 49, 1, 1] }, { type: "Buffer", data: [13, 14, 13, 14, 76, 77, 76, 77, 42, 42, 42, 42, 58, 58, 58, 58] }, { type: "Buffer", data: [1, 1, 94, 94, 1, 1, 94, 94, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [42, 46, 1, 1, 58, 60, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 45, 42, 1, 1, 59, 58, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 66, 82, 82, 66, 66, 82, 82, 66] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 24, 24, 24, 24] }, { type: "Buffer", data: [51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 33, 49, 1, 1, 32, 48] }, { type: "Buffer", data: [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50] }, { type: "Buffer", data: [1, 1, 83, 84, 1, 1, 54, 38, 1, 1, 83, 84, 1, 1, 54, 38] }, { type: "Buffer", data: [3, 4, 1, 1, 19, 78, 1, 1, 3, 4, 1, 1, 19, 78, 1, 1] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 42, 42, 42, 42, 58, 58, 58, 58] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 13, 2, 2, 14, 29, 53, 53, 30] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [29, 53, 53, 30, 29, 53, 53, 30, 29, 53, 53, 30, 29, 53, 53, 30] }, { type: "Buffer", data: [29, 53, 53, 30, 68, 69, 69, 68, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [83, 84, 1, 1, 54, 38, 1, 1, 83, 84, 1, 1, 54, 38, 1, 1] }, { type: "Buffer", data: [9, 10, 1, 1, 25, 26, 1, 1, 9, 10, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [66, 82, 3, 4, 66, 82, 19, 78, 66, 82, 82, 82, 66, 82, 82, 82] }, { type: "Buffer", data: [82, 82, 82, 66, 82, 82, 82, 66, 82, 82, 82, 66, 82, 82, 82, 66] }, { type: "Buffer", data: [45, 46, 87, 87, 43, 44, 89, 89, 43, 44, 1, 1, 43, 44, 1, 1] }, { type: "Buffer", data: [87, 87, 87, 87, 89, 89, 89, 89, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [87, 87, 45, 46, 89, 89, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44] }, { type: "Buffer", data: [66, 82, 82, 82, 66, 82, 82, 82, 66, 82, 82, 82, 66, 82, 82, 82] }, { type: "Buffer", data: [45, 42, 42, 42, 43, 44, 58, 58, 43, 44, 1, 1, 43, 44, 1, 1] }, { type: "Buffer", data: [42, 42, 42, 42, 58, 58, 58, 58, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [42, 42, 42, 46, 58, 58, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44] }, { type: "Buffer", data: [40, 41, 1, 1, 56, 57, 1, 1, 56, 57, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 39, 47, 1, 1, 55, 63, 1, 1, 61, 62] }, { type: "Buffer", data: [1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44] }, { type: "Buffer", data: [13, 2, 2, 14, 29, 53, 53, 30, 29, 53, 53, 30, 68, 69, 69, 68] }, { type: "Buffer", data: [43, 44, 1, 1, 43, 44, 1, 1, 45, 42, 42, 42, 59, 58, 58, 58] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 42, 42, 42, 42, 58, 58, 58, 58] }, { type: "Buffer", data: [1, 1, 43, 44, 1, 1, 43, 44, 42, 42, 42, 46, 58, 58, 58, 60] }, { type: "Buffer", data: [42, 42, 71, 95, 58, 58, 92, 93, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [50, 50, 50, 50, 50, 50, 50, 50, 42, 42, 42, 42, 58, 58, 58, 58] }, { type: "Buffer", data: [49, 49, 1, 1, 48, 48, 1, 1, 1, 1, 32, 48, 1, 1, 32, 48] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 12, 1, 1, 27, 28] }, { type: "Buffer", data: [64, 64, 43, 44, 80, 80, 59, 60, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 42, 42, 43, 44, 58, 58] }, { type: "Buffer", data: [1, 1, 43, 44, 1, 1, 43, 44, 42, 42, 43, 44, 58, 58, 43, 44] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 45, 46, 1, 1, 43, 44, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 45, 46, 1, 1, 43, 44] }, { type: "Buffer", data: [8, 8, 8, 8, 24, 24, 24, 24, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 59, 60, 1, 1] }, { type: "Buffer", data: [1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 59, 60] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 45, 42, 42, 42, 59, 58, 58, 58] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 42, 42, 42, 46, 58, 58, 58, 60] }, { type: "Buffer", data: [45, 46, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1] }, { type: "Buffer", data: [1, 1, 45, 46, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 43, 44] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [43, 44, 83, 84, 43, 44, 54, 38, 43, 44, 83, 84, 43, 44, 54, 38] }, { type: "Buffer", data: [83, 84, 43, 44, 54, 38, 43, 44, 83, 84, 43, 44, 54, 38, 43, 44] }, { type: "Buffer", data: [1, 1, 39, 47, 1, 1, 55, 63, 1, 1, 74, 75, 1, 1, 76, 77] }, { type: "Buffer", data: [1, 1, 36, 37, 1, 1, 36, 37, 1, 1, 36, 37, 1, 1, 36, 37] }, { type: "Buffer", data: [45, 42, 42, 42, 43, 44, 13, 14, 43, 44, 13, 14, 43, 44, 29, 30] }, { type: "Buffer", data: [42, 42, 42, 42, 13, 14, 13, 14, 74, 75, 74, 75, 76, 77, 76, 77] }, { type: "Buffer", data: [42, 42, 42, 46, 13, 14, 43, 44, 13, 14, 43, 44, 29, 30, 43, 44] }, { type: "Buffer", data: [42, 42, 42, 46, 58, 58, 58, 60, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [43, 44, 13, 14, 43, 44, 29, 30, 43, 44, 74, 75, 43, 44, 76, 77] }, { type: "Buffer", data: [42, 42, 42, 42, 58, 58, 58, 58, 83, 84, 83, 84, 54, 38, 54, 38] }, { type: "Buffer", data: [13, 14, 43, 44, 29, 30, 43, 44, 74, 75, 43, 44, 76, 77, 43, 44] }, { type: "Buffer", data: [45, 42, 42, 42, 59, 58, 58, 58, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [45, 42, 42, 42, 43, 44, 58, 58, 43, 44, 83, 84, 43, 44, 54, 38] }, { type: "Buffer", data: [42, 42, 42, 46, 58, 58, 43, 44, 83, 84, 43, 44, 54, 38, 43, 44] }, { type: "Buffer", data: [42, 42, 42, 42, 58, 58, 58, 58, 3, 4, 1, 1, 19, 78, 1, 1] }, { type: "Buffer", data: [43, 44, 42, 42, 43, 44, 13, 14, 43, 44, 74, 75, 43, 44, 76, 77] }, { type: "Buffer", data: [65, 17, 17, 17, 65, 17, 17, 17, 65, 17, 17, 17, 65, 17, 17, 17] }, { type: "Buffer", data: [65, 17, 17, 17, 81, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [1, 1, 3, 4, 1, 1, 19, 78, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 11, 12, 1, 1, 27, 28, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [43, 44, 1, 1, 59, 60, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 43, 44, 1, 1, 59, 60, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 45, 42, 42, 46, 59, 58, 58, 60] }, { type: "Buffer", data: [42, 42, 42, 42, 58, 58, 58, 58, 11, 12, 1, 1, 27, 28, 1, 1] }, { type: "Buffer", data: [45, 46, 1, 1, 43, 44, 1, 1, 43, 44, 1, 1, 59, 60, 1, 1] }, { type: "Buffer", data: [79, 79, 79, 79, 79, 20, 20, 20, 79, 20, 20, 20, 79, 20, 20, 20] }, { type: "Buffer", data: [79, 79, 79, 79, 20, 20, 20, 79, 20, 20, 20, 79, 20, 20, 20, 79] }, { type: "Buffer", data: [1, 1, 1, 1, 39, 47, 1, 1, 55, 63, 1, 1, 61, 62, 1, 1] }, { type: "Buffer", data: [35, 70, 1, 1, 72, 73, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [43, 44, 9, 10, 43, 44, 25, 26, 43, 44, 1, 1, 43, 44, 1, 1] }, { type: "Buffer", data: [42, 42, 42, 42, 58, 58, 58, 58, 9, 10, 1, 1, 25, 26, 1, 1] }, { type: "Buffer", data: [13, 2, 2, 14, 29, 53, 53, 30, 29, 53, 53, 30, 29, 53, 53, 30] }, { type: "Buffer", data: [86, 86, 87, 87, 88, 88, 89, 89, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [90, 91, 87, 87, 67, 52, 89, 89, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [43, 44, 1, 1, 43, 44, 1, 1, 43, 44, 2, 2, 43, 44, 18, 18] }, { type: "Buffer", data: [87, 87, 87, 87, 13, 14, 89, 89, 29, 30, 1, 1, 29, 30, 1, 1] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 0, 170, 0, 170, 0, 170, 0, 0, 170, 0, 170, 0, 170, 0, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 0, 0, 0, 0, 0, 63, 0, 48, 255, 240, 192, 48, 192, 48, 192, 178, 15, 255, 12, 3, 252, 3, 12, 3, 12, 3, 44, 3, 172, 3, 172, 3, 140, 136, 59, 226, 190, 188, 233, 187, 189, 91, 230, 85, 189, 127, 255, 235, 136, 184, 35, 238, 190, 159, 238, 87, 101, 125, 215, 171, 250, 124, 215, 226, 136, 139, 34, 32, 136, 141, 34, 254, 139, 116, 32, 249, 142, 244, 46, 253, 0, 2, 0, 8, 255, 255, 234, 171, 234, 171, 255, 255, 213, 87, 255, 255, 255, 255, 234, 170, 229, 85, 228, 0, 228, 0, 228, 0, 228, 0, 228, 0, 255, 255, 170, 171, 85, 91, 0, 27, 0, 27, 0, 27, 0, 27, 0, 27, 255, 255, 255, 255, 255, 255, 255, 255, 192, 63, 192, 63, 192, 58, 192, 58, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 175, 255, 175, 255, 255, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 3, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 120, 136, 178, 34, 120, 136, 191, 34, 157, 200, 111, 34, 159, 184, 127, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 170, 170, 170, 85, 85, 255, 255, 85, 85, 255, 255, 255, 255, 255, 255, 194, 186, 202, 186, 234, 186, 234, 191, 234, 181, 255, 245, 213, 85, 213, 85, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 190, 150, 231, 86, 186, 110, 233, 103, 249, 223, 235, 239, 187, 187, 46, 35, 182, 190, 85, 235, 217, 93, 217, 155, 247, 159, 251, 235, 254, 238, 62, 190, 141, 191, 45, 106, 135, 82, 27, 127, 167, 90, 25, 210, 134, 127, 34, 153, 213, 87, 213, 87, 213, 87, 255, 255, 213, 87, 255, 255, 32, 8, 128, 2, 228, 0, 229, 85, 234, 170, 255, 255, 229, 85, 229, 85, 229, 85, 255, 255, 0, 27, 85, 91, 170, 171, 255, 255, 85, 91, 85, 91, 85, 91, 255, 255, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 255, 255, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 255, 255, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 254, 120, 169, 114, 85, 232, 253, 218, 85, 228, 87, 154, 254, 104, 153, 34, 129, 80, 128, 84, 128, 21, 128, 5, 128, 1, 128, 0, 128, 0, 170, 170, 170, 170, 128, 0, 128, 0, 128, 1, 128, 5, 128, 21, 128, 84, 129, 80, 153, 153, 102, 102, 34, 34, 136, 136, 34, 34, 136, 136, 153, 153, 102, 102, 170, 0, 170, 240, 175, 255, 173, 85, 61, 255, 61, 244, 13, 210, 13, 200, 0, 63, 0, 54, 0, 54, 0, 54, 0, 54, 0, 54, 0, 54, 0, 54, 254, 170, 158, 170, 158, 170, 158, 170, 158, 170, 158, 170, 158, 170, 158, 170, 200, 62, 194, 167, 0, 42, 128, 90, 103, 119, 157, 223, 247, 126, 191, 234, 0, 3, 15, 60, 58, 220, 14, 87, 3, 117, 13, 77, 61, 85, 195, 244, 255, 255, 202, 170, 202, 170, 255, 255, 213, 85, 213, 255, 255, 128, 249, 170, 255, 255, 170, 163, 170, 163, 255, 255, 85, 87, 255, 87, 2, 255, 170, 111, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 170, 170, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 255, 192, 0, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 234, 170, 255, 255, 0, 3, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 170, 163, 192, 0, 60, 240, 55, 108, 213, 176, 93, 192, 113, 112, 85, 124, 159, 195, 5, 66, 21, 2, 84, 2, 80, 2, 64, 2, 0, 2, 0, 2, 170, 170, 170, 170, 0, 2, 0, 2, 64, 2, 80, 2, 84, 2, 21, 2, 5, 66, 136, 136, 34, 34, 137, 152, 17, 17, 152, 137, 34, 34, 136, 136, 34, 34, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 2, 167, 0, 167, 0, 39, 255, 255, 170, 167, 170, 167, 170, 167, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 213, 8, 213, 80, 221, 223, 191, 119, 151, 223, 169, 126, 170, 151, 170, 170, 201, 207, 55, 112, 15, 95, 55, 64, 231, 192, 237, 240, 236, 79, 235, 245, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 255, 255, 85, 85, 170, 170, 85, 85, 85, 85, 170, 170, 85, 85, 255, 255, 255, 255, 229, 85, 234, 170, 229, 85, 229, 85, 234, 170, 229, 85, 255, 255, 255, 255, 85, 91, 170, 171, 85, 91, 85, 91, 170, 171, 85, 91, 255, 255, 255, 255, 202, 170, 203, 255, 203, 0, 203, 0, 203, 255, 122, 170, 95, 255, 255, 255, 170, 151, 255, 215, 0, 215, 0, 215, 255, 215, 170, 157, 255, 245, 243, 75, 13, 220, 245, 240, 1, 220, 3, 219, 15, 123, 241, 59, 95, 235, 170, 170, 170, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 0, 0, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 146, 41, 104, 134, 146, 41, 104, 134, 146, 41, 104, 134, 146, 41, 104, 134, 255, 255, 192, 0, 192, 0, 192, 0, 255, 255, 234, 170, 234, 170, 234, 170, 255, 255, 213, 87, 255, 255, 245, 95, 245, 95, 178, 174, 178, 174, 63, 252, 255, 255, 85, 85, 255, 255, 85, 85, 255, 255, 170, 170, 170, 170, 0, 0, 170, 0, 175, 0, 255, 240, 85, 112, 255, 126, 31, 126, 135, 122, 35, 122, 254, 170, 3, 255, 252, 0, 255, 255, 255, 255, 255, 254, 254, 186, 171, 255, 173, 200, 173, 210, 189, 244, 189, 255, 13, 85, 15, 255, 0, 250, 0, 170, 35, 112, 135, 112, 31, 124, 255, 124, 85, 122, 255, 250, 15, 170, 0, 170, 213, 85, 223, 255, 223, 95, 221, 247, 221, 247, 223, 95, 223, 255, 213, 85, 85, 87, 255, 247, 245, 247, 223, 119, 223, 119, 245, 247, 255, 247, 85, 87, 255, 255, 213, 85, 213, 85, 213, 85, 213, 85, 213, 85, 221, 213, 255, 255, 255, 255, 85, 87, 85, 87, 85, 87, 85, 87, 85, 87, 87, 119, 255, 255, 172, 3, 175, 255, 173, 87, 253, 87, 85, 87, 85, 87, 85, 87, 85, 87, 230, 103, 49, 116, 135, 209, 103, 230, 27, 181, 110, 245, 95, 159, 254, 171, 255, 255, 85, 85, 255, 255, 174, 186, 172, 58, 87, 213, 0, 0, 255, 255, 255, 255, 213, 87, 255, 255, 222, 183, 220, 55, 215, 215, 192, 3, 255, 255, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 171, 234, 172, 58, 186, 175, 187, 236, 188, 60, 172, 3, 176, 2, 176, 2, 190, 170, 195, 234, 204, 122, 50, 122, 2, 122, 200, 218, 63, 214, 48, 54, 170, 0, 170, 0, 170, 0, 170, 0, 0, 170, 10, 106, 155, 250, 255, 255, 255, 255, 192, 3, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 255, 255, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 170, 170, 85, 85, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 192, 3, 255, 255, 85, 85, 170, 170, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 255, 255, 255, 255, 234, 170, 234, 170, 234, 170, 255, 255, 192, 0, 192, 0, 192, 0, 255, 255, 170, 167, 170, 167, 170, 167, 255, 255, 42, 167, 10, 167, 2, 167, 176, 0, 122, 170, 126, 170, 127, 255, 183, 119, 125, 221, 95, 119, 87, 255, 0, 14, 170, 173, 170, 189, 255, 253, 119, 126, 221, 245, 119, 117, 255, 213, 170, 170, 128, 2, 133, 82, 69, 81, 133, 82, 133, 82, 128, 2, 85, 85, 191, 255, 192, 0, 44, 255, 191, 255, 191, 255, 239, 255, 170, 191, 255, 234] } }, forest: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [52, 32, 32, 32, 32, 32, 32, 52, 32, 52, 32, 32, 32, 32, 32, 52] }, { type: "Buffer", data: [4, 5, 6, 7, 35, 21, 22, 23, 36, 37, 38, 39, 0, 53, 54, 48] }, { type: "Buffer", data: [51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [2, 3, 32, 32, 18, 19, 32, 32, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [2, 3, 32, 32, 18, 19, 32, 32, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 32, 32, 18, 19, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 2, 3, 32, 32, 18, 19] }, { type: "Buffer", data: [2, 3, 32, 32, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 2, 3, 32, 32, 18, 19, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 84, 85, 32, 32, 86, 87] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 84, 85, 32, 32, 86, 87, 32, 32] }, { type: "Buffer", data: [32, 32, 84, 85, 32, 32, 86, 87, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [84, 85, 32, 32, 86, 87, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 4, 5, 6, 7, 35, 21, 22, 23] }, { type: "Buffer", data: [48, 48, 2, 3, 48, 48, 18, 19, 33, 34, 2, 3, 49, 50, 18, 19] }, { type: "Buffer", data: [33, 34, 32, 32, 49, 50, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 66, 66, 66, 66, 67, 67, 67, 67] }, { type: "Buffer", data: [36, 37, 38, 39, 0, 53, 54, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [8, 9, 9, 9, 24, 25, 25, 25, 40, 41, 42, 43, 56, 41, 58, 59] }, { type: "Buffer", data: [9, 9, 9, 12, 25, 25, 25, 28, 16, 17, 41, 44, 41, 41, 41, 60] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [9, 9, 9, 12, 25, 25, 25, 28, 1, 1, 41, 44, 41, 41, 41, 60] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [94, 94, 94, 94, 52, 52, 94, 94, 94, 52, 52, 94, 94, 94, 94, 94] }, { type: "Buffer", data: [33, 34, 48, 48, 49, 50, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [32, 32, 48, 48, 32, 32, 48, 48, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [48, 48, 32, 32, 48, 48, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 48, 48, 32, 32, 48, 48] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 48, 48, 32, 32, 48, 48, 32, 32] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 10, 11, 66, 66, 26, 27, 67, 67, 75, 76] }, { type: "Buffer", data: [48, 48, 48, 48, 10, 11, 48, 48, 26, 27, 66, 66, 75, 76, 67, 67] }, { type: "Buffer", data: [94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 55, 48] }, { type: "Buffer", data: [48, 48, 48, 48, 10, 11, 48, 48, 26, 27, 48, 48, 75, 76, 48, 48] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 10, 11, 48, 48, 26, 27, 48, 48, 75, 76] }, { type: "Buffer", data: [48, 48, 48, 48, 57, 95, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 55, 48, 48, 48, 48, 57, 95, 48, 48, 48, 48] }, { type: "Buffer", data: [52, 32, 32, 32, 32, 32, 32, 52, 32, 52, 32, 32, 32, 32, 32, 52] }, { type: "Buffer", data: [32, 32, 77, 20, 32, 32, 72, 20, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 77, 20, 20, 78, 72, 20, 20, 74] }, { type: "Buffer", data: [20, 78, 32, 32, 20, 74, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 33, 34, 48, 48, 49, 50] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 2, 3, 48, 48, 18, 19] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 2, 3, 48, 48, 18, 19, 48, 48] }, { type: "Buffer", data: [2, 3, 48, 48, 18, 19, 48, 48, 2, 3, 48, 48, 18, 19, 48, 48] }, { type: "Buffer", data: [48, 48, 2, 3, 48, 48, 18, 19, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [2, 3, 48, 48, 18, 19, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [48, 48, 2, 3, 48, 48, 18, 19, 48, 48, 2, 3, 48, 48, 18, 19] }, { type: "Buffer", data: [48, 29, 30, 30, 29, 45, 46, 46, 45, 45, 46, 46, 45, 45, 46, 46] }, { type: "Buffer", data: [30, 30, 30, 30, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46] }, { type: "Buffer", data: [30, 30, 31, 48, 46, 46, 47, 31, 46, 46, 47, 47, 46, 46, 47, 47] }, { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 62, 14, 46, 46, 14, 45, 46, 46] }, { type: "Buffer", data: [45, 45, 46, 46, 45, 45, 46, 46, 45, 45, 46, 46, 45, 45, 46, 46] }, { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46] }, { type: "Buffer", data: [46, 46, 47, 47, 46, 46, 47, 47, 46, 46, 47, 47, 46, 46, 47, 47] }, { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 15, 62, 46, 46, 47, 15] }, { type: "Buffer", data: [45, 45, 46, 46, 45, 45, 46, 46, 45, 61, 62, 62, 61, 62, 62, 62] }, { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 62, 62, 62, 62, 62, 62, 62, 62] }, { type: "Buffer", data: [46, 46, 47, 47, 46, 46, 47, 47, 62, 62, 63, 47, 62, 62, 62, 63] }, { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 64, 65, 62, 62, 64, 65, 62, 62] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 2, 3, 48, 48, 18, 19, 48, 48] }, { type: "Buffer", data: [2, 3, 2, 3, 18, 19, 18, 19, 48, 48, 2, 3, 48, 48, 18, 19] }, { type: "Buffer", data: [30, 30, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46] }, { type: "Buffer", data: [46, 46, 30, 30, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46] }, { type: "Buffer", data: [2, 3, 48, 48, 18, 19, 48, 48, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [48, 48, 2, 3, 48, 48, 18, 19, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [30, 30, 31, 48, 46, 46, 47, 31, 33, 34, 47, 47, 49, 50, 47, 47] }, { type: "Buffer", data: [73, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [48, 48, 73, 73, 48, 48, 72, 20, 48, 48, 72, 20, 48, 48, 72, 20] }, { type: "Buffer", data: [73, 73, 73, 73, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [73, 73, 73, 73, 20, 20, 20, 74, 20, 20, 20, 74, 20, 20, 20, 74] }, { type: "Buffer", data: [46, 46, 46, 46, 46, 46, 46, 46, 62, 62, 64, 65, 62, 62, 64, 65] }, { type: "Buffer", data: [48, 48, 72, 20, 48, 48, 72, 20, 48, 48, 72, 20, 48, 48, 72, 20] }, { type: "Buffer", data: [77, 20, 20, 20, 72, 20, 20, 20, 72, 20, 20, 20, 72, 20, 20, 20] }, { type: "Buffer", data: [48, 48, 48, 48, 82, 48, 48, 48, 82, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 83, 48, 48, 48, 83, 48, 48, 48, 48] }, { type: "Buffer", data: [48, 80, 80, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 81, 81, 48] }, { type: "Buffer", data: [72, 20, 20, 20, 72, 20, 20, 20, 72, 20, 20, 20, 72, 20, 20, 20] }, { type: "Buffer", data: [20, 20, 20, 74, 20, 20, 20, 74, 20, 20, 20, 74, 20, 20, 20, 74] }, { type: "Buffer", data: [73, 73, 73, 73, 72, 20, 20, 20, 72, 20, 20, 20, 72, 20, 20, 20] }, { type: "Buffer", data: [20, 20, 20, 78, 20, 20, 20, 74, 20, 20, 20, 74, 20, 20, 20, 74] }, { type: "Buffer", data: [20, 20, 20, 73, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [72, 20, 20, 78, 72, 20, 20, 74, 72, 20, 20, 74, 72, 20, 20, 74] }, { type: "Buffer", data: [73, 20, 20, 74, 20, 20, 20, 74, 20, 20, 20, 74, 20, 20, 20, 74] }, { type: "Buffer", data: [33, 34, 46, 46, 49, 50, 46, 46, 46, 46, 15, 62, 46, 46, 47, 15] }, { type: "Buffer", data: [29, 30, 30, 31, 45, 46, 46, 47, 45, 46, 46, 47, 61, 62, 62, 63] }, { type: "Buffer", data: [68, 69, 68, 69, 70, 71, 70, 71, 68, 69, 68, 69, 70, 71, 70, 71] }, { type: "Buffer", data: [88, 89, 48, 48, 90, 91, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 88, 89, 48, 48, 90, 91, 48, 48] }, { type: "Buffer", data: [13, 79, 48, 48, 92, 93, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 13, 79, 48, 48, 92, 93, 48, 48] }, { type: "Buffer", data: [20, 74, 48, 48, 20, 74, 48, 48, 20, 74, 48, 48, 20, 74, 48, 48] }, { type: "Buffer", data: [20, 78, 48, 48, 20, 74, 48, 48, 20, 74, 48, 48, 20, 74, 48, 48] }, { type: "Buffer", data: [48, 48, 77, 20, 48, 48, 72, 20, 48, 48, 72, 20, 48, 48, 72, 20] }, { type: "Buffer", data: [68, 69, 20, 20, 70, 71, 20, 20, 68, 69, 20, 20, 70, 71, 20, 20] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 68, 69, 68, 69, 70, 71, 70, 71] }, { type: "Buffer", data: [68, 69, 68, 69, 70, 71, 70, 71, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [73, 73, 72, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [20, 73, 73, 72, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [20, 20, 68, 69, 20, 20, 70, 71, 20, 20, 68, 69, 20, 20, 70, 71] }, { type: "Buffer", data: [73, 73, 68, 69, 20, 20, 70, 71, 20, 20, 68, 69, 20, 20, 70, 71] }, { type: "Buffer", data: [72, 20, 20, 20, 72, 20, 20, 20, 68, 69, 68, 69, 70, 71, 70, 71] }, { type: "Buffer", data: [72, 20, 20, 74, 72, 20, 20, 74, 72, 20, 20, 74, 72, 20, 20, 74] }, { type: "Buffer", data: [29, 30, 30, 30, 45, 46, 46, 46, 45, 46, 46, 46, 45, 46, 46, 46] }, { type: "Buffer", data: [30, 31, 20, 20, 46, 47, 20, 20, 46, 47, 20, 20, 46, 47, 20, 20] }, { type: "Buffer", data: [20, 20, 29, 30, 20, 20, 45, 46, 20, 20, 45, 46, 20, 20, 45, 46] }, { type: "Buffer", data: [30, 30, 30, 31, 46, 46, 46, 47, 46, 46, 46, 47, 46, 46, 46, 47] }, { type: "Buffer", data: [45, 46, 46, 46, 45, 46, 46, 46, 45, 46, 46, 46, 61, 62, 62, 62] }, { type: "Buffer", data: [46, 47, 20, 20, 46, 47, 20, 20, 46, 47, 20, 20, 62, 63, 20, 20] }, { type: "Buffer", data: [20, 20, 45, 46, 20, 20, 45, 46, 20, 20, 45, 46, 20, 20, 61, 62] }, { type: "Buffer", data: [46, 46, 46, 47, 46, 46, 46, 47, 46, 46, 46, 47, 62, 62, 62, 63] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 84, 85, 84, 85, 86, 87, 86, 87] }, { type: "Buffer", data: [84, 85, 84, 85, 86, 87, 86, 87, 48, 48, 48, 48, 48, 48, 48, 48] }, { type: "Buffer", data: [48, 48, 84, 85, 48, 48, 86, 87, 48, 48, 84, 85, 48, 48, 86, 87] }, { type: "Buffer", data: [84, 85, 48, 48, 86, 87, 48, 48, 84, 85, 48, 48, 86, 87, 48, 48] }], tiles: { type: "Buffer", data: [0, 0, 32, 2, 0, 128, 0, 0, 128, 0, 0, 2, 0, 0, 32, 0, 255, 255, 213, 87, 213, 87, 234, 171, 255, 255, 192, 3, 192, 3, 255, 255, 8, 136, 34, 34, 136, 128, 32, 31, 128, 202, 33, 32, 131, 32, 35, 10, 136, 136, 34, 34, 0, 136, 246, 2, 163, 136, 8, 66, 8, 200, 160, 194, 0, 0, 1, 16, 16, 1, 0, 51, 0, 207, 0, 52, 0, 209, 3, 196, 0, 12, 13, 243, 51, 51, 243, 12, 17, 17, 68, 68, 17, 17, 68, 68, 48, 0, 207, 16, 204, 255, 112, 204, 17, 17, 68, 68, 17, 17, 68, 68, 0, 0, 1, 16, 16, 1, 204, 0, 243, 0, 76, 0, 87, 0, 119, 192, 3, 255, 12, 0, 12, 0, 15, 255, 7, 85, 12, 0, 14, 170, 14, 170, 255, 255, 0, 0, 0, 0, 255, 255, 85, 85, 0, 0, 170, 170, 170, 170, 0, 3, 15, 60, 58, 220, 14, 87, 3, 117, 13, 77, 61, 85, 195, 244, 192, 0, 60, 240, 55, 108, 213, 176, 93, 192, 113, 112, 85, 124, 159, 195, 255, 192, 0, 48, 0, 48, 255, 240, 85, 112, 0, 48, 170, 176, 170, 176, 3, 255, 35, 16, 3, 63, 3, 63, 131, 16, 3, 63, 3, 63, 35, 16, 245, 145, 213, 78, 157, 188, 230, 250, 187, 56, 252, 161, 242, 142, 232, 163, 78, 95, 113, 87, 126, 94, 127, 185, 94, 230, 119, 181, 126, 239, 251, 183, 170, 170, 255, 255, 170, 170, 240, 60, 204, 204, 204, 204, 240, 204, 192, 240, 170, 170, 255, 255, 170, 174, 204, 48, 204, 252, 240, 204, 204, 240, 204, 60, 131, 64, 35, 102, 15, 104, 55, 104, 189, 104, 234, 250, 127, 93, 21, 33, 1, 200, 105, 194, 25, 248, 25, 204, 41, 116, 173, 94, 175, 236, 245, 114, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 17, 17, 204, 68, 55, 85, 205, 68, 17, 17, 68, 68, 85, 17, 85, 85, 17, 29, 68, 119, 17, 29, 68, 69, 17, 21, 69, 85, 85, 85, 85, 85, 221, 112, 119, 208, 213, 241, 87, 92, 85, 252, 93, 215, 119, 124, 93, 221, 14, 170, 7, 85, 12, 0, 14, 170, 14, 170, 14, 170, 15, 255, 13, 85, 170, 170, 85, 85, 0, 0, 170, 170, 170, 170, 170, 170, 255, 255, 85, 85, 201, 207, 55, 112, 15, 95, 55, 64, 231, 192, 237, 240, 236, 79, 235, 245, 243, 75, 13, 220, 245, 240, 1, 220, 3, 219, 15, 123, 241, 59, 95, 235, 170, 176, 85, 192, 0, 48, 170, 176, 170, 176, 170, 176, 255, 240, 85, 112, 0, 3, 0, 15, 0, 252, 3, 250, 15, 56, 60, 161, 50, 142, 232, 163, 255, 255, 15, 240, 136, 136, 162, 42, 42, 136, 170, 2, 170, 136, 138, 170, 192, 0, 240, 0, 127, 0, 119, 192, 94, 240, 119, 176, 126, 236, 251, 183, 0, 2, 24, 16, 68, 68, 73, 134, 26, 100, 154, 102, 166, 90, 41, 104, 136, 139, 33, 30, 191, 255, 213, 85, 192, 0, 238, 190, 207, 62, 234, 160, 200, 136, 177, 18, 255, 253, 85, 87, 0, 3, 235, 235, 251, 12, 0, 3, 143, 115, 35, 204, 159, 51, 53, 76, 189, 209, 215, 85, 189, 85, 117, 221, 223, 117, 61, 221, 215, 119, 61, 68, 53, 209, 15, 85, 3, 247, 0, 63, 117, 85, 205, 221, 17, 117, 69, 213, 21, 119, 93, 221, 119, 117, 221, 221, 85, 87, 85, 85, 87, 119, 221, 221, 85, 117, 221, 221, 119, 119, 221, 221, 119, 119, 213, 252, 17, 215, 68, 124, 87, 92, 93, 240, 79, 192, 252, 0, 3, 255, 42, 215, 42, 215, 42, 231, 42, 231, 42, 231, 42, 231, 42, 231, 255, 255, 85, 85, 170, 170, 85, 85, 255, 255, 85, 85, 170, 170, 85, 85, 255, 255, 95, 255, 109, 117, 109, 117, 109, 117, 109, 117, 109, 121, 110, 118, 255, 255, 255, 245, 93, 121, 93, 121, 93, 121, 93, 121, 157, 121, 109, 121, 255, 200, 215, 168, 215, 168, 219, 168, 219, 168, 219, 168, 219, 168, 219, 168, 250, 35, 250, 138, 62, 44, 204, 250, 50, 56, 232, 162, 226, 12, 232, 131, 168, 138, 162, 40, 128, 138, 162, 170, 42, 136, 170, 2, 170, 136, 138, 170, 206, 223, 115, 127, 126, 254, 127, 187, 94, 238, 119, 183, 126, 239, 251, 183, 0, 0, 32, 2, 0, 128, 0, 0, 128, 0, 0, 2, 0, 0, 32, 0, 176, 0, 235, 187, 192, 0, 63, 255, 136, 157, 34, 94, 136, 87, 34, 21, 0, 3, 187, 171, 0, 3, 255, 254, 116, 136, 181, 34, 213, 136, 86, 34, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 136, 72, 33, 18, 150, 21, 73, 65, 105, 164, 22, 81, 146, 97, 37, 22, 253, 247, 3, 253, 31, 119, 119, 64, 125, 64, 192, 240, 127, 93, 21, 85, 119, 127, 223, 208, 21, 244, 1, 205, 1, 117, 13, 93, 15, 205, 253, 116, 0, 0, 1, 72, 6, 16, 5, 164, 33, 84, 0, 152, 24, 0, 36, 32, 42, 231, 42, 231, 42, 231, 42, 231, 42, 231, 42, 215, 42, 215, 42, 190, 32, 0, 0, 65, 18, 17, 4, 89, 2, 85, 9, 153, 32, 130, 0, 0, 77, 185, 78, 118, 77, 181, 78, 117, 77, 117, 109, 117, 111, 255, 250, 170, 157, 113, 109, 113, 93, 113, 93, 113, 93, 113, 93, 121, 255, 249, 170, 175, 219, 168, 219, 168, 219, 168, 219, 168, 219, 168, 215, 168, 215, 168, 190, 168, 226, 35, 254, 132, 251, 18, 226, 217, 233, 100, 239, 153, 126, 213, 91, 191, 230, 39, 49, 116, 135, 209, 103, 230, 27, 181, 110, 245, 95, 159, 254, 171, 238, 239, 51, 119, 142, 223, 103, 183, 25, 223, 102, 247, 87, 189, 254, 229, 213, 170, 213, 170, 213, 85, 255, 255, 213, 170, 213, 170, 213, 85, 255, 255, 170, 171, 170, 171, 85, 87, 255, 255, 170, 171, 170, 171, 85, 87, 255, 255, 255, 255, 170, 170, 170, 170, 85, 85, 255, 255, 93, 117, 94, 181, 94, 181, 94, 181, 94, 181, 94, 181, 94, 181, 254, 191, 94, 181, 94, 181, 87, 213, 7, 208, 76, 51, 58, 175, 123, 236, 124, 60, 92, 3, 112, 2, 112, 2, 61, 80, 195, 193, 204, 112, 50, 117, 2, 117, 200, 213, 63, 197, 48, 48, 213, 8, 213, 80, 213, 223, 125, 119, 95, 223, 84, 222, 65, 69, 81, 80, 200, 60, 194, 167, 0, 43, 128, 91, 103, 119, 157, 221, 247, 117, 87, 80, 229, 223, 121, 126, 94, 251, 87, 237, 87, 231, 94, 189, 121, 221, 229, 119, 213, 87, 181, 94, 109, 121, 91, 229, 223, 237, 126, 183, 251, 125, 237, 215, 247, 99, 61, 142, 207, 57, 115, 230, 211, 217, 124, 54, 183, 77, 221, 147, 255, 255, 202, 170, 203, 255, 203, 0, 203, 0, 203, 255, 122, 170, 95, 255, 255, 255, 170, 151, 255, 215, 0, 215, 0, 215, 255, 215, 170, 157, 255, 245, 197, 80, 124, 65, 87, 0, 85, 213, 87, 117, 94, 189, 121, 221, 229, 119, 5, 83, 64, 126, 20, 249, 87, 102, 93, 217, 116, 54, 119, 77, 221, 147, 255, 192, 4, 194, 252, 192, 252, 192, 4, 192, 252, 194, 252, 192, 4, 192, 1, 0, 5, 64, 21, 80, 85, 84, 0, 0, 5, 64, 5, 64, 5, 64, 1, 80, 1, 80, 1, 80, 0, 0, 21, 85, 5, 84, 1, 80, 0, 64, 0, 0, 1, 0, 5, 0, 21, 21, 85, 21, 21, 21, 5, 0, 1, 0, 0, 64, 0, 80, 84, 84, 84, 85, 84, 84, 0, 80, 0, 64, 0, 0, 32, 192, 35, 51, 13, 28, 179, 69, 49, 18, 212, 130, 28, 80, 117, 57, 240, 2, 15, 48, 21, 204, 131, 92, 128, 167, 53, 44, 2, 95, 33, 159, 245, 221, 223, 119, 189, 221, 55, 247, 79, 223, 20, 127, 4, 20, 0, 65, 150, 253, 119, 124, 221, 243, 119, 206, 253, 244, 117, 64, 84, 16, 4, 1, 0, 0, 35, 242, 3, 63, 3, 63, 143, 16, 15, 63, 63, 191, 63, 144, 0, 0, 47, 194, 252, 192, 252, 192, 4, 240, 252, 242, 254, 252, 6, 252, 63, 191, 63, 191, 15, 90, 15, 127, 131, 255, 0, 63, 0, 0, 32, 0, 254, 252, 254, 254, 165, 240, 253, 240, 255, 192, 252, 2, 0, 0, 32, 0, 3, 63, 35, 63, 3, 16, 3, 63, 135, 245, 5, 85, 0, 85, 32, 0, 252, 192, 252, 194, 4, 192, 252, 192, 95, 208, 85, 82, 85, 0, 32, 0, 136, 136, 33, 18, 152, 137, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 64, 0, 137, 8, 32, 128, 145, 6, 101, 144, 150, 32, 72, 128, 0, 2] } }, gate: { blocks: [{ type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 32, 33, 1, 17, 50, 51, 17, 1, 32, 33, 1, 17, 50, 51] }, { type: "Buffer", data: [32, 33, 17, 1, 50, 51, 1, 17, 32, 33, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [55, 56, 56, 55, 55, 56, 56, 55, 55, 56, 56, 55, 55, 56, 56, 55] }, { type: "Buffer", data: [10, 11, 17, 1, 26, 27, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [5, 6, 0, 0, 21, 22, 0, 0, 37, 38, 17, 1, 53, 54, 1, 17] }, { type: "Buffer", data: [0, 0, 5, 6, 0, 0, 21, 22, 17, 1, 37, 38, 1, 17, 53, 54] }, { type: "Buffer", data: [17, 1, 23, 24, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17, 23, 24] }, { type: "Buffer", data: [23, 24, 17, 1, 23, 24, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [17, 1, 7, 9, 1, 17, 50, 51, 4, 4, 17, 1, 20, 20, 1, 17] }, { type: "Buffer", data: [9, 8, 5, 6, 50, 51, 21, 22, 17, 1, 37, 38, 1, 17, 53, 54] }, { type: "Buffer", data: [5, 6, 7, 9, 21, 22, 50, 51, 37, 38, 17, 1, 53, 54, 1, 17] }, { type: "Buffer", data: [9, 8, 17, 1, 50, 51, 1, 17, 17, 1, 4, 4, 1, 17, 20, 20] }, { type: "Buffer", data: [9, 8, 17, 1, 23, 24, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [17, 1, 7, 9, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17, 23, 24] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 7, 8, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 17, 1, 7, 8, 1, 17, 23, 24] }, { type: "Buffer", data: [17, 1, 7, 9, 1, 17, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [9, 8, 17, 1, 50, 51, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [32, 33, 7, 8, 50, 51, 34, 35, 32, 33, 34, 35, 50, 51, 34, 35] }, { type: "Buffer", data: [7, 8, 32, 33, 34, 35, 50, 51, 34, 35, 32, 33, 34, 35, 50, 51] }, { type: "Buffer", data: [32, 33, 17, 1, 50, 51, 1, 17, 32, 33, 32, 33, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 1, 32, 33, 1, 17, 50, 51, 32, 33, 32, 33, 50, 51, 50, 51] }, { type: "Buffer", data: [23, 24, 17, 1, 50, 51, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 23, 24, 1, 17, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [32, 33, 32, 33, 50, 51, 50, 51, 32, 33, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [32, 33, 32, 33, 50, 51, 50, 51, 17, 1, 32, 33, 1, 17, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 32, 33, 32, 33, 50, 51, 50, 51] }, { type: "Buffer", data: [32, 33, 32, 33, 50, 51, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 7, 9, 1, 17, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [9, 9, 9, 9, 50, 51, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [9, 8, 17, 1, 50, 51, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [12, 13, 32, 33, 28, 29, 50, 51, 32, 33, 32, 33, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 17, 1, 7, 9, 1, 17, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 9, 9, 9, 9, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 9, 8, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [32, 33, 17, 1, 50, 51, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [43, 41, 43, 41, 59, 42, 59, 42, 55, 56, 56, 55, 55, 56, 56, 55] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 32, 33, 7, 9, 50, 51, 50, 51] }, { type: "Buffer", data: [23, 24, 17, 1, 23, 24, 1, 17, 32, 33, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [17, 1, 32, 33, 1, 17, 50, 51, 17, 1, 23, 24, 1, 17, 23, 24] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 14, 15, 17, 1, 30, 31, 1, 17, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 14, 15, 1, 17, 30, 31, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 14, 15, 17, 1, 30, 31, 1, 17, 50, 51] }, { type: "Buffer", data: [0, 0, 0, 0, 14, 15, 0, 0, 30, 31, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [23, 24, 17, 1, 23, 24, 1, 17, 32, 33, 32, 33, 50, 51, 50, 51] }, { type: "Buffer", data: [9, 8, 32, 33, 50, 51, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [32, 33, 7, 9, 50, 51, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [58, 58, 45, 61, 58, 45, 61, 58, 45, 61, 58, 58, 61, 58, 58, 45] }, { type: "Buffer", data: [58, 58, 45, 62, 58, 45, 61, 62, 45, 61, 58, 62, 61, 58, 58, 62] }, { type: "Buffer", data: [62, 58, 45, 61, 62, 45, 61, 58, 62, 61, 58, 58, 62, 58, 58, 45] }, { type: "Buffer", data: [17, 1, 36, 36, 1, 17, 52, 52, 17, 1, 57, 57, 1, 17, 1, 17] }, { type: "Buffer", data: [36, 36, 17, 1, 52, 52, 1, 17, 57, 57, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 2, 3, 1, 17, 18, 19, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 17, 1, 10, 11, 1, 17, 26, 27] }, { type: "Buffer", data: [5, 6, 17, 1, 21, 22, 1, 17, 37, 38, 17, 1, 53, 54, 1, 17] }, { type: "Buffer", data: [2, 3, 17, 1, 18, 19, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [72, 72, 72, 72, 74, 74, 74, 74, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [72, 72, 72, 72, 74, 74, 74, 74, 64, 65, 66, 67, 80, 81, 82, 82] }, { type: "Buffer", data: [72, 72, 72, 72, 74, 74, 74, 74, 68, 69, 17, 1, 84, 85, 1, 17] }, { type: "Buffer", data: [86, 87, 88, 89, 50, 51, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 39, 40, 1, 17, 48, 70, 17, 1, 49, 60, 1, 17, 50, 51] }, { type: "Buffer", data: [40, 40, 40, 40, 71, 58, 58, 70, 83, 63, 60, 60, 50, 51, 50, 51] }, { type: "Buffer", data: [2, 3, 17, 1, 18, 19, 1, 17, 2, 3, 17, 1, 18, 19, 1, 17] }, { type: "Buffer", data: [72, 72, 72, 72, 74, 74, 7, 8, 17, 1, 23, 24, 1, 17, 23, 24] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 17, 1, 39, 40, 1, 17, 48, 70] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 40, 40, 40, 40, 71, 58, 58, 70] }, { type: "Buffer", data: [23, 24, 17, 1, 23, 24, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 7, 8, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [17, 1, 49, 60, 1, 17, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [83, 63, 60, 60, 50, 51, 50, 51, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 23, 24, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17, 50, 51] }, { type: "Buffer", data: [90, 91, 17, 1, 50, 51, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 23, 24, 1, 17, 23, 24, 17, 1, 23, 24, 1, 17, 23, 24] }, { type: "Buffer", data: [7, 8, 7, 8, 34, 35, 34, 35, 34, 35, 34, 35, 34, 35, 34, 35] }, { type: "Buffer", data: [2, 3, 17, 1, 18, 19, 1, 17, 2, 3, 17, 1, 18, 19, 1, 17] }, { type: "Buffer", data: [76, 77, 17, 1, 92, 93, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [72, 72, 78, 79, 74, 74, 74, 74, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 9, 9, 9, 9, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 17, 1, 12, 13, 1, 17, 28, 29] }, { type: "Buffer", data: [40, 25, 17, 1, 71, 44, 1, 17, 60, 44, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 9, 9, 9, 8, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 7, 9, 9, 9, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 17, 1, 10, 11, 1, 17, 26, 27] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 40, 25, 17, 1, 71, 44, 1, 17] }, { type: "Buffer", data: [17, 1, 39, 40, 1, 17, 48, 46, 17, 1, 49, 60, 1, 17, 50, 51] }, { type: "Buffer", data: [40, 40, 40, 40, 46, 58, 58, 46, 83, 63, 60, 60, 50, 51, 50, 51] }, { type: "Buffer", data: [40, 25, 17, 1, 46, 44, 1, 17, 60, 44, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [60, 44, 17, 1, 50, 51, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [72, 72, 72, 72, 74, 74, 74, 74, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [43, 41, 43, 41, 59, 42, 59, 42, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [72, 72, 72, 72, 74, 74, 74, 74, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [72, 72, 72, 72, 74, 74, 74, 74, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 7, 8, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [23, 24, 17, 1, 50, 51, 1, 17, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [7, 8, 17, 1, 23, 24, 1, 17, 23, 24, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [7, 8, 5, 6, 23, 24, 21, 22, 23, 24, 37, 38, 50, 51, 53, 54] }, { type: "Buffer", data: [17, 1, 5, 6, 1, 17, 21, 22, 7, 8, 37, 38, 23, 24, 53, 54] }, { type: "Buffer", data: [23, 24, 5, 6, 50, 51, 21, 22, 17, 1, 37, 38, 1, 17, 53, 54] }, { type: "Buffer", data: [94, 94, 17, 1, 56, 56, 1, 17, 56, 56, 17, 1, 94, 94, 1, 17] }, { type: "Buffer", data: [17, 1, 94, 94, 1, 17, 56, 56, 17, 1, 56, 56, 1, 17, 94, 94] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 32, 33, 32, 33, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 1, 23, 24, 1, 17, 50, 51, 56, 55, 17, 1, 56, 55, 1, 17] }, { type: "Buffer", data: [56, 55, 17, 1, 56, 55, 1, 17, 17, 1, 7, 8, 1, 17, 23, 24] }, { type: "Buffer", data: [17, 1, 55, 56, 1, 17, 55, 56, 7, 8, 17, 1, 23, 24, 1, 17] }, { type: "Buffer", data: [23, 24, 17, 1, 50, 51, 1, 17, 17, 1, 55, 56, 1, 17, 55, 56] }, { type: "Buffer", data: [17, 1, 56, 56, 1, 17, 94, 94, 9, 8, 17, 1, 50, 51, 1, 17] }, { type: "Buffer", data: [56, 56, 17, 1, 94, 94, 1, 17, 17, 1, 7, 9, 1, 17, 50, 51] }, { type: "Buffer", data: [9, 8, 17, 1, 50, 51, 1, 17, 17, 1, 94, 94, 1, 17, 56, 56] }, { type: "Buffer", data: [17, 1, 7, 9, 1, 17, 50, 51, 94, 94, 17, 1, 56, 56, 1, 17] }, { type: "Buffer", data: [55, 56, 56, 55, 55, 56, 56, 55, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 17, 1, 1, 17, 1, 17, 55, 56, 56, 55, 55, 56, 56, 55] }, { type: "Buffer", data: [72, 72, 43, 41, 74, 74, 59, 42, 17, 1, 17, 1, 1, 17, 1, 17] }, { type: "Buffer", data: [17, 1, 5, 6, 1, 17, 21, 22, 17, 1, 37, 38, 1, 17, 53, 54] }, { type: "Buffer", data: [100, 101, 102, 103, 116, 117, 118, 119, 132, 133, 134, 135, 148, 149, 150, 151] }, { type: "Buffer", data: [104, 105, 106, 107, 120, 121, 122, 123, 136, 137, 138, 139, 152, 153, 154, 155] }, { type: "Buffer", data: [104, 105, 106, 107, 120, 121, 122, 123, 136, 137, 138, 139, 152, 153, 154, 155] }, { type: "Buffer", data: [96, 97, 98, 99, 112, 113, 114, 115, 128, 129, 130, 131, 144, 145, 146, 147] }, { type: "Buffer", data: [100, 101, 102, 103, 116, 117, 118, 119, 132, 133, 134, 135, 148, 149, 150, 151] }, { type: "Buffer", data: [104, 105, 106, 107, 120, 121, 122, 123, 136, 137, 138, 139, 152, 153, 154, 155] }, { type: "Buffer", data: [108, 109, 110, 111, 124, 125, 126, 127, 140, 141, 142, 143, 156, 157, 158, 159] }, { type: "Buffer", data: [160, 161, 162, 163, 176, 177, 178, 179, 192, 193, 194, 195, 208, 209, 210, 211] }, { type: "Buffer", data: [164, 165, 166, 167, 180, 181, 182, 183, 196, 197, 198, 199, 212, 213, 214, 215] }, { type: "Buffer", data: [168, 169, 170, 171, 184, 185, 186, 187, 200, 201, 202, 203, 216, 217, 218, 219] }, { type: "Buffer", data: [172, 173, 174, 175, 188, 189, 190, 191, 204, 205, 206, 207, 220, 221, 222, 223] }], tiles: { type: "Buffer", data: [170, 170, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 255, 12, 0, 12, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 192, 0, 48, 168, 48, 0, 0, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 12, 0, 59, 192, 62, 188, 233, 187, 61, 91, 230, 85, 61, 127, 255, 235, 0, 48, 3, 236, 62, 159, 238, 87, 101, 125, 215, 171, 250, 124, 215, 192, 63, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 252, 0, 3, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 253, 85, 253, 85, 253, 85, 253, 85, 255, 255, 255, 254, 255, 234, 254, 175, 85, 85, 85, 127, 87, 235, 126, 175, 234, 239, 174, 255, 239, 87, 255, 87, 0, 0, 0, 0, 0, 0, 0, 3, 0, 63, 3, 243, 171, 187, 171, 255, 0, 63, 3, 243, 63, 51, 243, 255, 51, 3, 255, 3, 3, 3, 3, 63, 170, 171, 175, 188, 186, 220, 174, 87, 171, 117, 173, 77, 189, 85, 195, 244, 234, 170, 62, 250, 55, 110, 213, 186, 93, 234, 113, 122, 85, 126, 159, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 42, 12, 42, 12, 0, 14, 170, 14, 255, 14, 213, 14, 234, 15, 234, 168, 48, 168, 48, 0, 48, 170, 176, 255, 176, 87, 176, 171, 176, 171, 240, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 0, 0, 62, 150, 231, 86, 58, 110, 233, 103, 249, 223, 235, 239, 59, 51, 12, 3, 182, 188, 85, 235, 217, 93, 217, 155, 247, 159, 251, 235, 252, 236, 60, 60, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 85, 85, 0, 1, 85, 81, 85, 81, 85, 81, 85, 81, 85, 81, 85, 81, 234, 239, 175, 255, 239, 87, 255, 167, 215, 167, 215, 167, 215, 167, 215, 87, 87, 87, 167, 87, 167, 87, 167, 87, 167, 127, 167, 247, 191, 183, 119, 183, 87, 3, 255, 3, 215, 3, 215, 63, 215, 243, 215, 51, 215, 255, 255, 255, 3, 243, 63, 51, 243, 255, 51, 87, 255, 87, 85, 87, 85, 87, 255, 255, 201, 207, 183, 112, 175, 95, 183, 64, 231, 192, 237, 240, 236, 79, 235, 245, 243, 75, 13, 222, 245, 250, 1, 222, 3, 219, 15, 123, 241, 59, 95, 235, 63, 255, 192, 0, 197, 85, 198, 170, 198, 170, 198, 170, 197, 85, 192, 0, 255, 252, 0, 3, 85, 83, 170, 147, 170, 147, 170, 147, 85, 83, 0, 3, 218, 170, 223, 255, 222, 187, 222, 179, 220, 51, 223, 251, 223, 255, 218, 170, 170, 167, 255, 247, 174, 183, 12, 55, 12, 55, 255, 247, 255, 247, 170, 167, 15, 240, 63, 252, 248, 47, 232, 43, 232, 43, 232, 43, 235, 235, 236, 59, 0, 3, 0, 0, 0, 13, 0, 254, 3, 116, 0, 249, 14, 244, 14, 253, 112, 0, 176, 0, 112, 0, 191, 0, 157, 192, 111, 0, 159, 176, 127, 176, 85, 85, 64, 0, 68, 68, 65, 17, 68, 69, 65, 21, 68, 85, 65, 85, 85, 85, 0, 0, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 85, 87, 255, 247, 0, 55, 0, 55, 0, 55, 170, 183, 255, 247, 85, 87, 170, 167, 85, 103, 85, 103, 85, 103, 170, 167, 85, 87, 255, 255, 255, 255, 213, 85, 223, 255, 220, 0, 220, 0, 220, 0, 222, 170, 223, 255, 136, 129, 34, 33, 136, 129, 34, 33, 136, 129, 34, 33, 136, 129, 34, 33, 170, 168, 170, 160, 170, 128, 170, 0, 168, 2, 160, 8, 128, 34, 0, 138, 170, 170, 171, 250, 189, 174, 218, 167, 230, 87, 233, 151, 181, 87, 173, 94, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 72, 136, 66, 34, 72, 136, 66, 34, 72, 136, 66, 34, 72, 136, 66, 34, 255, 255, 192, 0, 255, 255, 229, 87, 229, 87, 229, 87, 229, 87, 255, 255, 255, 255, 0, 3, 255, 255, 213, 87, 213, 87, 213, 87, 213, 87, 255, 255, 56, 44, 56, 44, 56, 44, 59, 236, 63, 252, 61, 124, 61, 124, 15, 240, 13, 191, 13, 106, 3, 82, 3, 127, 3, 90, 0, 210, 0, 63, 0, 0, 254, 112, 169, 112, 85, 192, 253, 192, 85, 192, 87, 0, 252, 0, 0, 0, 129, 129, 66, 66, 129, 129, 66, 66, 129, 129, 66, 66, 129, 129, 66, 66, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 3, 192, 3, 192, 43, 232, 173, 122, 188, 62, 175, 250, 42, 168, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 213, 85, 218, 170, 217, 85, 217, 85, 217, 85, 218, 170, 213, 85, 255, 255, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 2, 42, 8, 170, 34, 170, 138, 170, 42, 170, 170, 170, 170, 170, 170, 170, 120, 45, 120, 45, 120, 45, 120, 45, 120, 45, 120, 45, 120, 45, 120, 45, 255, 252, 0, 12, 204, 204, 0, 12, 255, 204, 204, 204, 0, 12, 255, 252, 0, 244, 63, 255, 195, 19, 199, 164, 196, 233, 199, 234, 205, 117, 205, 126, 3, 255, 79, 3, 243, 0, 247, 255, 61, 15, 79, 68, 99, 244, 168, 244, 64, 0, 255, 255, 63, 64, 255, 245, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 85, 85, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 85, 85, 255, 192, 3, 221, 0, 3, 3, 195, 0, 0, 255, 252, 0, 3, 85, 83, 0, 19, 0, 19, 192, 19, 244, 19, 171, 234, 173, 123, 182, 123, 182, 94, 213, 94, 213, 93, 182, 93, 182, 123, 238, 234, 187, 186, 187, 190, 238, 247, 238, 215, 221, 215, 221, 247, 187, 190, 136, 0, 32, 0, 128, 0, 2, 0, 8, 128, 34, 0, 0, 8, 0, 32, 224, 11, 224, 11, 224, 11, 224, 11, 224, 11, 224, 11, 224, 11, 224, 11, 0, 136, 2, 32, 85, 85, 85, 85, 85, 85, 102, 102, 153, 153, 255, 255, 224, 11, 224, 11, 224, 11, 224, 11, 213, 87, 213, 87, 213, 87, 255, 255, 171, 255, 174, 170, 186, 85, 233, 170, 233, 170, 233, 170, 233, 170, 234, 85, 255, 234, 170, 186, 85, 174, 170, 107, 170, 107, 170, 107, 170, 107, 85, 171, 21, 85, 16, 0, 16, 1, 16, 5, 16, 21, 16, 85, 16, 0, 21, 85, 85, 84, 0, 4, 0, 4, 0, 4, 85, 68, 85, 68, 0, 4, 85, 84, 207, 253, 205, 126, 254, 158, 253, 126, 247, 254, 245, 94, 245, 94, 245, 127, 85, 244, 169, 244, 170, 20, 168, 4, 168, 4, 170, 166, 170, 166, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 170, 170, 255, 255, 63, 255, 48, 0, 51, 51, 48, 0, 51, 255, 51, 51, 48, 0, 63, 255, 0, 3, 0, 60, 0, 63, 0, 0, 0, 1, 170, 171, 170, 171, 255, 255, 199, 83, 196, 243, 4, 255, 4, 255, 95, 255, 255, 243, 255, 219, 253, 155, 207, 255, 198, 255, 198, 171, 198, 171, 196, 10, 196, 0, 197, 85, 192, 0, 255, 170, 255, 20, 15, 0, 95, 20, 79, 0, 207, 1, 207, 255, 63, 253, 170, 191, 0, 63, 0, 63, 1, 255, 31, 216, 253, 128, 213, 85, 128, 0, 255, 255, 255, 255, 253, 170, 96, 0, 0, 0, 0, 0, 85, 85, 0, 0, 255, 255, 255, 253, 170, 170, 0, 0, 0, 0, 0, 0, 85, 85, 0, 0, 218, 147, 170, 19, 160, 19, 0, 19, 0, 19, 0, 19, 85, 83, 0, 3, 250, 170, 206, 170, 194, 255, 194, 192, 194, 192, 178, 255, 174, 170, 171, 255, 170, 175, 170, 183, 255, 151, 3, 151, 3, 151, 255, 158, 170, 186, 255, 234, 102, 102, 0, 0, 0, 0, 153, 153, 102, 102, 0, 0, 0, 0, 153, 153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, gym: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [5, 5, 5, 5, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 6, 6, 6, 6, 22, 22, 22, 22] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 2, 56, 7, 8, 18, 19, 23, 24] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 7, 8, 2, 56, 23, 24, 18, 19] }, { type: "Buffer", data: [7, 8, 7, 8, 23, 24, 23, 24, 7, 8, 17, 17, 23, 24, 17, 17] }, { type: "Buffer", data: [7, 8, 7, 8, 23, 24, 23, 24, 17, 17, 7, 8, 17, 17, 23, 24] }, { type: "Buffer", data: [7, 8, 7, 8, 23, 24, 23, 24, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [7, 8, 17, 17, 23, 24, 17, 17, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [17, 17, 7, 8, 17, 17, 23, 24, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [7, 8, 17, 17, 23, 24, 17, 17, 7, 8, 17, 17, 23, 24, 17, 17] }, { type: "Buffer", data: [17, 17, 7, 8, 17, 17, 23, 24, 17, 17, 7, 8, 17, 17, 23, 24] }, { type: "Buffer", data: [34, 35, 17, 17, 50, 51, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 34, 35, 17, 17, 50, 51, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 7, 8, 17, 17, 23, 24, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 7, 8, 17, 17, 23, 24] }, { type: "Buffer", data: [5, 5, 5, 5, 16, 16, 16, 16, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [9, 10, 20, 20, 25, 26, 20, 20, 9, 10, 20, 20, 25, 26, 20, 20] }, { type: "Buffer", data: [20, 20, 9, 10, 20, 20, 25, 26, 20, 20, 9, 10, 20, 20, 25, 26] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [2, 56, 1, 1, 18, 19, 17, 17, 34, 35, 17, 17, 50, 51, 17, 17] }, { type: "Buffer", data: [20, 20, 2, 56, 20, 20, 18, 19, 20, 20, 34, 35, 20, 20, 50, 51] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [17, 17, 4, 4, 17, 17, 20, 20, 17, 17, 20, 20, 17, 17, 20, 20] }, { type: "Buffer", data: [4, 4, 17, 17, 20, 20, 17, 17, 20, 20, 17, 17, 20, 20, 17, 17] }, { type: "Buffer", data: [4, 4, 4, 4, 20, 20, 20, 20, 1, 1, 1, 1, 17, 17, 17, 17] }, { type: "Buffer", data: [4, 4, 17, 17, 20, 20, 17, 17, 1, 1, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [4, 4, 4, 4, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [5, 5, 5, 5, 16, 16, 16, 16, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [1, 1, 1, 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 1, 1, 1, 1, 17, 17, 17, 17] }, { type: "Buffer", data: [32, 33, 32, 33, 48, 49, 48, 49, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [69, 70, 5, 5, 86, 86, 86, 86, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [69, 70, 41, 42, 86, 86, 13, 14, 11, 12, 13, 14, 27, 28, 29, 30] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 11, 12, 17, 17, 27, 28] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 2, 56, 17, 17, 18, 19, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 2, 56, 17, 17, 18, 19] }, { type: "Buffer", data: [36, 38, 38, 38, 37, 15, 15, 15, 68, 5, 69, 70, 84, 86, 86, 86] }, { type: "Buffer", data: [38, 38, 38, 39, 15, 15, 15, 53, 69, 70, 5, 71, 86, 86, 86, 87] }, { type: "Buffer", data: [37, 15, 15, 53, 37, 15, 15, 53, 37, 15, 15, 53, 37, 15, 15, 53] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 17, 17, 31, 31, 17, 17, 31, 31, 17, 17, 31, 31, 17, 17] }, { type: "Buffer", data: [17, 17, 31, 31, 17, 17, 31, 31, 17, 17, 31, 31, 17, 17, 31, 31] }, { type: "Buffer", data: [2, 56, 17, 17, 18, 19, 17, 17, 34, 35, 17, 17, 50, 51, 17, 17] }, { type: "Buffer", data: [17, 17, 2, 56, 17, 17, 18, 19, 17, 17, 34, 35, 17, 17, 50, 51] }, { type: "Buffer", data: [3, 43, 43, 43, 43, 43, 3, 43, 3, 43, 43, 43, 43, 43, 3, 43] }, { type: "Buffer", data: [44, 45, 44, 45, 46, 47, 46, 47, 44, 45, 44, 45, 46, 47, 46, 47] }, { type: "Buffer", data: [43, 43, 43, 43, 43, 43, 43, 43, 44, 45, 43, 43, 46, 47, 43, 43] }, { type: "Buffer", data: [43, 43, 44, 45, 43, 43, 46, 47, 43, 43, 43, 43, 43, 43, 43, 43] }, { type: "Buffer", data: [88, 89, 89, 90, 25, 26, 25, 26, 9, 10, 9, 10, 25, 26, 25, 26] }, { type: "Buffer", data: [44, 45, 44, 45, 46, 47, 46, 47, 44, 45, 43, 43, 46, 47, 43, 43] }, { type: "Buffer", data: [44, 45, 44, 45, 46, 47, 46, 47, 43, 43, 44, 45, 43, 43, 46, 47] }, { type: "Buffer", data: [44, 45, 44, 45, 46, 47, 46, 47, 43, 43, 43, 43, 43, 43, 43, 43] }, { type: "Buffer", data: [44, 45, 43, 43, 46, 47, 43, 43, 44, 45, 44, 45, 46, 47, 46, 47] }, { type: "Buffer", data: [64, 65, 43, 43, 80, 81, 43, 43, 44, 45, 43, 43, 46, 47, 43, 43] }, { type: "Buffer", data: [43, 43, 44, 45, 43, 43, 46, 47, 43, 43, 64, 65, 43, 43, 80, 81] }, { type: "Buffer", data: [43, 43, 44, 45, 43, 43, 46, 47, 44, 45, 44, 45, 46, 47, 46, 47] }, { type: "Buffer", data: [43, 43, 43, 43, 43, 43, 43, 43, 44, 45, 64, 65, 46, 47, 80, 81] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 63, 63, 17, 17, 63, 63] }, { type: "Buffer", data: [17, 17, 63, 63, 17, 17, 63, 63, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 60, 60, 17, 17, 76, 76, 17, 17, 60, 60, 17, 17, 76, 76] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 60, 61, 60, 61, 60, 61, 60, 61] }, { type: "Buffer", data: [36, 38, 38, 39, 37, 15, 15, 53, 37, 15, 15, 53, 37, 15, 15, 53] }, { type: "Buffer", data: [37, 15, 15, 53, 37, 15, 15, 53, 37, 15, 15, 53, 66, 16, 16, 62] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 36, 38, 38, 39, 66, 16, 16, 62] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 63, 63, 60, 61, 63, 63, 60, 61] }, { type: "Buffer", data: [36, 38, 38, 39, 66, 16, 16, 62, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [36, 39, 5, 5, 37, 53, 16, 16, 37, 53, 17, 17, 37, 53, 17, 17] }, { type: "Buffer", data: [5, 5, 36, 39, 16, 16, 37, 53, 17, 17, 37, 53, 17, 17, 37, 53] }, { type: "Buffer", data: [36, 39, 17, 17, 37, 53, 17, 17, 37, 53, 17, 17, 37, 53, 17, 17] }, { type: "Buffer", data: [17, 17, 36, 39, 17, 17, 37, 53, 17, 17, 37, 53, 17, 17, 37, 53] }, { type: "Buffer", data: [36, 38, 38, 39, 66, 16, 37, 53, 17, 17, 37, 53, 17, 17, 37, 53] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 36, 38, 38, 39, 66, 16, 37, 53] }, { type: "Buffer", data: [17, 17, 36, 39, 17, 17, 37, 53, 17, 17, 37, 53, 17, 17, 37, 53] }, { type: "Buffer", data: [36, 39, 17, 17, 37, 53, 17, 17, 37, 53, 17, 17, 66, 62, 17, 17] }, { type: "Buffer", data: [17, 17, 36, 39, 17, 17, 37, 53, 17, 17, 37, 53, 17, 17, 66, 62] }, { type: "Buffer", data: [36, 39, 17, 17, 37, 53, 17, 17, 37, 15, 38, 39, 66, 16, 16, 62] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 36, 39, 17, 17, 37, 53] }, { type: "Buffer", data: [37, 53, 17, 17, 66, 62, 17, 17, 17, 17, 36, 39, 17, 17, 37, 53] }, { type: "Buffer", data: [17, 17, 37, 53, 17, 17, 66, 62, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 36, 38, 38, 39, 37, 53, 16, 62] }, { type: "Buffer", data: [61, 61, 17, 17, 77, 77, 17, 17, 36, 38, 38, 39, 66, 16, 16, 62] }, { type: "Buffer", data: [17, 17, 36, 38, 17, 17, 66, 16, 63, 63, 61, 61, 63, 63, 77, 77] }, { type: "Buffer", data: [17, 17, 63, 63, 17, 17, 63, 63, 36, 38, 38, 39, 66, 16, 16, 62] }, { type: "Buffer", data: [36, 38, 38, 39, 66, 16, 16, 62, 17, 17, 63, 63, 17, 17, 63, 63] }, { type: "Buffer", data: [38, 39, 17, 17, 16, 62, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [76, 77, 63, 63, 76, 77, 63, 63, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [5, 5, 5, 5, 16, 16, 16, 16, 17, 17, 60, 60, 17, 17, 76, 76] }, { type: "Buffer", data: [17, 17, 63, 63, 17, 17, 63, 63, 36, 38, 38, 39, 66, 16, 37, 53] }, { type: "Buffer", data: [5, 5, 5, 5, 16, 16, 16, 16, 17, 17, 63, 63, 17, 17, 63, 63] }, { type: "Buffer", data: [76, 77, 36, 39, 76, 77, 37, 53, 17, 17, 37, 53, 17, 17, 66, 62] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 63, 63, 17, 17, 63, 63, 17, 17] }, { type: "Buffer", data: [63, 63, 17, 17, 63, 63, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 61, 61, 17, 17, 77, 77, 17, 17, 36, 39, 17, 17, 37, 53] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 38, 39, 17, 17, 16, 62, 17, 17] }, { type: "Buffer", data: [5, 5, 5, 5, 16, 16, 16, 16, 91, 92, 93, 94, 54, 55, 85, 95] }, { type: "Buffer", data: [5, 5, 5, 5, 16, 16, 16, 16, 41, 59, 59, 42, 78, 57, 57, 79] }, { type: "Buffer", data: [52, 67, 52, 67, 82, 83, 82, 83, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [41, 42, 41, 42, 13, 14, 13, 14, 13, 14, 13, 14, 29, 30, 29, 30] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 41, 59, 59, 59, 78, 57, 57, 57] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 59, 42, 17, 17, 57, 79, 17, 17] }, { type: "Buffer", data: [88, 89, 89, 90, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [9, 10, 9, 10, 25, 26, 25, 26, 6, 6, 6, 6, 22, 22, 22, 22] }, { type: "Buffer", data: [88, 89, 89, 89, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [89, 90, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 36, 39, 17, 17, 37, 53, 36, 38, 15, 53, 66, 16, 16, 62] }, { type: "Buffer", data: [72, 73, 36, 39, 74, 75, 37, 53, 17, 17, 37, 53, 17, 17, 37, 53] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 36, 39, 17, 17, 37, 53, 17, 17] }, { type: "Buffer", data: [2, 56, 32, 33, 18, 19, 48, 49, 34, 35, 17, 17, 50, 51, 17, 17] }, { type: "Buffer", data: [32, 33, 2, 56, 48, 49, 18, 19, 17, 17, 34, 35, 17, 17, 50, 51] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 170, 170, 85, 85, 170, 170, 170, 170, 170, 170, 85, 85, 170, 171, 175, 188, 186, 220, 174, 87, 171, 117, 173, 77, 189, 85, 195, 244, 137, 72, 20, 20, 66, 129, 66, 129, 20, 20, 105, 105, 149, 149, 33, 66, 85, 85, 0, 0, 255, 255, 94, 181, 94, 185, 108, 57, 108, 49, 65, 64, 85, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 85, 85, 0, 0, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 191, 171, 207, 172, 40, 176, 34, 176, 26, 192, 170, 194, 170, 232, 170, 254, 170, 239, 234, 135, 250, 167, 126, 149, 238, 103, 123, 151, 239, 175, 187, 85, 85, 64, 0, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 85, 85, 0, 9, 170, 169, 170, 169, 170, 169, 170, 169, 170, 169, 170, 169, 170, 170, 170, 175, 170, 245, 87, 85, 173, 85, 173, 95, 173, 117, 95, 213, 170, 170, 234, 170, 126, 170, 87, 85, 85, 234, 213, 234, 117, 234, 95, 213, 218, 170, 223, 255, 222, 187, 222, 179, 220, 51, 223, 251, 223, 255, 218, 170, 170, 167, 255, 247, 174, 183, 12, 55, 12, 55, 255, 247, 255, 247, 170, 167, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 34, 34, 136, 136, 34, 34, 136, 136, 170, 170, 170, 170, 170, 170, 255, 255, 170, 170, 170, 170, 170, 170, 85, 85, 170, 170, 170, 170, 170, 170, 85, 85, 201, 207, 183, 117, 175, 95, 175, 64, 183, 192, 237, 240, 237, 95, 236, 79, 243, 75, 93, 222, 245, 250, 1, 250, 3, 222, 15, 123, 245, 123, 241, 59, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 85, 85, 136, 136, 162, 42, 136, 138, 85, 85, 168, 138, 170, 42, 168, 138, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 0, 0, 85, 85, 170, 170, 226, 54, 254, 129, 251, 39, 226, 215, 233, 75, 239, 158, 126, 223, 91, 190, 126, 239, 67, 55, 216, 239, 230, 123, 145, 159, 214, 111, 181, 123, 191, 238, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 106, 170, 85, 85, 170, 169, 170, 169, 170, 169, 170, 169, 170, 169, 170, 169, 170, 169, 85, 85, 172, 245, 172, 15, 173, 0, 87, 80, 167, 5, 169, 240, 170, 95, 85, 85, 124, 234, 192, 234, 1, 234, 23, 85, 67, 106, 61, 170, 214, 170, 85, 85, 223, 255, 218, 171, 218, 171, 218, 171, 218, 171, 255, 255, 218, 170, 191, 255, 255, 247, 234, 167, 234, 167, 234, 167, 234, 167, 255, 255, 170, 167, 255, 254, 170, 170, 170, 170, 170, 170, 86, 85, 170, 170, 170, 170, 170, 170, 85, 85, 170, 170, 255, 255, 234, 170, 234, 170, 255, 255, 229, 102, 223, 255, 222, 102, 170, 170, 255, 255, 170, 171, 170, 171, 255, 255, 85, 87, 255, 247, 85, 119, 235, 255, 234, 191, 218, 170, 198, 170, 193, 85, 194, 170, 210, 255, 198, 217, 255, 235, 254, 171, 170, 167, 170, 151, 85, 87, 170, 151, 255, 151, 167, 151, 255, 255, 192, 0, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 3, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 0, 0, 0, 0, 191, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 254, 0, 3, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 72, 68, 2, 17, 0, 128, 34, 1, 72, 68, 1, 32, 72, 64, 17, 1, 136, 143, 35, 242, 158, 232, 46, 162, 187, 120, 54, 231, 189, 153, 230, 103, 200, 136, 63, 34, 141, 200, 38, 226, 155, 120, 117, 114, 157, 244, 119, 126, 245, 93, 223, 85, 125, 221, 55, 127, 143, 223, 39, 253, 137, 118, 34, 95, 221, 220, 119, 94, 221, 248, 127, 114, 255, 216, 127, 98, 157, 68, 245, 34, 221, 153, 221, 101, 223, 255, 221, 102, 221, 153, 223, 255, 213, 85, 255, 255, 149, 119, 85, 119, 255, 247, 153, 119, 85, 119, 255, 247, 85, 87, 255, 255, 193, 213, 194, 218, 194, 213, 194, 255, 194, 170, 178, 170, 174, 170, 171, 255, 87, 87, 167, 151, 87, 151, 255, 151, 170, 151, 170, 158, 170, 186, 255, 234, 63, 255, 53, 170, 60, 0, 12, 69, 12, 0, 12, 81, 12, 69, 12, 0, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 206, 255, 206, 106, 199, 255, 204, 0, 205, 85, 205, 4, 222, 81, 255, 255, 255, 190, 169, 189, 255, 215, 0, 182, 85, 118, 68, 118, 17, 117, 255, 255, 234, 170, 62, 250, 55, 110, 213, 186, 93, 234, 113, 122, 85, 126, 159, 195, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 0, 0, 255, 255, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 128, 0, 128, 0, 128, 1, 128, 5, 128, 21, 128, 84, 129, 80, 170, 170, 0, 2, 0, 2, 64, 2, 80, 2, 84, 2, 21, 2, 5, 66, 34, 35, 136, 139, 34, 35, 136, 139, 170, 171, 170, 171, 170, 171, 255, 255, 170, 170, 128, 2, 133, 82, 69, 81, 133, 82, 133, 82, 128, 2, 85, 85, 136, 136, 33, 18, 156, 196, 55, 114, 213, 92, 55, 127, 253, 255, 55, 247, 140, 200, 247, 114, 221, 92, 119, 119, 255, 220, 119, 114, 189, 244, 155, 226, 226, 34, 200, 136, 226, 34, 200, 136, 234, 170, 234, 170, 234, 170, 255, 255, 255, 252, 170, 92, 0, 60, 17, 48, 17, 48, 16, 48, 21, 48, 16, 48, 213, 85, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 85, 85, 0, 15, 0, 48, 0, 193, 0, 197, 0, 193, 0, 48, 0, 15, 85, 85, 240, 0, 12, 0, 67, 0, 83, 0, 67, 0, 12, 0, 240, 0, 85, 87, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 170, 170, 170, 170, 170, 170, 85, 87, 170, 191, 171, 251, 171, 187, 87, 255, 170, 191, 171, 251, 191, 187, 247, 255, 187, 3, 255, 3, 3, 3, 3, 63, 171, 3, 255, 3, 215, 3, 215, 63, 215, 243, 215, 51, 215, 255, 255, 255, 3, 243, 63, 51, 243, 255, 51, 87, 255, 87, 85, 87, 85, 87, 255, 255, 129, 80, 128, 84, 128, 21, 128, 5, 128, 1, 128, 0, 128, 0, 170, 170, 5, 66, 21, 2, 84, 2, 80, 2, 64, 2, 0, 2, 0, 2, 170, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 140, 245, 33, 29, 152, 140, 34, 44, 136, 114, 34, 216, 136, 125, 34, 23, 92, 136, 114, 34, 184, 136, 178, 34, 45, 136, 167, 98, 125, 132, 214, 34, 44, 85, 140, 16, 44, 69, 188, 0, 181, 85, 191, 255, 170, 170, 255, 255, 20, 50, 5, 56, 65, 50, 0, 60, 85, 94, 255, 254, 170, 170, 255, 255, 192, 0, 192, 0, 207, 255, 241, 0, 207, 255, 234, 250, 192, 0, 255, 255, 105, 191, 85, 119, 255, 215, 177, 55, 181, 126, 186, 186, 95, 213, 255, 255, 0, 0, 0, 0, 255, 255, 4, 16, 255, 255, 171, 234, 0, 0, 255, 255, 0, 3, 0, 3, 255, 243, 0, 79, 255, 243, 175, 171, 0, 3, 255, 255, 255, 255, 213, 85, 255, 255, 181, 95, 181, 95, 159, 245, 170, 170, 170, 170, 255, 255, 85, 85, 255, 255, 85, 85, 255, 255, 85, 85, 170, 170, 170, 170, 255, 255, 85, 87, 255, 255, 245, 94, 245, 94, 95, 250, 170, 170, 170, 170, 3, 255, 60, 0, 204, 0, 206, 170, 206, 255, 206, 208, 206, 213, 206, 208, 255, 195, 0, 60, 0, 60, 170, 188, 255, 190, 87, 190, 87, 189, 7, 190, 255, 192, 0, 63, 0, 48, 0, 58, 170, 186, 255, 181, 85, 116, 105, 188, 0, 0, 255, 252, 0, 3, 170, 167, 170, 167, 85, 103, 0, 103, 168, 103, 0, 103, 136, 103, 0, 103, 85, 103, 170, 167, 170, 167, 85, 87, 255, 255] } }, house: { blocks: [{ type: "Buffer", data: [170, 171, 170, 171, 186, 187, 186, 187, 170, 171, 170, 171, 186, 187, 186, 187] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 38, 39, 18, 19, 54, 47] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 39, 41, 2, 3, 47, 57, 18, 19] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [38, 41, 38, 41, 14, 15, 14, 15, 14, 15, 14, 15, 30, 31, 30, 31] }, { type: "Buffer", data: [0, 0, 36, 36, 0, 0, 52, 52, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [10, 11, 1, 1, 8, 9, 1, 1, 26, 27, 1, 1, 24, 25, 1, 1] }, { type: "Buffer", data: [1, 1, 10, 11, 1, 1, 8, 9, 1, 1, 26, 27, 1, 1, 24, 25] }, { type: "Buffer", data: [0, 0, 36, 36, 0, 0, 52, 52, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [0, 0, 38, 41, 0, 0, 48, 49, 1, 1, 48, 49, 1, 1, 30, 31] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [2, 3, 54, 47, 18, 19, 60, 58, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [47, 57, 2, 3, 58, 59, 18, 19, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [0, 0, 45, 46, 0, 0, 61, 62, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [64, 65, 0, 0, 32, 33, 38, 39, 66, 67, 54, 47, 30, 31, 60, 58] }, { type: "Buffer", data: [0, 0, 0, 0, 39, 41, 0, 0, 47, 57, 1, 1, 58, 59, 1, 1] }, { type: "Buffer", data: [0, 0, 72, 73, 0, 0, 88, 89, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [73, 75, 0, 0, 90, 91, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 38, 39, 1, 1, 70, 71] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 39, 41, 1, 1, 47, 57, 1, 1] }, { type: "Buffer", data: [36, 36, 0, 0, 52, 52, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [0, 63, 0, 63, 63, 0, 63, 0, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 86, 87, 1, 1, 60, 58, 1, 1, 2, 3, 1, 1, 18, 19] }, { type: "Buffer", data: [47, 57, 1, 1, 58, 59, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [38, 41, 38, 41, 48, 49, 48, 49, 48, 49, 48, 49, 30, 31, 30, 31] }, { type: "Buffer", data: [1, 1, 55, 40, 1, 55, 1, 1, 40, 1, 55, 1, 1, 55, 1, 1] }, { type: "Buffer", data: [1, 55, 1, 1, 55, 1, 40, 1, 2, 3, 38, 39, 18, 19, 54, 47] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 39, 41, 28, 29, 47, 57, 68, 69] }, { type: "Buffer", data: [34, 1, 40, 1, 1, 34, 1, 40, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [0, 63, 35, 74, 63, 0, 84, 85, 1, 40, 1, 55, 1, 1, 55, 1] }, { type: "Buffer", data: [28, 29, 80, 81, 68, 69, 82, 83, 1, 1, 55, 40, 1, 55, 1, 1] }, { type: "Buffer", data: [47, 57, 2, 3, 58, 59, 18, 19, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 42, 43, 44, 37, 12, 13, 53, 56] }], tiles: { type: "Buffer", data: [170, 170, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 128, 0, 32, 0, 8, 0, 2, 0, 8, 128, 32, 32, 128, 8, 0, 2, 128, 0, 32, 0, 8, 0, 2, 0, 8, 128, 35, 255, 140, 0, 12, 42, 128, 0, 32, 0, 8, 0, 2, 0, 8, 128, 255, 224, 0, 56, 168, 50, 0, 0, 85, 85, 170, 170, 85, 85, 170, 85, 170, 85, 85, 170, 85, 170, 255, 255, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 255, 255, 15, 255, 50, 170, 63, 255, 202, 170, 202, 170, 213, 85, 223, 255, 222, 169, 255, 240, 170, 172, 255, 252, 170, 171, 170, 171, 85, 87, 255, 247, 85, 119, 62, 150, 231, 86, 58, 110, 233, 103, 249, 223, 235, 239, 59, 51, 12, 3, 182, 188, 85, 235, 217, 93, 217, 155, 247, 159, 251, 235, 252, 236, 60, 60, 12, 0, 59, 192, 62, 188, 233, 187, 61, 91, 230, 85, 61, 127, 255, 235, 0, 48, 3, 236, 62, 159, 238, 87, 101, 125, 215, 171, 250, 124, 215, 192, 14, 157, 3, 127, 3, 223, 62, 158, 201, 103, 238, 223, 62, 239, 3, 51, 213, 252, 159, 255, 171, 234, 93, 255, 185, 127, 218, 169, 238, 237, 51, 243, 224, 0, 239, 255, 238, 186, 237, 117, 236, 48, 239, 255, 239, 255, 224, 0, 0, 11, 255, 251, 234, 187, 234, 187, 202, 59, 240, 251, 255, 251, 0, 11, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140, 42, 44, 42, 12, 0, 14, 170, 14, 255, 46, 213, 142, 230, 15, 233, 168, 48, 168, 48, 0, 48, 170, 176, 255, 176, 87, 176, 107, 184, 171, 242, 170, 85, 170, 85, 85, 170, 85, 170, 85, 85, 170, 170, 85, 85, 0, 0, 255, 255, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 255, 255, 222, 9, 222, 169, 221, 85, 221, 85, 221, 85, 223, 255, 213, 213, 127, 255, 85, 119, 85, 119, 85, 119, 85, 119, 85, 119, 255, 247, 87, 87, 255, 253, 13, 191, 13, 106, 3, 82, 3, 127, 3, 90, 0, 210, 0, 63, 0, 0, 254, 112, 169, 112, 85, 192, 253, 192, 85, 192, 87, 0, 252, 0, 0, 0, 0, 3, 0, 0, 0, 13, 0, 254, 3, 116, 0, 249, 14, 244, 14, 253, 112, 0, 176, 0, 112, 0, 191, 0, 157, 192, 111, 0, 159, 176, 127, 176, 0, 0, 0, 0, 0, 63, 0, 192, 3, 10, 12, 42, 48, 170, 56, 42, 0, 0, 0, 0, 192, 0, 48, 0, 12, 0, 131, 0, 160, 192, 168, 48, 239, 255, 229, 87, 229, 87, 229, 87, 229, 87, 255, 255, 224, 0, 63, 255, 255, 251, 213, 91, 213, 91, 213, 91, 213, 91, 255, 255, 0, 11, 255, 252, 206, 255, 206, 255, 206, 170, 205, 85, 206, 170, 205, 85, 195, 255, 192, 0, 255, 183, 255, 183, 170, 183, 255, 119, 170, 183, 85, 123, 255, 235, 0, 3, 15, 255, 53, 87, 48, 3, 53, 87, 53, 87, 53, 87, 48, 3, 63, 255, 174, 170, 87, 85, 85, 255, 87, 192, 172, 0, 92, 0, 112, 0, 112, 0, 170, 170, 255, 255, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 0, 0, 0, 0, 240, 0, 95, 192, 149, 112, 231, 92, 231, 92, 231, 92, 63, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 129, 64, 36, 144, 1, 64, 21, 0, 66, 80, 106, 164, 150, 164, 1, 90, 255, 252, 0, 3, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 0, 192, 3, 112, 3, 112, 61, 236, 229, 236, 57, 103, 58, 123, 15, 89, 12, 0, 55, 0, 55, 240, 238, 239, 229, 107, 182, 188, 149, 240, 90, 108, 0, 0, 0, 0, 0, 15, 0, 202, 3, 127, 0, 255, 3, 103, 3, 153, 170, 170, 127, 255, 112, 0, 113, 85, 177, 165, 113, 165, 113, 85, 113, 86, 170, 170, 255, 253, 0, 13, 85, 77, 85, 78, 85, 77, 165, 77, 169, 77, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 213, 85, 223, 255, 222, 238, 222, 204, 220, 204, 220, 255, 223, 255, 213, 85, 85, 87, 255, 247, 235, 183, 235, 183, 195, 55, 195, 247, 255, 247, 85, 87, 87, 3, 255, 3, 215, 3, 215, 63, 215, 243, 215, 51, 215, 255, 255, 255, 3, 243, 63, 51, 243, 255, 51, 87, 255, 87, 85, 87, 85, 87, 255, 255, 192, 3, 234, 171, 234, 171, 255, 255, 170, 170, 85, 85, 85, 85, 85, 85, 254, 17, 102, 103, 175, 255, 240, 127, 0, 202, 252, 15, 112, 0, 0, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 1, 0, 17, 68, 21, 84, 21, 84, 5, 80, 5, 80, 1, 64, 0, 0, 235, 172, 227, 140, 231, 92, 149, 112, 95, 192, 240, 0, 0, 0, 0, 0, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 255, 255, 85, 85, 255, 255, 85, 85, 255, 255, 170, 170, 170, 170, 0, 0, 255, 255, 85, 87, 255, 252, 93, 92, 254, 172, 174, 172, 175, 252, 0, 0, 255, 255, 213, 85, 63, 255, 53, 117, 50, 191, 50, 186, 63, 250, 0, 0, 177, 90, 113, 170, 113, 85, 112, 0, 191, 255, 85, 85, 85, 85, 85, 85, 170, 78, 170, 77, 85, 77, 0, 13, 255, 254, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 87, 85, 87, 85, 174, 238, 85, 117, 85, 221, 85, 85, 171, 255, 92, 0, 92, 0, 92, 0, 174, 170, 94, 255, 254, 199, 206, 255, 255, 234, 0, 53, 0, 53, 0, 53, 170, 186, 255, 181, 255, 191, 255, 187, 215, 255, 252, 68, 206, 85, 204, 68, 206, 170, 223, 255, 213, 85, 191, 255, 255, 215, 68, 63, 85, 55, 1, 55, 170, 183, 255, 247, 85, 87, 255, 254, 62, 10, 59, 130, 59, 224, 15, 184, 2, 174, 0, 175, 0, 46, 0, 11, 160, 176, 130, 240, 11, 176, 47, 224, 186, 128, 250, 0, 184, 0, 192, 0, 202, 191, 202, 181, 202, 191, 202, 170, 203, 255, 204, 0, 204, 168, 204, 0, 255, 234, 86, 58, 255, 234, 170, 170, 191, 250, 192, 14, 74, 142, 64, 14, 191, 255, 112, 0, 123, 255, 115, 255, 179, 255, 115, 255, 115, 255, 115, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 186, 170, 117, 85, 255, 85, 3, 213, 0, 58, 0, 53, 0, 13, 0, 15, 255, 254, 0, 13, 255, 237, 255, 205, 255, 206, 255, 205, 255, 205, 255, 205, 253, 85, 253, 85, 253, 85, 253, 85, 255, 255, 255, 254, 255, 234, 254, 175, 85, 85, 85, 127, 87, 235, 126, 175, 234, 239, 174, 255, 239, 87, 255, 87, 0, 0, 0, 0, 0, 0, 0, 3, 0, 63, 3, 243, 171, 187, 171, 255, 0, 63, 3, 243, 63, 51, 243, 255, 51, 3, 255, 3, 3, 3, 3, 63, 202, 170, 214, 170, 201, 90, 226, 37, 200, 138, 178, 32, 172, 128, 59, 128, 170, 170, 170, 170, 166, 170, 153, 170, 102, 106, 106, 154, 26, 150, 21, 125, 238, 192, 222, 186, 58, 175, 3, 239, 12, 59, 58, 158, 53, 122, 15, 192, 159, 255, 117, 85, 223, 255, 119, 85, 255, 255, 170, 170, 170, 170, 0, 0, 176, 0, 122, 170, 126, 170, 127, 255, 183, 119, 125, 221, 95, 119, 87, 255, 0, 14, 170, 173, 170, 189, 255, 253, 119, 126, 221, 245, 119, 117, 255, 213, 204, 0, 204, 0, 204, 0, 204, 0, 206, 170, 203, 255, 202, 170, 245, 85, 64, 14, 64, 14, 64, 14, 64, 14, 106, 174, 255, 250, 170, 170, 85, 85, 179, 255, 115, 255, 115, 255, 115, 255, 183, 255, 112, 0, 127, 255, 85, 85, 255, 255, 255, 255, 234, 171, 193, 67, 193, 67, 21, 84, 255, 255, 85, 85, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 85, 85, 255, 206, 255, 205, 255, 205, 255, 205, 255, 222, 0, 13, 255, 253, 85, 85, 234, 239, 175, 255, 239, 87, 255, 167, 215, 167, 215, 167, 215, 167, 215, 87, 87, 87, 167, 87, 167, 87, 167, 87, 167, 127, 167, 247, 191, 183, 119, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, interior: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [31, 31, 11, 12, 31, 31, 27, 28, 31, 31, 43, 44, 31, 31, 59, 60] }, { type: "Buffer", data: [13, 14, 31, 31, 29, 30, 31, 31, 91, 92, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 7, 8, 9, 32, 23, 24, 25, 48, 39, 40, 41] }, { type: "Buffer", data: [16, 16, 16, 16, 10, 16, 16, 16, 26, 37, 38, 38, 42, 53, 54, 54] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 7, 38, 38, 32, 23, 54, 54, 48, 39] }, { type: "Buffer", data: [16, 16, 16, 16, 8, 9, 10, 16, 24, 25, 26, 37, 40, 41, 42, 53] }, { type: "Buffer", data: [69, 55, 56, 57, 31, 80, 1, 2, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [58, 69, 69, 69, 15, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [69, 69, 69, 55, 31, 31, 31, 80, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [56, 57, 58, 69, 1, 2, 15, 31, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 70, 70, 70, 70, 71, 71, 71, 71] }, { type: "Buffer", data: [47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 61, 62, 31, 31, 59, 60, 31, 31] }, { type: "Buffer", data: [31, 72, 74, 74, 72, 64, 64, 17, 77, 64, 64, 33, 77, 64, 64, 91] }, { type: "Buffer", data: [74, 74, 73, 31, 18, 64, 64, 73, 34, 64, 64, 78, 92, 64, 64, 78] }, { type: "Buffer", data: [52, 52, 52, 52, 68, 49, 50, 50, 31, 65, 66, 66, 31, 31, 31, 31] }, { type: "Buffer", data: [52, 52, 52, 52, 51, 68, 68, 68, 67, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [63, 64, 64, 64, 79, 63, 64, 64, 31, 79, 75, 76, 31, 31, 31, 31] }, { type: "Buffer", data: [64, 64, 64, 81, 64, 64, 81, 82, 76, 75, 82, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [19, 20, 52, 52, 35, 36, 68, 68, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [52, 52, 19, 20, 68, 68, 35, 36, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 61, 62, 31, 31, 59, 60, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 61, 62, 31, 31, 59, 60] }, { type: "Buffer", data: [61, 62, 31, 31, 59, 60, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 87, 87, 87, 87, 88, 88, 88, 88] }, { type: "Buffer", data: [31, 31, 89, 90, 31, 31, 89, 90, 31, 31, 89, 90, 31, 31, 91, 92] }, { type: "Buffer", data: [16, 16, 3, 3, 16, 16, 4, 4, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [16, 16, 5, 6, 16, 16, 21, 22, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [89, 90, 31, 31, 89, 90, 31, 31, 89, 90, 45, 87, 91, 92, 91, 88] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 93, 93, 93, 93, 94, 94, 94, 94] }, { type: "Buffer", data: [45, 46, 16, 16, 89, 90, 16, 16, 89, 90, 31, 31, 89, 90, 31, 31] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 31, 31, 31, 31, 31, 31, 31, 31] }, { type: "Buffer", data: [45, 46, 47, 47, 89, 90, 47, 47, 89, 90, 47, 47, 89, 90, 47, 47] }, { type: "Buffer", data: [89, 90, 31, 31, 89, 90, 31, 31, 89, 90, 31, 31, 89, 90, 31, 31] }, { type: "Buffer", data: [89, 90, 31, 31, 89, 90, 31, 31, 45, 87, 87, 87, 91, 88, 88, 88] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 87, 87, 87, 87, 88, 88, 88, 88] }, { type: "Buffer", data: [89, 90, 47, 47, 89, 90, 47, 47, 87, 46, 47, 47, 88, 92, 47, 47] }, { type: "Buffer", data: [89, 90, 47, 47, 89, 90, 47, 47, 89, 90, 47, 47, 89, 90, 47, 47] }, { type: "Buffer", data: [16, 16, 45, 46, 16, 16, 89, 90, 31, 31, 89, 90, 31, 31, 89, 90] }, { type: "Buffer", data: [31, 31, 89, 90, 31, 31, 89, 90, 31, 31, 89, 90, 31, 31, 89, 90] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 87, 87, 87, 46, 88, 88, 88, 92] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 45, 87, 87, 87, 91, 88, 88, 88] }, { type: "Buffer", data: [89, 90, 31, 31, 89, 90, 31, 31, 89, 90, 45, 87, 89, 90, 91, 88] }, { type: "Buffer", data: [31, 31, 89, 90, 31, 31, 89, 90, 87, 46, 89, 90, 88, 92, 91, 92] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 87, 46, 45, 46, 88, 92, 89, 90] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 45, 87, 87, 46, 91, 88, 88, 92] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 87, 87, 87, 87, 87, 87, 87, 87] }, { type: "Buffer", data: [89, 90, 31, 31, 89, 90, 31, 31, 89, 90, 45, 87, 89, 90, 45, 87] }, { type: "Buffer", data: [89, 90, 52, 52, 89, 90, 68, 68, 89, 90, 31, 31, 89, 90, 31, 31] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 87, 46, 45, 46, 87, 46, 89, 90] }, { type: "Buffer", data: [52, 52, 89, 90, 68, 68, 89, 90, 31, 31, 89, 90, 31, 31, 89, 90] }, { type: "Buffer", data: [31, 31, 31, 31, 31, 31, 31, 31, 45, 46, 31, 31, 89, 90, 31, 31] }, { type: "Buffer", data: [89, 90, 31, 31, 89, 90, 31, 31, 45, 87, 87, 46, 91, 88, 88, 92] }, { type: "Buffer", data: [11, 12, 13, 14, 27, 28, 29, 30, 43, 44, 91, 92, 59, 60, 31, 31] }, { type: "Buffer", data: [31, 31, 83, 84, 31, 31, 85, 86, 31, 31, 31, 31, 31, 31, 31, 31] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 189, 239, 237, 239, 239, 250, 189, 223, 245, 213, 85, 61, 85, 0, 255, 85, 127, 85, 87, 255, 254, 85, 122, 85, 127, 85, 87, 85, 124, 255, 0, 255, 255, 192, 3, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 202, 163, 192, 3, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 192, 63, 192, 63, 192, 58, 192, 58, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 175, 255, 175, 255, 170, 170, 85, 85, 85, 95, 85, 250, 171, 170, 94, 169, 122, 164, 121, 80, 170, 127, 127, 166, 170, 149, 165, 64, 80, 0, 0, 21, 0, 64, 1, 21, 253, 170, 154, 253, 86, 170, 1, 90, 0, 5, 84, 0, 1, 0, 84, 64, 170, 170, 85, 85, 245, 85, 175, 85, 170, 234, 106, 181, 26, 173, 5, 109, 63, 255, 213, 85, 192, 0, 201, 85, 201, 0, 201, 0, 201, 0, 201, 0, 255, 252, 85, 87, 0, 0, 105, 106, 100, 26, 80, 6, 64, 1, 80, 6, 0, 3, 255, 252, 0, 48, 170, 232, 171, 2, 171, 112, 171, 127, 171, 127, 192, 0, 63, 252, 3, 195, 0, 55, 128, 175, 42, 175, 9, 175, 249, 175, 169, 220, 230, 212, 233, 240, 230, 192, 173, 0, 208, 0, 0, 0, 0, 0, 170, 170, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 170, 171, 175, 188, 186, 220, 174, 87, 171, 117, 173, 77, 189, 85, 195, 244, 234, 170, 62, 250, 55, 110, 213, 186, 93, 234, 113, 122, 85, 126, 159, 195, 0, 0, 255, 255, 192, 0, 197, 85, 197, 96, 197, 128, 197, 84, 197, 84, 0, 0, 255, 255, 0, 3, 85, 83, 21, 83, 69, 83, 5, 83, 33, 83, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 192, 58, 255, 255, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 173, 87, 255, 255, 214, 145, 234, 144, 233, 84, 214, 169, 234, 170, 250, 170, 218, 170, 222, 170, 81, 21, 0, 64, 0, 21, 0, 0, 80, 1, 165, 64, 170, 149, 170, 166, 84, 69, 1, 0, 84, 0, 0, 0, 64, 5, 1, 90, 86, 170, 154, 170, 70, 151, 6, 171, 21, 107, 106, 151, 170, 171, 170, 175, 170, 167, 170, 183, 201, 255, 202, 192, 202, 229, 202, 208, 202, 229, 202, 255, 202, 170, 255, 255, 255, 255, 0, 11, 153, 155, 68, 71, 153, 151, 255, 255, 170, 170, 255, 255, 111, 127, 251, 95, 107, 85, 106, 245, 106, 175, 106, 170, 170, 170, 255, 255, 57, 175, 249, 175, 249, 183, 89, 215, 91, 167, 254, 167, 170, 167, 255, 255, 128, 0, 32, 0, 8, 0, 2, 0, 8, 128, 32, 32, 128, 8, 0, 2, 128, 0, 32, 0, 63, 252, 238, 171, 238, 171, 204, 3, 204, 3, 204, 3, 201, 207, 183, 112, 175, 95, 183, 64, 231, 192, 237, 240, 236, 79, 235, 245, 243, 75, 13, 222, 245, 250, 1, 222, 3, 219, 15, 123, 241, 59, 95, 235, 197, 106, 197, 86, 197, 86, 192, 0, 255, 255, 170, 170, 170, 170, 255, 255, 169, 83, 168, 83, 170, 83, 0, 3, 255, 255, 170, 170, 170, 170, 255, 255, 128, 0, 32, 0, 63, 252, 234, 187, 234, 187, 192, 51, 192, 51, 192, 51, 128, 0, 32, 0, 0, 0, 255, 255, 85, 85, 255, 255, 170, 170, 0, 0, 215, 170, 213, 122, 213, 107, 213, 154, 213, 106, 245, 154, 245, 106, 253, 154, 170, 166, 170, 166, 170, 166, 190, 166, 170, 255, 170, 184, 250, 232, 251, 175, 154, 170, 154, 170, 154, 170, 154, 190, 255, 170, 46, 170, 43, 175, 250, 239, 170, 215, 173, 87, 233, 87, 166, 87, 169, 87, 166, 95, 169, 95, 166, 127, 213, 85, 255, 255, 221, 85, 221, 102, 223, 255, 220, 0, 252, 170, 156, 170, 85, 85, 255, 255, 85, 85, 170, 170, 255, 230, 0, 57, 170, 54, 170, 57, 255, 255, 192, 0, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 234, 170, 255, 255, 0, 3, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 170, 163, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 238, 175, 238, 173, 221, 93, 221, 87, 63, 252, 0, 0, 128, 8, 0, 2, 34, 47, 136, 240, 35, 0, 142, 10, 174, 170, 174, 170, 174, 165, 255, 154, 255, 255, 0, 0, 0, 0, 170, 170, 170, 170, 170, 170, 85, 85, 170, 170, 242, 34, 15, 136, 0, 226, 160, 184, 170, 186, 170, 186, 90, 186, 166, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 250, 187, 122, 187, 117, 119, 213, 119, 63, 252, 0, 0, 128, 8, 0, 2, 170, 170, 255, 255, 85, 85, 255, 255, 8, 128, 32, 32, 128, 8, 0, 2, 223, 106, 215, 250, 215, 255, 215, 159, 215, 106, 215, 154, 215, 106, 87, 154, 251, 181, 171, 191, 171, 181, 254, 239, 215, 250, 213, 95, 213, 85, 223, 245, 94, 239, 254, 234, 94, 234, 251, 191, 175, 215, 245, 87, 85, 126, 85, 122, 169, 247, 175, 215, 255, 215, 246, 215, 169, 215, 230, 215, 233, 215, 230, 213, 12, 170, 12, 170, 12, 0, 14, 170, 14, 255, 14, 213, 14, 234, 15, 234, 170, 48, 170, 48, 0, 48, 170, 176, 255, 176, 87, 176, 171, 176, 171, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 255, 12, 0, 12, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 192, 0, 48, 170, 48, 230, 170, 245, 170, 237, 106, 235, 90, 235, 214, 235, 117, 235, 93, 235, 215, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 50, 234, 50, 234, 50, 234, 58, 234, 58, 226, 15, 88, 0, 245, 0, 15, 170, 170, 170, 170, 170, 170, 170, 170, 34, 34, 136, 136, 85, 85, 255, 255, 171, 140, 171, 140, 171, 140, 171, 172, 43, 172, 133, 240, 95, 0, 240, 0, 34, 34, 136, 136, 34, 34, 136, 136, 170, 170, 170, 170, 170, 170, 255, 255, 106, 170, 154, 170, 166, 170, 169, 170, 166, 106, 154, 154, 106, 166, 170, 169, 0, 0, 85, 85, 170, 170, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 0, 0, 170, 170, 85, 85, 0, 0, 0, 3, 0, 12, 0, 50, 0, 202, 3, 42, 12, 170, 50, 170, 202, 170, 192, 0, 48, 0, 140, 0, 163, 0, 168, 192, 170, 48, 170, 140, 170, 163, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 85, 85, 255, 255, 213, 87, 229, 91, 229, 91, 229, 91, 229, 91, 191, 254, 85, 85, 255, 255, 85, 85, 255, 255, 170, 170, 170, 170, 170, 170, 0, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 235, 181, 57, 237, 15, 251, 0, 94, 0, 23, 0, 5, 0, 1, 0, 0, 55, 106, 23, 154, 15, 106, 3, 154, 0, 122, 0, 7, 0, 0, 0, 0, 170, 155, 170, 95, 169, 123, 165, 235, 151, 235, 93, 235, 117, 235, 215, 235, 94, 235, 123, 108, 239, 240, 181, 0, 212, 0, 80, 0, 64, 0, 0, 0, 170, 170, 128, 0, 128, 0, 128, 1, 128, 5, 128, 21, 128, 84, 129, 80, 170, 170, 0, 2, 0, 2, 64, 2, 80, 2, 84, 2, 21, 2, 5, 66, 129, 80, 128, 84, 128, 21, 128, 5, 128, 1, 128, 0, 128, 0, 170, 170, 5, 66, 21, 2, 84, 2, 80, 2, 64, 2, 0, 2, 0, 2, 170, 170, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 170, 170, 255, 255, 85, 85, 170, 170, 85, 85, 85, 85, 170, 170, 85, 85, 255, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 255, 229, 85, 234, 170, 229, 85, 229, 85, 234, 170, 229, 85, 255, 255, 255, 255, 85, 91, 170, 171, 85, 91, 85, 91, 170, 171, 85, 91, 255, 255, 0, 2, 0, 8, 255, 255, 234, 171, 234, 171, 255, 255, 213, 87, 255, 255, 213, 87, 213, 87, 213, 87, 255, 255, 213, 87, 255, 255, 32, 8, 128, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, lab: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [34, 34, 34, 34, 34, 34, 34, 34, 1, 38, 1, 38, 38, 1, 38, 1] }, { type: "Buffer", data: [64, 66, 64, 66, 10, 11, 10, 11, 10, 11, 10, 11, 26, 27, 26, 27] }, { type: "Buffer", data: [34, 34, 16, 17, 34, 34, 32, 33, 1, 38, 1, 38, 38, 1, 38, 1] }, { type: "Buffer", data: [34, 34, 34, 34, 34, 34, 34, 34, 48, 49, 48, 49, 34, 34, 34, 34] }, { type: "Buffer", data: [34, 34, 64, 66, 34, 34, 40, 41, 48, 49, 40, 41, 34, 34, 40, 41] }, { type: "Buffer", data: [64, 66, 64, 66, 40, 41, 40, 41, 40, 41, 40, 41, 40, 41, 40, 41] }, { type: "Buffer", data: [1, 38, 1, 38, 38, 1, 38, 1, 1, 38, 1, 38, 38, 1, 38, 1] }, { type: "Buffer", data: [2, 3, 4, 5, 18, 19, 20, 21, 6, 7, 8, 9, 22, 23, 38, 1] }, { type: "Buffer", data: [44, 45, 34, 34, 60, 61, 34, 34, 46, 47, 1, 38, 62, 63, 38, 1] }, { type: "Buffer", data: [34, 34, 44, 45, 34, 34, 60, 61, 1, 38, 46, 47, 38, 1, 62, 63] }, { type: "Buffer", data: [12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13] }, { type: "Buffer", data: [1, 38, 1, 38, 38, 1, 38, 1, 39, 39, 39, 39, 55, 55, 55, 55] }, { type: "Buffer", data: [44, 45, 1, 38, 60, 61, 38, 1, 46, 47, 1, 38, 62, 63, 38, 1] }, { type: "Buffer", data: [1, 38, 44, 45, 38, 1, 60, 61, 1, 38, 46, 47, 38, 1, 62, 63] }, { type: "Buffer", data: [64, 65, 65, 66, 80, 81, 81, 82, 80, 72, 73, 82, 83, 58, 58, 84] }, { type: "Buffer", data: [1, 38, 14, 15, 38, 1, 30, 31, 1, 38, 64, 65, 38, 1, 80, 81] }, { type: "Buffer", data: [1, 38, 14, 15, 38, 1, 30, 31, 65, 65, 65, 66, 81, 81, 81, 82] }, { type: "Buffer", data: [69, 69, 70, 69, 85, 85, 86, 85, 10, 11, 75, 10, 26, 27, 91, 26] }, { type: "Buffer", data: [69, 70, 69, 69, 85, 86, 85, 85, 11, 75, 10, 11, 27, 91, 26, 27] }, { type: "Buffer", data: [1, 38, 80, 81, 38, 1, 83, 58, 1, 38, 14, 15, 38, 1, 30, 31] }, { type: "Buffer", data: [81, 81, 81, 82, 58, 58, 58, 84, 1, 38, 14, 15, 38, 1, 30, 31] }, { type: "Buffer", data: [69, 70, 69, 59, 85, 86, 85, 59, 74, 75, 74, 59, 90, 91, 90, 59] }, { type: "Buffer", data: [54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54] }, { type: "Buffer", data: [76, 77, 24, 25, 52, 53, 34, 34, 1, 38, 1, 38, 38, 1, 38, 1] }, { type: "Buffer", data: [35, 34, 34, 34, 35, 34, 34, 34, 1, 38, 1, 38, 38, 1, 38, 1] }, { type: "Buffer", data: [28, 81, 81, 81, 28, 81, 81, 81, 28, 81, 81, 81, 28, 81, 81, 81] }, { type: "Buffer", data: [81, 81, 81, 29, 81, 81, 81, 29, 81, 81, 81, 29, 81, 81, 81, 29] }, { type: "Buffer", data: [81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81] }, { type: "Buffer", data: [1, 38, 50, 51, 38, 1, 67, 68, 1, 38, 50, 51, 38, 1, 67, 68] }, { type: "Buffer", data: [50, 51, 50, 51, 67, 68, 67, 68, 1, 38, 50, 51, 38, 1, 67, 68] }, { type: "Buffer", data: [56, 56, 1, 38, 57, 57, 38, 1, 56, 56, 1, 38, 57, 57, 38, 1] }, { type: "Buffer", data: [87, 88, 88, 89, 28, 71, 71, 29, 36, 24, 25, 37, 42, 34, 34, 43] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [1, 38, 1, 38, 38, 1, 38, 1, 56, 56, 1, 38, 57, 57, 38, 1] }, { type: "Buffer", data: [1, 38, 1, 38, 38, 1, 38, 1, 1, 38, 64, 65, 38, 1, 42, 34] }, { type: "Buffer", data: [56, 56, 56, 56, 57, 57, 57, 57, 65, 65, 65, 65, 34, 34, 34, 34] }, { type: "Buffer", data: [56, 56, 56, 56, 57, 57, 57, 57, 65, 65, 65, 65, 34, 34, 34, 34] }, { type: "Buffer", data: [56, 56, 1, 38, 57, 57, 38, 1, 65, 65, 65, 66, 34, 34, 34, 43] }, { type: "Buffer", data: [2, 3, 4, 5, 18, 19, 20, 21, 6, 7, 8, 9, 22, 23, 38, 1] }, { type: "Buffer", data: [64, 65, 65, 66, 80, 72, 73, 82, 6, 7, 8, 9, 22, 23, 38, 1] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [34, 34, 87, 88, 34, 34, 28, 81, 1, 38, 28, 81, 38, 1, 28, 81] }, { type: "Buffer", data: [88, 88, 88, 88, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81] }, { type: "Buffer", data: [88, 88, 88, 88, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81] }, { type: "Buffer", data: [88, 89, 34, 34, 81, 29, 34, 34, 81, 29, 1, 38, 81, 29, 38, 1] }, { type: "Buffer", data: [1, 38, 28, 81, 38, 1, 36, 78, 1, 38, 36, 78, 38, 1, 42, 34] }, { type: "Buffer", data: [81, 81, 81, 81, 78, 78, 78, 78, 78, 78, 78, 78, 34, 34, 34, 34] }, { type: "Buffer", data: [81, 81, 81, 81, 78, 78, 78, 78, 78, 78, 24, 25, 34, 34, 34, 34] }, { type: "Buffer", data: [81, 29, 1, 38, 78, 37, 38, 1, 78, 37, 1, 38, 34, 43, 38, 1] }, { type: "Buffer", data: [1, 38, 1, 38, 38, 1, 38, 1, 65, 65, 65, 66, 34, 34, 34, 43] }, { type: "Buffer", data: [34, 34, 34, 34, 34, 34, 34, 34, 14, 15, 1, 38, 30, 31, 38, 1] }, { type: "Buffer", data: [1, 38, 1, 38, 38, 1, 38, 1, 64, 65, 65, 65, 42, 34, 34, 34] }, { type: "Buffer", data: [1, 38, 1, 38, 38, 1, 38, 1, 65, 65, 65, 65, 34, 34, 34, 34] }, { type: "Buffer", data: [1, 38, 64, 65, 38, 1, 80, 81, 1, 38, 80, 81, 38, 1, 83, 58] }, { type: "Buffer", data: [65, 65, 65, 66, 81, 81, 81, 82, 81, 81, 81, 82, 58, 58, 58, 84] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 63, 255, 213, 85, 192, 0, 201, 85, 201, 0, 201, 0, 201, 0, 201, 0, 255, 252, 85, 87, 0, 0, 105, 106, 100, 26, 80, 6, 64, 1, 80, 6, 0, 3, 255, 252, 0, 48, 170, 232, 171, 2, 171, 112, 171, 127, 171, 127, 192, 0, 63, 252, 3, 195, 0, 55, 128, 175, 42, 175, 9, 175, 249, 175, 213, 85, 255, 255, 221, 85, 221, 102, 221, 191, 253, 192, 102, 194, 153, 194, 85, 85, 255, 255, 85, 85, 170, 170, 255, 254, 0, 3, 170, 131, 170, 131, 93, 213, 253, 213, 93, 255, 157, 213, 109, 213, 159, 255, 102, 102, 153, 153, 85, 119, 85, 119, 255, 247, 85, 119, 85, 119, 255, 255, 170, 170, 170, 170, 213, 85, 223, 255, 223, 95, 221, 247, 221, 247, 223, 95, 223, 255, 213, 85, 85, 87, 255, 247, 245, 247, 223, 119, 223, 119, 245, 247, 255, 247, 85, 87, 153, 153, 25, 153, 153, 153, 38, 102, 134, 100, 38, 102, 153, 152, 25, 146, 6, 100, 6, 100, 6, 100, 1, 144, 1, 144, 1, 144, 6, 100, 6, 100, 0, 0, 0, 0, 3, 255, 12, 0, 12, 42, 12, 42, 12, 42, 12, 0, 0, 0, 0, 0, 255, 192, 0, 48, 168, 48, 168, 48, 168, 48, 0, 48, 0, 0, 255, 255, 192, 0, 197, 95, 197, 122, 197, 224, 197, 192, 197, 212, 0, 0, 255, 255, 0, 3, 245, 83, 173, 83, 11, 83, 3, 83, 23, 83, 201, 255, 202, 192, 202, 229, 202, 208, 202, 229, 202, 255, 202, 170, 255, 255, 255, 255, 0, 11, 153, 155, 68, 71, 153, 151, 255, 255, 170, 170, 255, 255, 111, 127, 251, 95, 107, 85, 106, 245, 106, 175, 106, 170, 170, 170, 255, 255, 57, 175, 249, 175, 249, 183, 89, 215, 91, 167, 254, 167, 170, 167, 255, 255, 0, 194, 0, 192, 0, 234, 0, 239, 0, 237, 0, 239, 0, 238, 0, 255, 170, 131, 0, 3, 170, 171, 255, 251, 85, 123, 255, 251, 170, 187, 255, 255, 63, 255, 48, 0, 51, 51, 48, 0, 51, 255, 51, 51, 48, 0, 63, 255, 255, 252, 0, 12, 204, 204, 0, 12, 255, 204, 204, 204, 0, 12, 255, 252, 255, 255, 213, 85, 213, 85, 213, 85, 213, 85, 213, 85, 221, 213, 255, 255, 255, 255, 85, 87, 85, 87, 85, 87, 85, 87, 85, 87, 87, 119, 255, 255, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 74, 170, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 170, 161, 14, 170, 14, 255, 14, 213, 14, 255, 14, 234, 15, 255, 0, 0, 0, 0, 170, 176, 255, 176, 87, 176, 255, 176, 171, 176, 255, 240, 0, 0, 0, 0, 197, 192, 197, 114, 197, 87, 192, 0, 255, 255, 85, 85, 85, 85, 255, 255, 3, 83, 141, 83, 213, 83, 0, 3, 255, 255, 85, 85, 85, 85, 255, 255, 85, 85, 85, 85, 85, 85, 255, 255, 85, 85, 85, 85, 85, 85, 255, 255, 229, 85, 229, 85, 229, 85, 255, 255, 229, 85, 229, 85, 229, 85, 255, 255, 72, 136, 66, 34, 72, 136, 66, 34, 72, 136, 66, 34, 72, 136, 66, 34, 136, 129, 34, 33, 136, 129, 34, 33, 136, 129, 34, 33, 136, 129, 34, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 0, 0, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 218, 170, 223, 255, 222, 187, 222, 179, 220, 51, 223, 251, 223, 255, 218, 170, 170, 167, 255, 247, 174, 183, 12, 55, 12, 55, 255, 247, 255, 247, 170, 167, 223, 255, 218, 171, 218, 171, 218, 171, 218, 171, 255, 255, 218, 170, 191, 255, 255, 247, 234, 167, 234, 167, 234, 167, 234, 167, 255, 255, 170, 167, 255, 254, 12, 0, 51, 192, 60, 188, 225, 59, 60, 91, 226, 85, 61, 127, 255, 235, 0, 48, 3, 236, 60, 143, 238, 19, 100, 124, 215, 171, 250, 124, 215, 192, 0, 11, 0, 0, 0, 13, 0, 254, 3, 116, 0, 249, 14, 244, 14, 253, 112, 0, 176, 0, 112, 0, 191, 0, 157, 192, 111, 0, 159, 176, 127, 176, 255, 255, 3, 172, 142, 251, 46, 251, 141, 167, 47, 95, 139, 255, 34, 254, 255, 255, 0, 0, 255, 8, 85, 226, 127, 136, 234, 34, 136, 136, 34, 34, 136, 143, 35, 242, 158, 232, 46, 162, 187, 120, 54, 231, 189, 153, 230, 103, 200, 136, 63, 34, 141, 200, 38, 226, 155, 120, 117, 114, 157, 244, 119, 126, 123, 255, 122, 170, 122, 170, 122, 170, 122, 170, 122, 170, 127, 255, 240, 0, 255, 237, 170, 173, 168, 45, 168, 45, 170, 173, 170, 173, 255, 253, 0, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 0, 0, 85, 85, 15, 240, 60, 60, 48, 12, 52, 28, 54, 156, 54, 156, 54, 156, 54, 156, 54, 156, 54, 156, 54, 156, 54, 156, 54, 156, 190, 190, 175, 250, 42, 168, 255, 255, 85, 85, 255, 255, 170, 170, 170, 170, 170, 170, 170, 170, 0, 0, 255, 255, 255, 255, 117, 93, 154, 166, 32, 8, 154, 166, 117, 93, 255, 255, 190, 150, 227, 22, 56, 78, 225, 39, 248, 223, 235, 239, 59, 119, 46, 239, 182, 188, 81, 227, 216, 76, 209, 19, 247, 159, 251, 235, 253, 236, 51, 48, 13, 191, 13, 106, 3, 82, 7, 127, 7, 90, 5, 210, 1, 127, 0, 21, 254, 112, 169, 112, 85, 192, 253, 208, 85, 208, 87, 80, 253, 64, 84, 0, 63, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 252, 0, 3, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 245, 93, 223, 85, 125, 221, 55, 127, 143, 223, 39, 253, 137, 118, 34, 95, 221, 220, 119, 94, 221, 248, 127, 114, 255, 216, 127, 98, 157, 68, 245, 34, 255, 255, 213, 87, 213, 87, 230, 103, 217, 155, 230, 103, 217, 155, 234, 171, 85, 85, 255, 255, 85, 85, 255, 255, 255, 255, 102, 102, 255, 255, 255, 255, 175, 250, 181, 94, 213, 87, 245, 95, 207, 243, 192, 3, 192, 3, 191, 254, 85, 85, 64, 0, 69, 80, 69, 80, 64, 0, 74, 168, 64, 0, 85, 85, 105, 170, 100, 106, 80, 26, 64, 6, 64, 6, 80, 26, 100, 106, 105, 170, 192, 3, 192, 3, 226, 35, 200, 139, 226, 35, 234, 171, 234, 171, 234, 171, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 170, 170, 255, 255, 127, 255, 122, 170, 123, 255, 123, 85, 123, 85, 123, 85, 123, 85, 123, 85, 255, 253, 170, 173, 255, 237, 85, 237, 85, 237, 85, 237, 85, 237, 85, 237, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 255, 255, 213, 85, 255, 255, 213, 234, 202, 234, 202, 234, 127, 106, 0, 0, 255, 255, 85, 87, 255, 255, 171, 87, 171, 171, 171, 171, 169, 253, 0, 0, 234, 171, 234, 171, 234, 171, 226, 35, 200, 139, 226, 35, 192, 3, 192, 3, 255, 255, 170, 170, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 85, 85, 64, 0, 68, 68, 65, 17, 68, 69, 65, 21, 68, 85, 65, 85, 85, 85, 0, 0, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 0, 1, 85, 81, 85, 81, 85, 81, 85, 81, 85, 81, 85, 81, 234, 171, 217, 155, 230, 103, 217, 155, 230, 103, 213, 87, 213, 87, 255, 255, 255, 255, 255, 255, 102, 102, 255, 255, 255, 255, 85, 85, 255, 255, 85, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, lobby: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 33, 33, 33, 33] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 12, 13, 1, 1, 28, 29, 33, 33] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 10, 11, 1, 1, 26, 27, 33, 33] }, { type: "Buffer", data: [36, 37, 14, 15, 52, 53, 30, 31, 48, 21, 21, 21, 32, 32, 32, 32] }, { type: "Buffer", data: [39, 39, 36, 37, 55, 55, 52, 53, 21, 21, 21, 21, 32, 32, 32, 32] }, { type: "Buffer", data: [14, 15, 32, 32, 30, 31, 32, 32, 21, 49, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 18, 19, 18, 19] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [32, 32, 7, 8, 32, 32, 23, 24, 32, 32, 7, 8, 32, 32, 23, 24] }, { type: "Buffer", data: [42, 43, 44, 45, 58, 59, 60, 61, 64, 65, 66, 67, 80, 81, 82, 83] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 40, 40, 33, 33, 56, 56] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 22, 33, 33, 33] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 14, 15, 14, 15, 30, 31, 30, 31] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [38, 39, 39, 39, 54, 57, 21, 21, 54, 57, 32, 32, 54, 57, 32, 32] }, { type: "Buffer", data: [39, 39, 39, 39, 21, 21, 21, 21, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [34, 35, 34, 35, 50, 51, 50, 51, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [54, 57, 32, 32, 54, 57, 32, 32, 54, 57, 32, 32, 54, 57, 32, 32] }, { type: "Buffer", data: [38, 39, 39, 39, 48, 21, 21, 21, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [39, 39, 39, 41, 21, 21, 21, 49, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [32, 32, 54, 57, 32, 32, 54, 57, 32, 32, 54, 57, 32, 32, 54, 57] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 38, 41, 33, 33] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 33, 33, 38, 41] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 42, 43, 44, 45, 58, 59, 60, 61] }, { type: "Buffer", data: [38, 41, 38, 41, 34, 35, 34, 35, 34, 35, 34, 35, 50, 51, 50, 51] }, { type: "Buffer", data: [68, 68, 68, 68, 84, 84, 84, 84, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [9, 39, 39, 25, 54, 55, 55, 57, 70, 55, 55, 71, 85, 86, 87, 55] }, { type: "Buffer", data: [64, 65, 66, 67, 80, 81, 82, 83, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [7, 8, 55, 69, 23, 24, 69, 55, 7, 8, 55, 69, 23, 24, 69, 55] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [55, 69, 7, 8, 69, 55, 23, 24, 55, 69, 7, 8, 69, 55, 23, 24] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 38, 41, 38, 41, 34, 35, 34, 35] }, { type: "Buffer", data: [34, 35, 34, 35, 50, 51, 50, 51, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 72, 73, 1, 1, 88, 89, 33, 33] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 46, 47, 1, 1, 33, 33, 33, 33] }, { type: "Buffer", data: [39, 39, 46, 47, 21, 21, 21, 49, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [39, 39, 39, 41, 21, 21, 54, 57, 32, 32, 54, 57, 32, 32, 54, 57] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 55, 69, 4, 4, 69, 55, 20, 20] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 4, 4, 55, 69, 20, 20, 69, 55] }, { type: "Buffer", data: [1, 1, 1, 1, 33, 33, 33, 33, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [1, 1, 62, 1, 33, 33, 63, 33, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [1, 1, 1, 1, 33, 33, 33, 33, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [7, 8, 7, 8, 23, 24, 23, 24, 9, 39, 39, 25, 54, 55, 55, 57] }, { type: "Buffer", data: [1, 1, 1, 1, 33, 33, 33, 33, 55, 69, 7, 8, 69, 55, 23, 24] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 39, 39, 39, 39, 21, 21, 21, 21] }, { type: "Buffer", data: [1, 1, 1, 1, 33, 33, 33, 33, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [70, 55, 55, 71, 85, 86, 87, 55, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [1, 1, 1, 1, 38, 41, 33, 33, 54, 57, 32, 32, 54, 57, 32, 32] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 39, 39, 39, 41, 21, 21, 21, 21] }, { type: "Buffer", data: [1, 1, 72, 73, 33, 33, 88, 89, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [40, 40, 1, 1, 56, 56, 33, 33, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [79, 79, 79, 76, 79, 79, 79, 76, 79, 79, 79, 76, 79, 79, 79, 76] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 68, 68, 68, 68, 84, 84, 84, 84] }, { type: "Buffer", data: [75, 76, 75, 76, 75, 76, 75, 76, 75, 76, 75, 76, 77, 78, 77, 78] }, { type: "Buffer", data: [54, 57, 54, 57, 54, 57, 54, 57, 54, 57, 54, 57, 54, 57, 54, 57] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 38, 41, 38, 41, 54, 57, 54, 57] }, { type: "Buffer", data: [39, 41, 55, 55, 54, 57, 55, 55, 38, 41, 55, 55, 34, 35, 91, 91] }, { type: "Buffer", data: [34, 35, 46, 47, 50, 51, 33, 33, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [39, 39, 39, 39, 21, 21, 21, 21, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 91, 91, 91, 91] }, { type: "Buffer", data: [55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 10, 11, 91, 91] }, { type: "Buffer", data: [75, 79, 79, 79, 75, 79, 79, 79, 75, 79, 79, 79, 75, 79, 79, 79] }, { type: "Buffer", data: [79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79] }, { type: "Buffer", data: [1, 1, 10, 11, 33, 33, 26, 27, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [92, 92, 92, 92, 93, 93, 93, 93, 75, 76, 1, 62, 75, 76, 33, 63] }, { type: "Buffer", data: [92, 92, 92, 92, 93, 93, 93, 93, 1, 1, 1, 1, 33, 33, 33, 33] }, { type: "Buffer", data: [55, 69, 55, 69, 69, 55, 69, 55, 92, 92, 92, 92, 93, 93, 93, 93] }, { type: "Buffer", data: [92, 92, 92, 92, 93, 93, 93, 93, 1, 1, 75, 76, 33, 33, 75, 76] }, { type: "Buffer", data: [75, 76, 55, 69, 75, 76, 69, 55, 92, 92, 92, 92, 93, 93, 93, 93] }, { type: "Buffer", data: [55, 69, 75, 76, 69, 55, 75, 76, 92, 92, 92, 92, 93, 93, 93, 93] }, { type: "Buffer", data: [75, 76, 55, 69, 75, 76, 69, 55, 75, 76, 55, 69, 75, 76, 69, 55] }, { type: "Buffer", data: [55, 69, 75, 76, 69, 55, 75, 76, 55, 69, 75, 76, 69, 55, 75, 76] }, { type: "Buffer", data: [4, 4, 4, 4, 20, 20, 20, 20, 55, 69, 55, 69, 69, 55, 69, 55] }, { type: "Buffer", data: [92, 92, 92, 92, 93, 93, 93, 93, 40, 40, 40, 40, 56, 56, 56, 56] }, { type: "Buffer", data: [55, 69, 1, 1, 69, 55, 33, 33, 55, 69, 55, 69, 69, 55, 69, 55] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 136, 0, 34, 0, 136, 0, 0, 34, 0, 136, 0, 34, 0, 136, 0, 255, 3, 170, 15, 234, 58, 186, 48, 186, 48, 181, 250, 180, 245, 119, 255, 0, 170, 192, 170, 48, 170, 48, 170, 48, 85, 112, 204, 127, 255, 123, 0, 0, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 85, 85, 255, 255, 85, 85, 85, 85, 85, 85, 255, 255, 34, 0, 136, 0, 34, 0, 136, 0, 63, 254, 48, 12, 49, 78, 48, 12, 42, 168, 138, 162, 162, 138, 168, 42, 171, 255, 172, 0, 140, 42, 44, 42, 42, 168, 138, 162, 162, 138, 168, 42, 255, 234, 0, 58, 168, 50, 168, 56, 0, 3, 0, 12, 0, 50, 0, 202, 3, 42, 12, 170, 50, 170, 202, 170, 255, 255, 255, 255, 255, 255, 255, 255, 247, 119, 221, 221, 247, 119, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 119, 119, 221, 223, 119, 119, 255, 255, 255, 255, 234, 170, 234, 170, 234, 170, 255, 255, 192, 0, 192, 0, 192, 0, 255, 255, 170, 167, 170, 167, 170, 167, 255, 255, 42, 167, 10, 167, 2, 167, 255, 255, 50, 170, 191, 255, 202, 170, 202, 170, 213, 85, 223, 255, 220, 0, 255, 255, 170, 175, 255, 255, 170, 171, 170, 171, 85, 87, 255, 247, 0, 55, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 213, 85, 63, 255, 53, 122, 58, 186, 58, 186, 58, 186, 15, 192, 245, 116, 245, 119, 245, 116, 245, 117, 207, 215, 195, 87, 192, 255, 192, 0, 204, 119, 255, 119, 204, 119, 85, 119, 245, 119, 245, 123, 255, 235, 0, 3, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 0, 0, 85, 85, 255, 255, 85, 85, 255, 255, 255, 255, 255, 255, 85, 85, 255, 255, 48, 12, 177, 76, 48, 12, 191, 252, 0, 2, 136, 136, 34, 34, 255, 255, 44, 42, 140, 0, 174, 170, 174, 255, 174, 213, 174, 229, 143, 217, 42, 168, 168, 56, 0, 50, 170, 186, 255, 186, 87, 186, 91, 186, 103, 242, 42, 168, 192, 0, 48, 0, 140, 0, 163, 0, 168, 192, 170, 48, 170, 140, 170, 167, 213, 90, 213, 106, 213, 170, 255, 255, 192, 0, 192, 0, 192, 0, 192, 0, 170, 171, 170, 171, 170, 171, 255, 255, 0, 11, 0, 11, 0, 11, 0, 11, 255, 255, 192, 0, 192, 0, 192, 0, 255, 255, 234, 170, 234, 170, 234, 170, 255, 255, 2, 167, 0, 167, 0, 39, 255, 255, 170, 167, 170, 167, 170, 167, 220, 84, 220, 0, 220, 85, 220, 106, 220, 106, 223, 255, 213, 213, 255, 255, 40, 55, 40, 55, 85, 55, 169, 55, 169, 55, 255, 247, 87, 87, 255, 255, 42, 168, 138, 162, 162, 138, 168, 42, 168, 42, 162, 138, 138, 162, 42, 168, 34, 0, 136, 0, 34, 0, 136, 0, 34, 34, 136, 136, 34, 34, 255, 255, 218, 170, 223, 255, 222, 186, 220, 48, 220, 48, 223, 255, 223, 255, 218, 170, 170, 167, 255, 247, 174, 183, 12, 55, 12, 55, 255, 247, 255, 247, 170, 167, 255, 255, 195, 255, 237, 0, 237, 149, 237, 255, 236, 0, 236, 106, 236, 0, 255, 255, 240, 0, 30, 170, 158, 170, 222, 170, 14, 170, 78, 170, 14, 170, 255, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 213, 87, 213, 87, 213, 87, 213, 87, 213, 87, 213, 87, 213, 87, 255, 255, 0, 3, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 139, 255, 62, 2, 223, 255, 222, 2, 223, 255, 222, 2, 255, 255, 192, 0, 3, 243, 252, 60, 223, 255, 220, 60, 223, 255, 220, 60, 255, 255, 0, 0, 251, 255, 14, 2, 255, 255, 14, 2, 255, 255, 14, 2, 255, 255, 0, 0, 15, 240, 252, 60, 223, 243, 220, 51, 223, 243, 220, 51, 255, 255, 0, 3, 255, 255, 192, 0, 204, 192, 204, 243, 192, 0, 207, 255, 192, 0, 255, 255, 255, 255, 0, 3, 12, 243, 204, 195, 0, 3, 255, 243, 0, 3, 255, 255, 213, 85, 255, 255, 213, 85, 255, 255, 223, 255, 223, 255, 213, 85, 255, 255, 85, 87, 255, 255, 85, 87, 255, 255, 255, 247, 255, 247, 85, 87, 255, 255, 213, 85, 255, 255, 203, 234, 203, 234, 203, 213, 255, 255, 213, 85, 191, 255, 85, 87, 255, 255, 171, 227, 171, 227, 87, 227, 255, 255, 85, 87, 255, 254, 237, 85, 215, 255, 231, 85, 235, 171, 234, 254, 234, 170, 234, 170, 234, 170, 94, 250, 247, 14, 108, 71, 240, 3, 197, 62, 197, 234, 176, 234, 175, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 230, 103, 217, 155, 230, 103, 217, 155, 234, 171, 234, 171, 234, 171, 255, 255, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 192, 0, 213, 85, 207, 255, 207, 255, 204, 3, 206, 171, 206, 171, 223, 255, 0, 0, 85, 85, 255, 255, 213, 253, 64, 116, 21, 49, 192, 252, 255, 255, 0, 0, 85, 85, 255, 255, 95, 255, 7, 3, 83, 171, 15, 87, 255, 255, 0, 3, 85, 87, 255, 243, 170, 179, 255, 243, 0, 51, 170, 179, 255, 247, 255, 255, 192, 3, 196, 83, 196, 83, 192, 3, 196, 83, 196, 83, 192, 3, 192, 3, 196, 83, 196, 83, 192, 3, 255, 255, 136, 136, 34, 34, 255, 255, 192, 0, 255, 255, 223, 255, 237, 7, 239, 255, 238, 171, 223, 255, 192, 0, 0, 0, 255, 255, 93, 127, 93, 125, 12, 63, 12, 60, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 13, 7, 255, 255, 44, 11, 255, 255, 0, 0, 0, 3, 255, 255, 93, 119, 93, 123, 174, 187, 12, 59, 255, 247, 0, 3, 255, 255, 0, 0, 170, 170, 255, 255, 221, 119, 181, 94, 237, 91, 123, 237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 170, 218, 170, 54, 170, 13, 170, 3, 106, 0, 218, 0, 54, 0, 13, 170, 167, 170, 167, 170, 156, 170, 112, 169, 192, 167, 0, 156, 0, 112, 0, 85, 85, 64, 0, 74, 149, 74, 85, 73, 85, 69, 85, 69, 86, 64, 0, 85, 85, 0, 1, 85, 81, 85, 81, 101, 81, 169, 81, 170, 81, 0, 1, 221, 221, 119, 119, 221, 221, 119, 119, 221, 221, 119, 119, 221, 221, 119, 119, 203, 85, 203, 85, 203, 85, 203, 85, 203, 85, 203, 85, 203, 85, 203, 85, 85, 227, 85, 227, 85, 227, 85, 227, 85, 227, 85, 227, 85, 227, 85, 227, 203, 85, 203, 85, 203, 85, 203, 85, 203, 85, 203, 85, 203, 85, 127, 255, 85, 227, 85, 227, 85, 227, 85, 227, 85, 227, 85, 227, 85, 227, 255, 253, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 221, 117, 239, 255, 236, 48, 239, 255, 223, 255, 192, 0, 255, 255, 255, 255, 213, 117, 255, 250, 234, 176, 192, 63, 255, 255, 0, 0, 255, 255, 255, 255, 117, 117, 186, 181, 48, 63, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 213, 119, 255, 251, 197, 123, 202, 187, 255, 247, 0, 3, 255, 255, 94, 181, 94, 181, 123, 237, 237, 123, 53, 94, 205, 115, 179, 204, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 255, 255, 218, 181, 218, 175, 58, 0, 12, 0, 3, 192, 0, 63, 85, 85, 255, 255, 94, 171, 250, 171, 0, 172, 0, 48, 3, 192, 253, 0, 69, 0, 69, 17, 68, 81, 64, 0, 85, 85, 136, 136, 34, 34, 255, 255, 0, 81, 68, 81, 69, 17, 0, 1, 85, 85, 136, 136, 34, 34, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 34, 136, 136, 34, 34, 136, 136, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 170, 170, 255, 255, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 170, 170, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, mansion: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 12, 13, 1, 1, 28, 29, 1, 1] }, { type: "Buffer", data: [81, 82, 74, 75, 83, 84, 74, 75, 1, 1, 74, 75, 1, 1, 74, 75] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 1, 1, 12, 13, 1, 1, 28, 29] }, { type: "Buffer", data: [17, 17, 74, 75, 17, 17, 74, 75, 17, 17, 74, 75, 17, 17, 74, 75] }, { type: "Buffer", data: [76, 76, 76, 76, 30, 30, 30, 30, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [76, 76, 72, 73, 30, 30, 88, 89, 17, 17, 74, 75, 17, 17, 74, 75] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [17, 17, 74, 75, 5, 5, 74, 75, 1, 1, 74, 75, 1, 1, 90, 91] }, { type: "Buffer", data: [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32] }, { type: "Buffer", data: [36, 37, 52, 53, 64, 65, 66, 67, 2, 3, 85, 86, 18, 19, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 76, 76, 76, 76, 30, 30, 30, 30] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 76, 76, 76, 77, 22, 23, 30, 93] }, { type: "Buffer", data: [76, 76, 76, 76, 30, 30, 30, 30, 36, 37, 52, 53, 64, 65, 66, 67] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [38, 39, 39, 41, 54, 55, 55, 57, 54, 55, 55, 57, 60, 58, 58, 59] }, { type: "Buffer", data: [38, 41, 38, 41, 34, 35, 34, 35, 34, 35, 34, 35, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 17, 68, 69, 17, 17, 8, 9, 17, 17, 70, 71, 17, 17, 24, 25] }, { type: "Buffer", data: [68, 69, 74, 75, 8, 9, 74, 75, 70, 71, 74, 75, 24, 25, 90, 91] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 10, 11, 1, 1, 26, 27, 1, 1] }, { type: "Buffer", data: [80, 80, 74, 75, 80, 80, 74, 75, 12, 13, 74, 75, 28, 29, 74, 75] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 12, 13, 1, 1, 28, 29, 1, 1] }, { type: "Buffer", data: [80, 80, 74, 75, 80, 80, 74, 75, 10, 11, 74, 75, 26, 27, 74, 75] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 10, 11, 12, 13, 26, 27, 28, 29] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 12, 13, 10, 11, 28, 29, 26, 27] }, { type: "Buffer", data: [38, 41, 72, 73, 34, 35, 88, 89, 34, 35, 74, 75, 50, 51, 74, 75] }, { type: "Buffer", data: [76, 76, 44, 92, 30, 30, 74, 75, 10, 11, 74, 75, 26, 27, 74, 75] }, { type: "Buffer", data: [76, 76, 44, 79, 30, 30, 74, 75, 1, 1, 74, 75, 1, 1, 74, 75] }, { type: "Buffer", data: [1, 1, 74, 75, 1, 1, 74, 75, 1, 1, 74, 75, 1, 1, 74, 75] }, { type: "Buffer", data: [1, 1, 74, 75, 1, 1, 74, 75, 15, 33, 74, 75, 31, 49, 90, 91] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 15, 15, 15, 15, 31, 31, 31, 31] }, { type: "Buffer", data: [74, 75, 1, 1, 74, 75, 1, 1, 74, 75, 42, 15, 90, 91, 43, 31] }, { type: "Buffer", data: [74, 75, 38, 39, 74, 75, 54, 55, 74, 75, 54, 55, 74, 75, 54, 55] }, { type: "Buffer", data: [39, 39, 39, 41, 55, 55, 55, 57, 55, 55, 55, 57, 55, 55, 55, 57] }, { type: "Buffer", data: [2, 3, 85, 86, 18, 19, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [76, 76, 76, 76, 30, 30, 38, 41, 17, 17, 34, 35, 17, 17, 50, 51] }, { type: "Buffer", data: [74, 75, 54, 55, 74, 75, 54, 55, 74, 75, 48, 30, 74, 75, 48, 30] }, { type: "Buffer", data: [55, 55, 55, 57, 55, 55, 55, 57, 81, 82, 30, 93, 83, 84, 6, 7] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 36, 37, 52, 53, 64, 65, 66, 67] }, { type: "Buffer", data: [76, 76, 76, 76, 30, 30, 30, 30, 17, 17, 36, 37, 17, 17, 64, 65] }, { type: "Buffer", data: [76, 76, 72, 73, 30, 30, 88, 89, 52, 53, 74, 75, 66, 67, 74, 75] }, { type: "Buffer", data: [38, 41, 76, 76, 40, 21, 38, 41, 56, 87, 34, 35, 50, 51, 50, 51] }, { type: "Buffer", data: [2, 3, 85, 86, 18, 19, 17, 17, 45, 46, 17, 17, 61, 62, 17, 17] }, { type: "Buffer", data: [17, 17, 2, 3, 17, 17, 18, 19, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [85, 86, 74, 75, 17, 17, 74, 75, 17, 17, 74, 75, 17, 17, 74, 75] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 38, 39, 39, 41, 54, 55, 55, 57] }, { type: "Buffer", data: [61, 62, 17, 17, 63, 47, 17, 17, 76, 76, 76, 76, 30, 30, 30, 30] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 5, 5, 5, 5] }, { type: "Buffer", data: [54, 57, 1, 1, 54, 57, 1, 1, 54, 57, 1, 1, 54, 57, 1, 1] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [74, 75, 1, 1, 74, 75, 1, 1, 74, 75, 42, 15, 74, 75, 43, 31] }, { type: "Buffer", data: [5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [5, 5, 68, 69, 1, 1, 8, 9, 1, 1, 70, 71, 1, 1, 24, 25] }, { type: "Buffer", data: [68, 69, 68, 69, 8, 9, 8, 9, 70, 71, 70, 71, 24, 25, 24, 25] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 38, 41, 38, 41, 50, 51, 50, 51] }, { type: "Buffer", data: [54, 57, 1, 1, 54, 57, 1, 1, 54, 57, 1, 1, 54, 57, 1, 1] }, { type: "Buffer", data: [54, 57, 1, 1, 54, 57, 1, 1, 38, 41, 1, 1, 50, 51, 1, 1] }, { type: "Buffer", data: [80, 80, 68, 69, 38, 41, 8, 9, 54, 57, 70, 71, 54, 57, 24, 25] }, { type: "Buffer", data: [76, 76, 76, 76, 30, 30, 30, 30, 10, 11, 1, 1, 26, 27, 1, 1] }, { type: "Buffer", data: [74, 75, 39, 39, 74, 75, 55, 55, 74, 75, 55, 55, 74, 75, 55, 55] }, { type: "Buffer", data: [74, 75, 1, 1, 74, 75, 1, 1, 74, 75, 1, 1, 74, 75, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [38, 41, 80, 80, 40, 21, 38, 41, 56, 87, 34, 35, 50, 51, 50, 51] }, { type: "Buffer", data: [80, 80, 38, 41, 38, 41, 40, 21, 34, 35, 56, 87, 50, 51, 50, 51] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 38, 39, 39, 39, 54, 55, 55, 55] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 39, 39, 39, 41, 55, 55, 55, 57] }, { type: "Buffer", data: [80, 80, 80, 80, 80, 80, 80, 80, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [78, 79, 76, 76, 74, 75, 30, 30, 74, 75, 1, 1, 74, 75, 1, 1] }, { type: "Buffer", data: [54, 55, 55, 55, 60, 58, 58, 58, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [55, 55, 55, 57, 58, 58, 58, 59, 17, 17, 17, 17, 17, 17, 17, 17] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 32, 0, 8, 0, 0, 0, 0, 128, 0, 0, 128, 8, 0, 0, 213, 85, 255, 255, 221, 85, 221, 102, 221, 191, 253, 192, 102, 194, 153, 194, 85, 85, 255, 255, 85, 85, 170, 170, 255, 254, 0, 3, 170, 131, 170, 131, 0, 0, 102, 102, 85, 85, 170, 170, 85, 85, 105, 85, 105, 85, 85, 85, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 85, 85, 85, 85, 85, 85, 112, 0, 115, 255, 112, 0, 115, 255, 112, 0, 127, 255, 85, 85, 255, 255, 0, 15, 255, 207, 0, 15, 255, 207, 0, 15, 255, 255, 85, 87, 255, 255, 62, 150, 231, 86, 58, 110, 233, 103, 249, 223, 235, 239, 59, 51, 140, 139, 182, 190, 85, 235, 217, 93, 217, 155, 247, 159, 251, 235, 254, 238, 60, 188, 255, 255, 255, 255, 255, 255, 255, 255, 247, 119, 221, 221, 247, 119, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 119, 119, 221, 223, 119, 119, 255, 255, 192, 0, 192, 0, 192, 0, 192, 0, 255, 255, 192, 0, 192, 0, 192, 0, 0, 7, 0, 7, 0, 7, 0, 7, 255, 255, 42, 167, 10, 167, 2, 167, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 170, 170, 255, 255, 220, 183, 176, 14, 236, 59, 59, 236, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 194, 136, 192, 34, 234, 136, 239, 34, 237, 136, 239, 34, 238, 136, 255, 170, 131, 0, 3, 170, 171, 255, 251, 85, 123, 255, 251, 170, 187, 255, 255, 85, 85, 85, 105, 85, 105, 85, 85, 170, 170, 85, 85, 102, 102, 0, 0, 170, 167, 255, 247, 191, 247, 175, 247, 39, 247, 23, 247, 103, 119, 39, 119, 115, 255, 112, 0, 115, 255, 112, 0, 127, 255, 85, 85, 85, 85, 255, 255, 255, 205, 0, 13, 255, 205, 0, 13, 255, 253, 85, 85, 85, 85, 255, 255, 45, 191, 141, 106, 35, 82, 139, 127, 39, 90, 133, 210, 33, 127, 136, 85, 254, 114, 169, 120, 85, 226, 253, 200, 85, 210, 87, 88, 253, 98, 85, 136, 213, 90, 213, 106, 213, 170, 255, 255, 192, 0, 192, 0, 192, 0, 192, 0, 170, 171, 170, 171, 170, 171, 255, 255, 0, 11, 0, 11, 0, 11, 0, 11, 255, 255, 192, 0, 192, 0, 192, 0, 255, 255, 192, 0, 192, 0, 255, 255, 255, 255, 2, 167, 0, 167, 0, 39, 255, 255, 0, 167, 0, 39, 255, 255, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 14, 176, 46, 176, 59, 236, 236, 59, 48, 142, 204, 51, 179, 204, 255, 255, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 234, 0, 234, 170, 234, 255, 234, 222, 234, 190, 234, 238, 234, 62, 234, 218, 170, 223, 255, 222, 187, 222, 179, 220, 51, 223, 251, 223, 255, 218, 170, 170, 167, 255, 247, 174, 183, 12, 55, 12, 55, 255, 247, 255, 247, 170, 167, 63, 255, 213, 85, 192, 0, 201, 85, 201, 0, 201, 0, 201, 0, 201, 0, 255, 252, 85, 87, 0, 0, 105, 106, 100, 26, 80, 6, 64, 1, 80, 6, 63, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 218, 170, 223, 255, 223, 254, 223, 250, 223, 216, 223, 212, 221, 217, 221, 216, 255, 252, 0, 3, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 171, 255, 171, 0, 171, 170, 171, 255, 171, 183, 171, 190, 171, 187, 171, 188, 171, 176, 171, 184, 171, 188, 171, 187, 171, 190, 171, 187, 171, 190, 171, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 255, 255, 202, 170, 202, 170, 255, 255, 213, 85, 213, 255, 255, 128, 249, 170, 255, 255, 170, 163, 170, 163, 255, 255, 85, 87, 255, 87, 2, 255, 170, 111, 255, 255, 170, 163, 170, 163, 255, 255, 85, 87, 85, 87, 85, 87, 255, 255, 213, 85, 213, 85, 213, 85, 213, 85, 213, 85, 213, 85, 213, 85, 255, 255, 14, 234, 46, 234, 62, 234, 238, 234, 190, 234, 238, 234, 190, 234, 255, 234, 223, 255, 218, 171, 218, 171, 218, 171, 218, 171, 255, 255, 218, 170, 191, 255, 255, 247, 234, 167, 234, 167, 234, 167, 234, 167, 255, 255, 170, 167, 255, 254, 0, 3, 255, 252, 0, 48, 170, 232, 171, 2, 171, 112, 171, 127, 171, 127, 192, 0, 63, 252, 3, 195, 0, 55, 128, 175, 42, 175, 9, 175, 249, 175, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 221, 120, 222, 191, 223, 170, 223, 255, 222, 181, 222, 191, 223, 255, 218, 170, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 255, 255, 85, 85, 255, 255, 85, 85, 255, 255, 170, 170, 170, 170, 0, 0, 255, 255, 85, 87, 255, 252, 93, 92, 254, 172, 174, 172, 175, 252, 0, 0, 255, 255, 213, 85, 63, 255, 53, 117, 50, 191, 50, 186, 63, 250, 0, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 255, 255, 202, 170, 202, 170, 255, 255, 213, 85, 213, 85, 213, 85, 255, 255, 201, 255, 202, 192, 202, 229, 202, 208, 202, 229, 202, 255, 202, 170, 255, 255, 255, 255, 0, 11, 153, 155, 68, 71, 153, 151, 255, 255, 170, 170, 255, 255, 111, 127, 251, 95, 107, 85, 106, 245, 106, 175, 106, 170, 170, 170, 255, 255, 57, 175, 249, 175, 249, 183, 89, 215, 91, 167, 254, 167, 170, 167, 255, 255, 46, 34, 187, 200, 62, 190, 233, 187, 61, 91, 230, 85, 61, 127, 255, 235, 34, 50, 139, 236, 62, 159, 238, 87, 101, 125, 215, 171, 250, 126, 215, 200, 34, 35, 136, 136, 34, 45, 136, 254, 35, 116, 136, 249, 46, 244, 142, 253, 114, 34, 184, 136, 114, 34, 191, 136, 157, 226, 111, 8, 159, 178, 127, 184, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 171, 0, 171, 0, 171, 0, 171, 0, 171, 0, 171, 0, 171, 0, 171, 0, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 255, 255, 171, 255, 171, 0, 171, 0, 171, 0, 171, 0, 171, 0, 171, 0, 171, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 170, 170, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 170, 170, 127, 255, 122, 170, 123, 255, 187, 85, 123, 85, 123, 85, 123, 85, 170, 170, 255, 253, 170, 173, 255, 237, 85, 238, 85, 237, 85, 237, 85, 237, 187, 255, 122, 170, 122, 170, 122, 170, 186, 170, 122, 170, 122, 170, 127, 255, 255, 238, 170, 173, 168, 45, 168, 45, 170, 174, 170, 173, 170, 173, 255, 253, 93, 213, 253, 213, 93, 255, 157, 213, 109, 213, 159, 255, 102, 102, 153, 153, 85, 119, 85, 119, 255, 247, 85, 119, 85, 119, 255, 255, 170, 170, 170, 170, 45, 119, 254, 183, 170, 247, 255, 247, 94, 183, 254, 183, 255, 247, 170, 167, 87, 0, 87, 0, 87, 0, 87, 0, 87, 0, 87, 0, 87, 0, 255, 0, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 171, 85, 171, 85, 171, 85, 171, 85, 171, 85, 171, 85, 171, 85, 171, 255, 85, 234, 85, 234, 85, 234, 85, 234, 85, 234, 85, 234, 85, 234, 255, 234, 255, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 0, 234, 85, 87, 85, 87, 85, 87, 85, 87, 85, 87, 85, 87, 85, 87, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, overworld: { blocks: [{ type: "Buffer", data: [10, 10, 40, 41, 75, 75, 75, 31, 10, 10, 10, 31, 26, 26, 26, 79] }, { type: "Buffer", data: [35, 35, 35, 35, 57, 35, 35, 35, 35, 35, 35, 35, 35, 35, 57, 35] }, { type: "Buffer", data: [5, 6, 7, 7, 21, 22, 23, 23, 37, 38, 11, 12, 78, 26, 27, 28] }, { type: "Buffer", data: [7, 7, 8, 9, 23, 23, 24, 25, 10, 10, 40, 41, 26, 26, 26, 79] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 42, 43, 20, 20, 58, 59] }, { type: "Buffer", data: [60, 60, 60, 60, 4, 60, 4, 60, 60, 60, 60, 60, 60, 60, 60, 60] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 72, 73, 55, 55, 88, 89, 55, 55] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 55, 55, 55, 55] }, { type: "Buffer", data: [57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 70, 71, 57, 57, 86, 87] }, { type: "Buffer", data: [7, 7, 7, 7, 23, 23, 23, 23, 35, 10, 10, 35, 26, 26, 26, 26] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82] }, { type: "Buffer", data: [5, 6, 83, 83, 21, 56, 18, 18, 21, 56, 18, 18, 21, 22, 23, 23] }, { type: "Buffer", data: [83, 83, 83, 83, 18, 18, 18, 18, 18, 18, 18, 18, 23, 23, 23, 23] }, { type: "Buffer", data: [83, 83, 8, 9, 18, 18, 56, 25, 18, 18, 56, 25, 23, 23, 24, 25] }, { type: "Buffer", data: [64, 65, 64, 65, 80, 81, 80, 81, 64, 65, 64, 65, 80, 81, 80, 81] }, { type: "Buffer", data: [37, 38, 10, 10, 15, 34, 34, 34, 15, 10, 10, 10, 78, 26, 26, 26] }, { type: "Buffer", data: [34, 47, 63, 34, 34, 34, 34, 34, 10, 10, 10, 10, 26, 26, 26, 26] }, { type: "Buffer", data: [10, 10, 40, 41, 34, 34, 34, 31, 11, 12, 10, 31, 27, 28, 26, 79] }, { type: "Buffer", data: [42, 43, 42, 43, 58, 59, 58, 59, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [42, 43, 20, 20, 58, 59, 20, 20, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [20, 20, 42, 43, 20, 20, 58, 59, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [42, 43, 42, 43, 58, 59, 58, 59, 42, 43, 20, 20, 58, 59, 20, 20] }, { type: "Buffer", data: [42, 43, 42, 43, 58, 59, 58, 59, 20, 20, 42, 43, 20, 20, 58, 59] }, { type: "Buffer", data: [42, 43, 20, 20, 58, 59, 20, 20, 42, 43, 20, 20, 58, 59, 20, 20] }, { type: "Buffer", data: [20, 20, 42, 43, 20, 20, 58, 59, 20, 20, 42, 43, 20, 20, 58, 59] }, { type: "Buffer", data: [57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 54, 55, 55, 55] }, { type: "Buffer", data: [14, 14, 35, 35, 85, 85, 35, 35, 14, 14, 35, 35, 85, 85, 35, 35] }, { type: "Buffer", data: [35, 35, 35, 35, 57, 35, 35, 35, 64, 65, 64, 65, 80, 81, 80, 81] }, { type: "Buffer", data: [51, 51, 51, 51, 50, 20, 20, 20, 50, 20, 20, 20, 50, 20, 20, 20] }, { type: "Buffer", data: [51, 51, 51, 51, 20, 20, 20, 84, 20, 20, 20, 84, 20, 20, 20, 84] }, { type: "Buffer", data: [51, 51, 51, 51, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [76, 83, 83, 83, 90, 18, 18, 18, 90, 18, 18, 18, 92, 23, 23, 23] }, { type: "Buffer", data: [83, 83, 83, 77, 18, 18, 18, 90, 18, 18, 18, 90, 23, 23, 23, 93] }, { type: "Buffer", data: [33, 35, 35, 16, 35, 35, 35, 16, 35, 35, 35, 16, 33, 35, 35, 16] }, { type: "Buffer", data: [32, 32, 32, 32, 35, 35, 35, 35, 35, 35, 35, 35, 32, 32, 32, 32] }, { type: "Buffer", data: [39, 39, 17, 17, 39, 39, 17, 17, 39, 54, 55, 55, 54, 55, 55, 55] }, { type: "Buffer", data: [17, 17, 36, 36, 17, 17, 36, 36, 55, 55, 52, 36, 55, 55, 55, 52] }, { type: "Buffer", data: [16, 35, 35, 33, 16, 35, 35, 35, 16, 35, 35, 35, 16, 35, 35, 33] }, { type: "Buffer", data: [16, 35, 35, 16, 16, 35, 35, 16, 16, 35, 35, 16, 16, 35, 35, 16] }, { type: "Buffer", data: [39, 39, 17, 17, 39, 39, 17, 17, 39, 39, 17, 17, 39, 39, 17, 17] }, { type: "Buffer", data: [17, 17, 36, 36, 17, 17, 36, 36, 17, 17, 36, 36, 17, 17, 36, 36] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 55, 19, 17, 17, 19, 39, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 53, 55, 17, 17, 36, 53] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [20, 20, 20, 51, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [51, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 55, 52, 60, 60] }, { type: "Buffer", data: [5, 6, 7, 7, 21, 22, 23, 23, 37, 38, 10, 34, 78, 26, 26, 26] }, { type: "Buffer", data: [57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57] }, { type: "Buffer", data: [64, 65, 45, 46, 80, 81, 61, 62, 64, 65, 44, 44, 80, 81, 44, 44] }, { type: "Buffer", data: [64, 65, 64, 65, 80, 81, 80, 81, 44, 44, 45, 46, 44, 44, 61, 62] }, { type: "Buffer", data: [45, 46, 44, 44, 61, 62, 44, 44, 64, 65, 64, 65, 80, 81, 80, 81] }, { type: "Buffer", data: [44, 44, 45, 46, 44, 44, 61, 62, 64, 65, 44, 44, 80, 81, 44, 44] }, { type: "Buffer", data: [64, 65, 64, 65, 80, 81, 80, 81, 44, 44, 64, 65, 44, 44, 80, 81] }, { type: "Buffer", data: [15, 10, 10, 10, 15, 75, 75, 75, 15, 75, 75, 75, 78, 26, 26, 26] }, { type: "Buffer", data: [35, 35, 35, 35, 57, 35, 35, 35, 5, 6, 7, 7, 21, 22, 23, 23] }, { type: "Buffer", data: [35, 35, 35, 35, 57, 35, 35, 35, 7, 7, 8, 9, 23, 23, 24, 25] }, { type: "Buffer", data: [10, 75, 75, 10, 75, 75, 75, 75, 11, 12, 10, 10, 27, 28, 26, 26] }, { type: "Buffer", data: [1, 1, 2, 57, 17, 17, 36, 2, 17, 17, 36, 36, 17, 17, 36, 36] }, { type: "Buffer", data: [37, 38, 10, 34, 92, 23, 23, 23, 15, 34, 11, 12, 78, 26, 27, 28] }, { type: "Buffer", data: [10, 10, 40, 41, 23, 23, 23, 93, 10, 10, 34, 31, 26, 26, 26, 79] }, { type: "Buffer", data: [35, 30, 1, 1, 30, 39, 17, 17, 39, 39, 17, 17, 39, 39, 17, 17] }, { type: "Buffer", data: [1, 1, 1, 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [42, 43, 44, 44, 58, 59, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 42, 43, 44, 44, 58, 59, 44, 44] }, { type: "Buffer", data: [44, 44, 64, 65, 44, 44, 80, 81, 44, 44, 64, 65, 55, 52, 80, 81] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [16, 35, 35, 33, 16, 35, 35, 35, 16, 35, 35, 35, 33, 32, 32, 32] }, { type: "Buffer", data: [33, 35, 35, 16, 35, 35, 35, 16, 35, 35, 35, 16, 32, 32, 32, 33] }, { type: "Buffer", data: [39, 57, 57, 57, 39, 57, 57, 57, 39, 57, 57, 57, 39, 57, 57, 57] }, { type: "Buffer", data: [57, 57, 13, 36, 57, 57, 13, 36, 57, 57, 13, 36, 57, 57, 13, 36] }, { type: "Buffer", data: [32, 32, 32, 33, 35, 35, 35, 16, 35, 35, 35, 16, 33, 35, 35, 16] }, { type: "Buffer", data: [33, 32, 32, 32, 16, 35, 35, 35, 16, 35, 35, 35, 16, 35, 35, 33] }, { type: "Buffer", data: [39, 57, 57, 57, 39, 57, 57, 57, 39, 57, 57, 57, 54, 55, 60, 60] }, { type: "Buffer", data: [57, 57, 13, 36, 57, 57, 13, 36, 57, 57, 13, 36, 54, 55, 55, 52] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 64, 65, 44, 44, 80, 81, 44, 44] }, { type: "Buffer", data: [44, 44, 42, 43, 44, 44, 58, 59, 44, 44, 42, 43, 44, 44, 58, 59] }, { type: "Buffer", data: [42, 43, 44, 44, 58, 59, 44, 44, 42, 43, 44, 44, 58, 59, 44, 44] }, { type: "Buffer", data: [44, 44, 42, 43, 44, 44, 58, 59, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [42, 43, 44, 44, 58, 59, 44, 44, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [42, 43, 42, 43, 58, 59, 58, 59, 44, 44, 44, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [44, 44, 42, 43, 44, 44, 58, 59, 44, 44, 44, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60] }, { type: "Buffer", data: [91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91] }, { type: "Buffer", data: [57, 57, 57, 57, 57, 57, 57, 57, 14, 14, 70, 71, 85, 85, 86, 87] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 55, 55, 55, 55, 55, 55, 55, 55] }, { type: "Buffer", data: [39, 44, 44, 44, 39, 44, 44, 44, 39, 44, 44, 44, 39, 44, 44, 44] }, { type: "Buffer", data: [44, 44, 29, 36, 44, 44, 29, 36, 44, 44, 29, 36, 44, 44, 29, 36] }, { type: "Buffer", data: [39, 44, 44, 44, 39, 44, 44, 44, 39, 44, 44, 44, 54, 55, 55, 55] }, { type: "Buffer", data: [44, 44, 29, 36, 44, 44, 29, 36, 44, 44, 29, 36, 55, 55, 55, 52] }, { type: "Buffer", data: [57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 60, 60, 54, 55] }, { type: "Buffer", data: [33, 35, 35, 33, 16, 35, 35, 16, 16, 35, 35, 16, 16, 35, 35, 16] }, { type: "Buffer", data: [16, 35, 35, 16, 16, 35, 35, 16, 16, 35, 35, 16, 33, 35, 35, 33] }, { type: "Buffer", data: [35, 35, 14, 14, 35, 35, 85, 85, 35, 35, 14, 14, 35, 35, 85, 85] }, { type: "Buffer", data: [44, 44, 64, 65, 44, 44, 80, 81, 45, 46, 64, 65, 61, 62, 80, 81] }, { type: "Buffer", data: [57, 57, 57, 57, 57, 57, 57, 57, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [42, 43, 42, 43, 58, 59, 58, 59, 42, 43, 44, 44, 58, 59, 44, 44] }, { type: "Buffer", data: [42, 43, 42, 43, 58, 59, 58, 59, 44, 44, 42, 43, 44, 44, 58, 59] }, { type: "Buffer", data: [20, 20, 20, 84, 20, 20, 20, 84, 20, 20, 20, 84, 20, 20, 20, 84] }, { type: "Buffer", data: [50, 20, 20, 20, 50, 20, 20, 20, 50, 20, 20, 20, 50, 20, 20, 20] }, { type: "Buffer", data: [50, 20, 20, 84, 50, 20, 20, 84, 50, 20, 20, 84, 50, 20, 20, 84] }, { type: "Buffer", data: [42, 43, 51, 51, 58, 59, 20, 20, 42, 43, 20, 20, 58, 59, 20, 20] }, { type: "Buffer", data: [15, 10, 10, 10, 15, 75, 75, 75, 15, 10, 10, 10, 15, 75, 75, 75] }, { type: "Buffer", data: [10, 10, 10, 31, 75, 75, 75, 31, 10, 10, 10, 31, 75, 75, 75, 31] }, { type: "Buffer", data: [51, 51, 42, 43, 20, 20, 58, 59, 20, 20, 42, 43, 20, 20, 58, 59] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 42, 43, 42, 43, 58, 59, 58, 59] }, { type: "Buffer", data: [64, 65, 64, 65, 80, 81, 80, 81, 44, 44, 44, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [64, 65, 44, 44, 80, 81, 44, 44, 64, 65, 44, 44, 80, 81, 44, 44] }, { type: "Buffer", data: [44, 44, 64, 65, 44, 44, 80, 81, 44, 44, 64, 65, 44, 44, 80, 81] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 64, 65, 64, 65, 80, 81, 80, 81] }, { type: "Buffer", data: [17, 17, 36, 36, 17, 17, 36, 36, 72, 73, 52, 36, 88, 89, 55, 52] }, { type: "Buffer", data: [18, 18, 18, 18, 18, 18, 18, 18, 23, 23, 23, 23, 34, 34, 34, 34] }, { type: "Buffer", data: [10, 10, 10, 31, 75, 75, 75, 31, 66, 67, 75, 31, 74, 74, 26, 79] }, { type: "Buffer", data: [10, 10, 10, 31, 75, 75, 75, 31, 68, 69, 75, 31, 74, 74, 26, 79] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 3, 44, 3, 3, 44, 3, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [21, 56, 18, 18, 21, 56, 18, 18, 21, 22, 23, 23, 37, 38, 34, 34] }, { type: "Buffer", data: [18, 18, 56, 25, 18, 18, 56, 25, 23, 23, 24, 25, 34, 34, 40, 41] }, { type: "Buffer", data: [57, 57, 57, 57, 57, 57, 57, 57, 14, 14, 14, 14, 85, 85, 85, 85] }, { type: "Buffer", data: [49, 49, 49, 49, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 70, 71, 48, 48, 86, 87] }, { type: "Buffer", data: [44, 48, 44, 48, 48, 44, 48, 44, 44, 48, 44, 48, 48, 44, 48, 44] }, { type: "Buffer", data: [48, 57, 48, 57, 57, 48, 57, 48, 48, 57, 48, 57, 57, 48, 57, 48] }, { type: "Buffer", data: [15, 10, 10, 10, 15, 75, 75, 75, 15, 75, 11, 12, 78, 26, 27, 28] }, { type: "Buffer", data: [10, 10, 10, 10, 75, 75, 75, 75, 75, 75, 75, 75, 26, 26, 26, 26] }, { type: "Buffer", data: [10, 10, 10, 31, 75, 75, 75, 31, 75, 75, 75, 31, 26, 26, 26, 79] }, { type: "Buffer", data: [10, 10, 10, 10, 75, 75, 75, 75, 10, 10, 10, 10, 75, 75, 75, 75] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 31, 210, 136, 136, 162, 170, 106, 153, 170, 102, 170, 153, 154, 170, 192, 0, 240, 0, 127, 0, 119, 192, 94, 240, 119, 176, 126, 236, 251, 183, 129, 66, 4, 24, 17, 102, 18, 164, 166, 146, 81, 69, 21, 84, 137, 98, 85, 85, 170, 170, 162, 2, 170, 170, 85, 85, 170, 170, 128, 138, 170, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 60, 3, 212, 61, 20, 0, 3, 0, 61, 3, 197, 61, 69, 209, 69, 81, 69, 81, 69, 81, 69, 255, 255, 0, 0, 170, 170, 170, 170, 85, 85, 170, 170, 170, 170, 170, 170, 192, 0, 124, 0, 83, 192, 81, 124, 81, 71, 81, 69, 81, 69, 81, 69, 0, 0, 0, 0, 0, 0, 0, 0, 192, 0, 60, 0, 23, 192, 20, 124, 170, 170, 127, 253, 192, 35, 192, 135, 194, 27, 200, 103, 225, 151, 127, 253, 102, 170, 111, 255, 109, 85, 109, 127, 77, 192, 77, 192, 77, 194, 77, 200, 170, 153, 255, 249, 85, 121, 253, 121, 35, 113, 139, 113, 43, 113, 171, 113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 240, 63, 252, 63, 252, 59, 220, 58, 92, 58, 92, 42, 176, 42, 176, 42, 176, 42, 176, 42, 176, 42, 176, 42, 176, 42, 176, 172, 118, 172, 118, 172, 118, 172, 118, 172, 118, 172, 118, 172, 118, 172, 118, 168, 170, 146, 169, 138, 130, 168, 10, 104, 25, 160, 102, 162, 153, 154, 170, 42, 168, 138, 161, 162, 134, 168, 26, 168, 42, 161, 138, 134, 162, 26, 168, 245, 145, 213, 78, 157, 188, 230, 250, 187, 56, 252, 161, 242, 142, 232, 163, 85, 5, 84, 21, 84, 21, 85, 5, 85, 64, 5, 85, 80, 85, 84, 21, 197, 20, 197, 20, 197, 20, 197, 20, 197, 20, 197, 20, 197, 20, 197, 20, 81, 69, 81, 69, 81, 69, 81, 69, 81, 69, 81, 71, 81, 125, 83, 215, 85, 85, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 85, 85, 255, 255, 81, 69, 81, 69, 81, 69, 81, 69, 81, 69, 209, 69, 125, 69, 215, 197, 20, 83, 20, 83, 20, 83, 20, 83, 20, 83, 20, 83, 20, 83, 20, 83, 170, 170, 170, 170, 0, 0, 170, 170, 85, 85, 85, 85, 255, 255, 170, 170, 77, 127, 77, 85, 77, 128, 77, 42, 77, 42, 77, 85, 79, 255, 250, 170, 253, 241, 87, 49, 2, 241, 170, 113, 170, 113, 85, 113, 255, 241, 170, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 14, 0, 252, 3, 250, 15, 56, 60, 161, 50, 142, 232, 163, 14, 168, 14, 168, 14, 168, 14, 168, 14, 168, 14, 168, 14, 168, 14, 168, 170, 170, 170, 170, 255, 255, 0, 0, 85, 85, 245, 127, 95, 245, 170, 170, 175, 250, 180, 30, 208, 7, 208, 7, 212, 23, 245, 95, 189, 126, 175, 250, 106, 170, 0, 0, 0, 0, 0, 0, 170, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 223, 115, 127, 126, 254, 127, 187, 94, 238, 119, 183, 126, 239, 251, 183, 197, 20, 197, 23, 197, 61, 199, 215, 253, 126, 215, 234, 63, 234, 0, 232, 125, 126, 215, 234, 126, 170, 234, 170, 170, 128, 168, 0, 128, 0, 0, 0, 250, 35, 250, 138, 62, 44, 204, 250, 50, 56, 232, 162, 226, 12, 232, 131, 189, 125, 171, 215, 170, 189, 170, 171, 2, 170, 0, 42, 0, 2, 0, 0, 20, 83, 212, 83, 124, 83, 215, 211, 189, 127, 171, 215, 171, 252, 43, 0, 0, 15, 0, 246, 3, 96, 13, 0, 14, 0, 13, 160, 13, 154, 45, 148, 252, 0, 167, 192, 2, 112, 0, 28, 0, 44, 2, 156, 169, 156, 5, 156, 136, 138, 32, 34, 128, 168, 34, 162, 138, 136, 34, 10, 8, 40, 42, 162, 136, 136, 33, 18, 156, 196, 55, 114, 216, 28, 54, 63, 253, 255, 55, 247, 140, 200, 247, 114, 217, 28, 116, 135, 249, 28, 118, 114, 189, 244, 155, 226, 170, 170, 0, 0, 63, 204, 240, 12, 243, 207, 240, 195, 63, 195, 0, 0, 128, 2, 16, 16, 36, 64, 9, 8, 128, 0, 4, 4, 1, 16, 128, 66, 85, 85, 0, 0, 255, 255, 94, 181, 94, 185, 108, 57, 108, 49, 65, 64, 229, 223, 121, 126, 94, 251, 87, 237, 87, 231, 94, 189, 121, 221, 229, 119, 213, 87, 181, 94, 109, 121, 91, 229, 223, 237, 126, 183, 251, 125, 237, 215, 238, 239, 51, 119, 142, 223, 99, 183, 24, 223, 102, 247, 87, 189, 254, 229, 78, 95, 113, 87, 126, 94, 127, 185, 94, 230, 119, 181, 126, 239, 251, 183, 226, 35, 254, 132, 251, 18, 226, 217, 233, 100, 239, 153, 126, 213, 91, 191, 230, 103, 49, 116, 7, 208, 7, 228, 27, 181, 110, 245, 95, 159, 254, 171, 81, 69, 81, 69, 81, 69, 81, 69, 81, 69, 81, 69, 81, 69, 81, 69, 0, 0, 34, 0, 34, 34, 0, 34, 0, 0, 8, 128, 8, 128, 0, 0, 174, 148, 158, 168, 157, 168, 157, 148, 23, 148, 37, 244, 9, 95, 2, 165, 5, 172, 10, 172, 10, 156, 5, 156, 5, 180, 7, 208, 253, 64, 84, 0, 85, 85, 170, 170, 162, 2, 170, 170, 85, 85, 170, 170, 128, 138, 170, 170, 140, 245, 33, 29, 152, 140, 34, 44, 136, 114, 34, 216, 136, 125, 34, 23, 92, 136, 114, 34, 184, 136, 178, 34, 45, 136, 167, 98, 125, 132, 214, 34, 170, 170, 0, 0, 51, 3, 51, 207, 243, 255, 195, 51, 195, 51, 0, 0, 136, 191, 37, 224, 139, 128, 39, 2, 158, 136, 53, 152, 190, 102, 47, 169, 210, 34, 61, 136, 143, 152, 19, 100, 12, 210, 151, 120, 221, 242, 123, 216, 170, 170, 255, 255, 170, 170, 240, 60, 204, 204, 204, 204, 240, 204, 192, 240, 170, 170, 255, 255, 170, 174, 204, 48, 204, 252, 240, 204, 204, 240, 204, 60, 170, 170, 255, 255, 170, 170, 192, 195, 243, 204, 204, 207, 192, 204, 192, 204, 170, 170, 255, 255, 170, 170, 15, 63, 204, 204, 207, 12, 204, 204, 204, 204, 63, 255, 53, 255, 15, 0, 63, 255, 234, 170, 196, 0, 197, 17, 192, 0, 255, 252, 253, 127, 3, 231, 255, 247, 170, 175, 5, 15, 69, 31, 0, 15, 230, 103, 49, 116, 134, 191, 103, 255, 27, 255, 111, 255, 95, 255, 255, 255, 230, 103, 49, 116, 254, 145, 255, 230, 255, 229, 255, 245, 255, 255, 255, 251, 0, 0, 21, 84, 0, 0, 255, 255, 92, 181, 92, 181, 252, 191, 167, 218, 0, 0, 170, 164, 170, 164, 0, 0, 164, 170, 164, 170, 0, 0, 42, 164, 0, 255, 3, 192, 3, 192, 3, 192, 3, 234, 3, 192, 3, 192, 3, 192, 255, 0, 3, 192, 3, 192, 3, 192, 171, 192, 3, 192, 3, 192, 3, 192, 42, 186, 42, 176, 42, 176, 42, 186, 42, 185, 42, 185, 42, 175, 42, 170, 174, 168, 14, 168, 14, 168, 174, 168, 110, 168, 110, 168, 250, 168, 170, 168, 187, 102, 221, 155, 251, 118, 125, 223, 159, 255, 103, 253, 153, 118, 34, 159, 221, 246, 183, 126, 253, 252, 127, 246, 255, 216, 127, 100, 157, 146, 246, 138, 0, 6, 0, 17, 80, 105, 68, 102, 73, 84, 18, 88, 166, 80, 41, 96, 255, 255, 0, 0, 170, 170, 170, 170, 85, 85, 161, 138, 134, 162, 26, 168, 247, 99, 61, 142, 207, 57, 115, 230, 211, 217, 124, 54, 183, 77, 221, 147, 58, 92, 58, 92, 50, 108, 48, 172, 56, 156, 30, 116, 7, 208, 0, 0, 197, 0, 197, 17, 192, 0, 63, 255, 34, 2, 34, 8, 0, 2, 0, 0, 4, 79, 68, 79, 0, 15, 255, 247, 41, 199, 165, 231, 37, 215, 138, 125, 239, 255, 63, 255, 143, 255, 111, 255, 31, 255, 111, 221, 91, 119, 250, 221, 255, 247, 255, 244, 255, 241, 255, 246, 255, 245, 221, 245, 119, 111, 221, 235, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 170, 170, 10, 128, 2, 0, 10, 128, 170, 170, 128, 10, 0, 2, 128, 10, 3, 234, 3, 192, 3, 192, 3, 192, 3, 234, 3, 255, 3, 170, 3, 255, 171, 192, 3, 192, 3, 192, 3, 192, 171, 192, 255, 192, 170, 192, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, plateau: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [35, 35, 35, 35, 45, 35, 35, 35, 35, 35, 35, 35, 35, 35, 45, 35] }, { type: "Buffer", data: [42, 43, 42, 43, 34, 29, 34, 29, 42, 43, 42, 43, 34, 29, 34, 29] }, { type: "Buffer", data: [1, 1, 2, 45, 17, 17, 36, 2, 17, 17, 36, 36, 17, 17, 36, 36] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [39, 39, 17, 17, 39, 39, 17, 17, 39, 39, 17, 17, 39, 39, 17, 17] }, { type: "Buffer", data: [17, 17, 36, 36, 17, 17, 36, 36, 17, 17, 36, 36, 17, 17, 36, 36] }, { type: "Buffer", data: [35, 30, 1, 1, 30, 39, 17, 17, 39, 39, 17, 17, 39, 39, 17, 17] }, { type: "Buffer", data: [45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 9, 10, 45, 45, 25, 26] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 55, 55, 55, 55, 55, 55, 55, 55] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [1, 1, 1, 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [39, 39, 17, 17, 39, 39, 17, 17, 39, 54, 55, 55, 54, 55, 55, 55] }, { type: "Buffer", data: [17, 17, 36, 36, 17, 17, 36, 36, 55, 55, 52, 36, 55, 55, 55, 52] }, { type: "Buffer", data: [45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45] }, { type: "Buffer", data: [7, 8, 7, 8, 23, 24, 23, 24, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [51, 51, 51, 51, 50, 20, 20, 20, 50, 20, 20, 20, 50, 20, 20, 20] }, { type: "Buffer", data: [51, 51, 51, 51, 20, 20, 20, 31, 20, 20, 20, 31, 20, 20, 20, 31] }, { type: "Buffer", data: [51, 51, 51, 51, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [44, 44, 42, 43, 44, 44, 34, 29, 44, 44, 42, 43, 44, 44, 34, 29] }, { type: "Buffer", data: [20, 20, 20, 31, 20, 20, 20, 31, 20, 20, 20, 31, 20, 20, 20, 31] }, { type: "Buffer", data: [50, 20, 20, 20, 50, 20, 20, 20, 50, 20, 20, 20, 50, 20, 20, 20] }, { type: "Buffer", data: [42, 43, 44, 44, 34, 29, 44, 44, 42, 43, 44, 44, 34, 29, 44, 44] }, { type: "Buffer", data: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3] }, { type: "Buffer", data: [46, 47, 3, 3, 46, 47, 3, 3, 37, 38, 3, 3, 40, 41, 13, 13] }, { type: "Buffer", data: [35, 35, 7, 8, 45, 35, 23, 24, 35, 45, 44, 44, 35, 35, 44, 44] }, { type: "Buffer", data: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 13, 13, 13, 13] }, { type: "Buffer", data: [3, 3, 46, 47, 3, 3, 46, 47, 3, 3, 37, 38, 13, 13, 40, 41] }, { type: "Buffer", data: [21, 22, 15, 15, 5, 6, 15, 15, 5, 6, 15, 15, 21, 22, 14, 14] }, { type: "Buffer", data: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 11, 12, 14, 14, 27, 28] }, { type: "Buffer", data: [15, 15, 15, 15, 15, 15, 15, 15, 11, 12, 15, 15, 27, 28, 14, 14] }, { type: "Buffer", data: [15, 15, 21, 22, 15, 15, 5, 6, 15, 15, 5, 6, 14, 14, 21, 22] }, { type: "Buffer", data: [7, 8, 35, 35, 23, 24, 45, 35, 44, 44, 35, 45, 44, 44, 35, 35] }, { type: "Buffer", data: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 32, 33, 3, 3] }, { type: "Buffer", data: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 32, 33] }, { type: "Buffer", data: [44, 44, 7, 8, 44, 44, 23, 24, 44, 44, 7, 8, 44, 44, 23, 24] }, { type: "Buffer", data: [7, 8, 44, 44, 23, 24, 44, 44, 7, 8, 44, 44, 23, 24, 44, 44] }, { type: "Buffer", data: [35, 35, 16, 18, 45, 35, 40, 41, 35, 45, 21, 22, 35, 35, 48, 49] }, { type: "Buffer", data: [16, 18, 35, 35, 40, 41, 45, 35, 21, 22, 35, 45, 48, 49, 35, 35] }, { type: "Buffer", data: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14] }, { type: "Buffer", data: [13, 13, 13, 13, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14] }, { type: "Buffer", data: [35, 35, 35, 35, 35, 35, 35, 35, 32, 33, 35, 35, 46, 47, 35, 35] }, { type: "Buffer", data: [35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 32, 33, 35, 35, 46, 47] }, { type: "Buffer", data: [13, 13, 21, 22, 15, 15, 5, 6, 15, 15, 5, 6, 14, 14, 48, 49] }, { type: "Buffer", data: [21, 22, 13, 13, 5, 6, 15, 15, 5, 6, 15, 15, 48, 49, 14, 14] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 57, 58, 55, 55, 59, 60, 55, 55] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 55, 19, 17, 17, 19, 39, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17] }, { type: "Buffer", data: [17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 53, 55, 17, 17, 36, 53] }, { type: "Buffer", data: [7, 8, 44, 44, 23, 24, 44, 44, 7, 8, 44, 44, 23, 24, 44, 44] }, { type: "Buffer", data: [44, 44, 7, 8, 44, 44, 23, 24, 44, 44, 7, 8, 44, 44, 23, 24] }, { type: "Buffer", data: [7, 8, 7, 8, 23, 24, 23, 24, 44, 44, 44, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 7, 8, 7, 8, 23, 24, 23, 24] }, { type: "Buffer", data: [46, 47, 3, 3, 46, 47, 3, 3, 46, 47, 3, 3, 46, 47, 3, 3] }, { type: "Buffer", data: [3, 3, 46, 47, 3, 3, 46, 47, 3, 3, 46, 47, 3, 3, 46, 47] }, { type: "Buffer", data: [50, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [20, 20, 20, 31, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [53, 55, 55, 55, 36, 53, 55, 55, 36, 36, 17, 17, 36, 36, 17, 17] }, { type: "Buffer", data: [64, 62, 62, 62, 68, 61, 61, 61, 68, 61, 61, 61, 68, 61, 61, 61] }, { type: "Buffer", data: [62, 62, 62, 65, 61, 61, 61, 68, 61, 61, 61, 68, 61, 61, 61, 68] }, { type: "Buffer", data: [62, 62, 62, 62, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61] }, { type: "Buffer", data: [61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61] }, { type: "Buffer", data: [68, 61, 61, 61, 68, 61, 61, 61, 68, 61, 61, 61, 68, 61, 61, 61] }, { type: "Buffer", data: [61, 61, 61, 68, 61, 61, 61, 68, 61, 61, 61, 68, 61, 61, 61, 68] }, { type: "Buffer", data: [69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69] }, { type: "Buffer", data: [44, 35, 44, 35, 35, 44, 35, 44, 44, 35, 44, 35, 35, 44, 35, 44] }, { type: "Buffer", data: [44, 35, 16, 18, 35, 44, 40, 41, 44, 35, 21, 22, 35, 44, 48, 49] }, { type: "Buffer", data: [16, 18, 44, 35, 40, 41, 35, 44, 21, 22, 44, 35, 48, 49, 35, 44] }, { type: "Buffer", data: [7, 8, 44, 44, 23, 24, 44, 44, 32, 33, 44, 44, 46, 47, 44, 44] }, { type: "Buffer", data: [44, 44, 7, 8, 44, 44, 23, 24, 44, 44, 32, 33, 44, 44, 46, 47] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 32, 33, 20, 20, 46, 47, 20, 20] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 32, 33, 20, 20, 46, 47] }, { type: "Buffer", data: [44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 9, 10, 44, 44, 25, 26] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 95, 18, 33, 136, 136, 162, 170, 106, 153, 170, 102, 170, 153, 154, 170, 64, 0, 112, 0, 127, 0, 119, 192, 94, 240, 119, 176, 126, 236, 251, 183, 221, 221, 0, 0, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 194, 170, 194, 170, 194, 170, 194, 170, 194, 170, 194, 170, 194, 170, 194, 170, 170, 151, 170, 151, 170, 151, 170, 151, 170, 151, 170, 151, 170, 151, 170, 151, 136, 143, 35, 242, 158, 232, 46, 162, 187, 120, 54, 231, 189, 153, 230, 103, 200, 136, 63, 34, 141, 200, 38, 226, 155, 120, 117, 114, 157, 244, 119, 126, 0, 0, 15, 240, 63, 255, 213, 85, 192, 0, 193, 4, 193, 68, 192, 0, 0, 0, 15, 240, 255, 252, 85, 87, 0, 3, 81, 67, 81, 3, 0, 3, 255, 255, 221, 204, 237, 204, 221, 204, 221, 238, 221, 255, 221, 153, 221, 230, 255, 255, 51, 119, 51, 119, 51, 119, 187, 119, 255, 123, 153, 119, 103, 119, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 102, 102, 255, 255, 221, 221, 170, 170, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 255, 255, 85, 85, 170, 170, 170, 170, 170, 170, 85, 85, 170, 170, 170, 170, 170, 170, 0, 3, 15, 60, 58, 220, 14, 87, 3, 117, 13, 77, 61, 85, 51, 244, 168, 138, 146, 41, 136, 170, 162, 170, 106, 153, 170, 102, 170, 153, 154, 170, 192, 0, 60, 240, 55, 108, 213, 176, 93, 192, 113, 112, 85, 124, 159, 204, 245, 145, 213, 78, 157, 188, 230, 250, 187, 56, 252, 161, 242, 142, 232, 163, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 250, 170, 206, 170, 195, 119, 194, 169, 194, 170, 242, 169, 238, 170, 235, 255, 170, 175, 170, 183, 119, 87, 154, 151, 106, 151, 153, 159, 102, 119, 255, 215, 245, 93, 223, 85, 125, 221, 55, 127, 143, 223, 39, 253, 137, 118, 34, 95, 221, 220, 119, 94, 221, 248, 127, 114, 255, 216, 127, 98, 157, 68, 245, 34, 193, 68, 193, 68, 192, 0, 63, 255, 14, 176, 92, 53, 87, 213, 0, 0, 4, 67, 68, 67, 0, 3, 255, 252, 14, 176, 92, 53, 87, 213, 0, 0, 221, 85, 221, 214, 221, 89, 221, 102, 221, 89, 255, 255, 85, 85, 85, 85, 85, 119, 87, 119, 153, 119, 101, 119, 149, 119, 255, 255, 85, 85, 85, 85, 200, 62, 194, 167, 0, 39, 128, 87, 103, 119, 157, 223, 247, 125, 63, 226, 0, 1, 0, 14, 0, 252, 3, 250, 15, 56, 60, 161, 50, 142, 232, 163, 247, 99, 61, 142, 207, 57, 115, 230, 211, 217, 124, 54, 183, 77, 221, 147, 255, 255, 192, 0, 200, 136, 194, 2, 200, 0, 192, 0, 192, 0, 192, 0, 255, 255, 0, 3, 128, 131, 34, 35, 8, 131, 2, 35, 0, 3, 0, 3, 213, 8, 213, 80, 221, 223, 63, 119, 139, 223, 34, 254, 136, 139, 34, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 223, 115, 127, 126, 254, 127, 187, 94, 238, 119, 183, 126, 239, 251, 183, 234, 171, 239, 188, 250, 220, 238, 87, 235, 117, 237, 77, 253, 85, 243, 244, 234, 171, 62, 251, 55, 111, 213, 187, 93, 235, 113, 123, 85, 127, 159, 207, 250, 35, 250, 138, 62, 44, 204, 250, 50, 56, 232, 162, 226, 12, 232, 131, 201, 207, 247, 112, 239, 95, 247, 64, 231, 192, 237, 240, 236, 79, 235, 245, 243, 75, 13, 223, 245, 251, 1, 223, 3, 219, 15, 123, 241, 59, 95, 235, 170, 253, 175, 7, 186, 160, 219, 96, 220, 53, 220, 3, 240, 2, 176, 2, 190, 104, 195, 209, 1, 120, 22, 114, 66, 120, 72, 209, 63, 248, 48, 50, 136, 136, 33, 18, 152, 137, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 0, 0, 32, 2, 0, 128, 0, 0, 128, 0, 0, 2, 0, 0, 32, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 250, 170, 206, 170, 194, 255, 194, 192, 194, 192, 242, 255, 94, 170, 87, 255, 170, 175, 170, 183, 255, 151, 3, 151, 3, 151, 255, 159, 170, 181, 255, 213, 229, 223, 121, 126, 94, 251, 87, 237, 87, 231, 94, 189, 121, 221, 229, 119, 213, 87, 181, 94, 109, 121, 91, 229, 223, 237, 126, 183, 251, 125, 237, 215, 238, 239, 51, 119, 142, 223, 103, 183, 25, 223, 102, 247, 87, 189, 254, 229, 78, 95, 113, 87, 126, 94, 127, 185, 94, 230, 119, 181, 126, 239, 251, 183, 226, 35, 254, 132, 251, 18, 226, 217, 233, 100, 239, 153, 126, 213, 91, 191, 230, 103, 49, 116, 135, 209, 103, 230, 27, 181, 110, 245, 95, 159, 254, 171, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 230, 103, 49, 116, 134, 191, 103, 255, 27, 255, 111, 255, 95, 255, 255, 255, 230, 103, 49, 116, 254, 145, 255, 230, 255, 229, 255, 245, 255, 255, 255, 251, 239, 255, 63, 255, 143, 255, 111, 255, 31, 255, 111, 221, 91, 119, 250, 221, 255, 247, 255, 244, 255, 241, 255, 246, 255, 245, 221, 245, 119, 111, 221, 235, 106, 169, 154, 166, 166, 154, 169, 106, 169, 106, 166, 154, 154, 166, 106, 169, 255, 255, 0, 0, 170, 170, 170, 170, 85, 85, 166, 154, 154, 166, 106, 169, 85, 85, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 85, 85, 255, 255, 0, 255, 3, 192, 3, 192, 3, 192, 3, 234, 3, 192, 3, 192, 3, 192, 255, 0, 3, 192, 3, 192, 3, 192, 171, 192, 3, 192, 3, 192, 3, 192, 3, 234, 3, 192, 3, 192, 3, 192, 3, 234, 3, 255, 3, 170, 3, 255, 171, 192, 3, 192, 3, 192, 3, 192, 171, 192, 255, 192, 170, 192, 255, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 0, 0, 16, 16, 68, 68, 105, 164, 26, 100, 154, 102, 166, 90, 41, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, pokecenter: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [3, 40, 16, 41, 19, 40, 16, 41, 1, 11, 16, 41, 17, 27, 16, 41] }, { type: "Buffer", data: [40, 58, 59, 40, 40, 74, 75, 40, 72, 76, 77, 73, 72, 6, 22, 73] }, { type: "Buffer", data: [1, 11, 1, 11, 17, 27, 17, 27, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [8, 8, 8, 10, 24, 25, 24, 25, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [8, 8, 4, 5, 24, 25, 20, 21, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [56, 8, 8, 8, 24, 25, 24, 25, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [8, 8, 8, 8, 24, 25, 24, 25, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [36, 37, 57, 11, 52, 53, 60, 27, 38, 39, 54, 11, 42, 43, 26, 27] }, { type: "Buffer", data: [40, 40, 40, 40, 78, 79, 78, 79, 76, 77, 76, 77, 23, 29, 23, 29] }, { type: "Buffer", data: [1, 11, 1, 11, 17, 27, 17, 27, 1, 11, 12, 12, 17, 27, 28, 28] }, { type: "Buffer", data: [1, 11, 1, 11, 17, 27, 17, 27, 12, 12, 1, 11, 28, 28, 17, 27] }, { type: "Buffer", data: [40, 40, 40, 40, 40, 40, 40, 40, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [92, 93, 40, 40, 94, 95, 40, 40, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [32, 33, 32, 33, 48, 49, 48, 49, 34, 35, 34, 35, 50, 51, 50, 51] }, { type: "Buffer", data: [1, 11, 1, 11, 17, 27, 17, 27, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [59, 40, 40, 2, 75, 40, 40, 18, 77, 7, 54, 11, 22, 13, 26, 27] }, { type: "Buffer", data: [1, 11, 1, 11, 26, 27, 17, 27, 54, 11, 1, 11, 26, 27, 17, 27] }, { type: "Buffer", data: [40, 40, 40, 40, 78, 79, 78, 79, 76, 77, 76, 77, 23, 29, 23, 29] }, { type: "Buffer", data: [90, 91, 90, 91, 44, 45, 44, 45, 46, 47, 46, 47, 62, 63, 62, 63] }, { type: "Buffer", data: [1, 11, 1, 11, 17, 27, 17, 27, 64, 65, 65, 67, 80, 81, 81, 83] }, { type: "Buffer", data: [68, 69, 69, 71, 84, 85, 85, 87, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [54, 11, 1, 11, 26, 27, 17, 27, 64, 65, 65, 67, 80, 81, 81, 83] }, { type: "Buffer", data: [56, 8, 16, 41, 25, 24, 25, 24, 54, 11, 1, 11, 26, 27, 17, 27] }, { type: "Buffer", data: [40, 40, 40, 89, 40, 40, 16, 41, 54, 11, 14, 15, 26, 27, 30, 31] }, { type: "Buffer", data: [54, 11, 1, 11, 26, 27, 17, 27, 54, 11, 1, 11, 26, 27, 17, 27] }, { type: "Buffer", data: [54, 11, 1, 11, 26, 27, 17, 27, 1, 11, 12, 12, 17, 27, 28, 28] }, { type: "Buffer", data: [1, 11, 9, 88, 17, 27, 17, 27, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [8, 8, 8, 8, 24, 25, 24, 25, 1, 11, 66, 70, 17, 27, 82, 86] }, { type: "Buffer", data: [64, 65, 65, 67, 80, 81, 81, 83, 68, 69, 69, 71, 84, 85, 85, 87] }, { type: "Buffer", data: [1, 11, 1, 11, 17, 27, 17, 27, 90, 91, 90, 91, 20, 40, 40, 40] }, { type: "Buffer", data: [1, 11, 1, 11, 17, 27, 17, 27, 90, 91, 90, 91, 40, 40, 40, 40] }, { type: "Buffer", data: [16, 41, 40, 58, 16, 41, 40, 74, 16, 41, 72, 76, 16, 41, 72, 6] }, { type: "Buffer", data: [4, 5, 56, 8, 20, 21, 24, 25, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [90, 91, 1, 11, 25, 24, 17, 27, 1, 11, 1, 11, 17, 27, 17, 27] }, { type: "Buffer", data: [90, 91, 8, 8, 25, 24, 24, 25, 1, 11, 66, 70, 17, 27, 82, 86] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 90, 91, 90, 91, 40, 40, 40, 40] }], tiles: { type: "Buffer", data: [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 128, 128, 32, 32, 8, 8, 2, 2, 0, 128, 0, 32, 160, 8, 32, 2, 85, 85, 64, 0, 64, 15, 234, 180, 106, 212, 64, 213, 106, 192, 234, 176, 85, 85, 0, 1, 240, 1, 30, 171, 23, 169, 87, 1, 3, 169, 14, 171, 255, 255, 192, 0, 255, 255, 229, 85, 229, 85, 229, 85, 229, 85, 229, 85, 255, 255, 0, 3, 255, 255, 85, 91, 85, 91, 85, 91, 85, 91, 85, 91, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 192, 0, 234, 170, 255, 255, 154, 170, 218, 169, 63, 230, 16, 122, 16, 122, 21, 121, 17, 54, 21, 122, 255, 255, 0, 0, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 170, 170, 215, 255, 252, 68, 206, 85, 204, 68, 206, 170, 223, 255, 213, 85, 191, 255, 255, 255, 0, 0, 87, 245, 95, 61, 115, 243, 184, 11, 94, 173, 171, 250, 8, 8, 32, 32, 128, 128, 2, 0, 8, 0, 32, 0, 128, 42, 0, 32, 0, 0, 85, 85, 0, 0, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 17, 58, 21, 58, 17, 54, 21, 121, 209, 58, 127, 250, 85, 118, 255, 249, 202, 170, 202, 170, 202, 170, 202, 170, 203, 255, 205, 68, 204, 85, 204, 68, 190, 167, 211, 167, 220, 231, 207, 55, 243, 183, 204, 183, 205, 231, 207, 231, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 32, 0, 32, 2, 160, 8, 0, 32, 0, 128, 2, 2, 8, 8, 32, 32, 64, 15, 64, 0, 79, 240, 207, 240, 79, 0, 64, 0, 85, 85, 255, 255, 240, 1, 0, 1, 15, 241, 15, 195, 15, 241, 0, 1, 85, 85, 255, 255, 229, 85, 229, 85, 229, 85, 229, 85, 229, 85, 229, 85, 229, 85, 255, 255, 85, 91, 85, 91, 85, 91, 85, 91, 85, 91, 85, 91, 85, 91, 255, 255, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 0, 3, 170, 171, 255, 255, 207, 31, 205, 87, 207, 255, 192, 0, 234, 170, 255, 255, 213, 85, 191, 255, 85, 85, 0, 0, 255, 255, 85, 91, 85, 91, 85, 91, 85, 91, 255, 255, 85, 85, 0, 0, 255, 255, 229, 85, 229, 85, 229, 85, 229, 85, 255, 255, 154, 170, 154, 169, 90, 166, 170, 154, 170, 106, 169, 169, 166, 166, 154, 154, 0, 32, 0, 32, 128, 42, 32, 0, 8, 0, 2, 0, 128, 128, 32, 32, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 0, 0, 85, 85, 0, 0, 241, 243, 213, 115, 255, 243, 0, 3, 170, 171, 255, 255, 85, 87, 255, 254, 204, 68, 205, 85, 204, 72, 207, 255, 205, 85, 207, 255, 205, 85, 207, 255, 197, 231, 202, 231, 213, 231, 213, 231, 85, 231, 255, 231, 85, 231, 255, 231, 140, 128, 51, 224, 60, 188, 225, 59, 60, 91, 226, 85, 61, 127, 255, 235, 8, 56, 35, 236, 188, 143, 238, 19, 100, 124, 215, 171, 250, 124, 215, 192, 128, 131, 32, 32, 8, 13, 2, 254, 3, 116, 0, 249, 14, 244, 14, 253, 120, 8, 176, 32, 112, 128, 191, 0, 157, 192, 111, 0, 159, 176, 127, 176, 191, 200, 226, 50, 232, 187, 234, 63, 232, 191, 234, 63, 213, 127, 234, 63, 143, 252, 255, 255, 255, 255, 255, 255, 255, 195, 255, 0, 195, 12, 193, 0, 232, 182, 234, 54, 232, 181, 234, 54, 232, 182, 234, 54, 255, 246, 213, 118, 170, 163, 170, 139, 85, 87, 170, 139, 170, 163, 170, 139, 170, 163, 170, 139, 170, 170, 85, 85, 85, 85, 255, 255, 170, 170, 85, 85, 85, 85, 255, 255, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 213, 118, 213, 118, 213, 118, 213, 127, 255, 213, 213, 85, 213, 85, 127, 255, 170, 163, 170, 139, 170, 163, 255, 255, 85, 87, 85, 87, 85, 87, 255, 253, 192, 0, 223, 255, 205, 84, 205, 80, 206, 128, 207, 3, 204, 12, 204, 17, 0, 3, 255, 247, 12, 115, 17, 115, 142, 179, 47, 243, 255, 243, 85, 115, 204, 207, 205, 53, 204, 181, 206, 186, 206, 191, 207, 255, 205, 85, 207, 255, 255, 243, 213, 255, 235, 3, 235, 187, 235, 187, 243, 171, 68, 255, 48, 51, 190, 150, 227, 22, 56, 78, 225, 39, 248, 223, 235, 239, 59, 119, 46, 239, 182, 188, 81, 227, 216, 76, 209, 19, 247, 159, 251, 235, 253, 236, 51, 48, 13, 191, 13, 106, 3, 82, 7, 127, 7, 90, 5, 210, 9, 127, 32, 21, 254, 112, 169, 112, 85, 192, 253, 208, 85, 208, 87, 80, 253, 64, 86, 32, 232, 183, 234, 54, 232, 181, 234, 54, 232, 182, 234, 54, 213, 118, 234, 54, 192, 0, 189, 7, 112, 255, 192, 255, 195, 247, 191, 93, 171, 245, 170, 143, 106, 106, 154, 154, 166, 166, 169, 169, 170, 106, 170, 154, 90, 166, 154, 169, 158, 43, 156, 171, 158, 43, 156, 171, 158, 43, 156, 171, 159, 255, 157, 87, 255, 255, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 128, 128, 32, 32, 200, 8, 242, 2, 240, 128, 192, 32, 224, 8, 224, 2, 170, 170, 87, 255, 92, 0, 252, 0, 174, 170, 94, 255, 254, 192, 206, 202, 170, 170, 255, 213, 0, 53, 0, 63, 170, 181, 255, 181, 3, 191, 171, 187, 218, 170, 154, 169, 90, 166, 170, 154, 234, 106, 121, 169, 230, 166, 154, 154, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 205, 212, 206, 226, 206, 200, 206, 32, 204, 192, 223, 255, 192, 0, 191, 255, 192, 115, 2, 179, 10, 179, 42, 179, 250, 243, 255, 247, 0, 3, 255, 254, 139, 255, 62, 2, 223, 255, 222, 2, 223, 255, 222, 2, 255, 255, 192, 0, 3, 252, 252, 3, 223, 255, 220, 3, 223, 255, 220, 3, 255, 255, 0, 0, 3, 255, 12, 0, 12, 0, 12, 0, 14, 170, 14, 255, 254, 199, 206, 255, 15, 240, 252, 60, 223, 243, 220, 51, 223, 243, 220, 51, 255, 255, 0, 3, 192, 0, 255, 255, 223, 255, 237, 7, 239, 255, 238, 171, 223, 255, 192, 0, 0, 0, 255, 255, 93, 127, 93, 127, 12, 63, 12, 63, 255, 255, 0, 0, 255, 192, 0, 48, 0, 48, 0, 48, 170, 176, 255, 176, 255, 191, 255, 187, 0, 3, 255, 255, 93, 119, 93, 123, 174, 187, 12, 59, 255, 247, 0, 3, 169, 170, 169, 171, 171, 254, 172, 68, 180, 100, 177, 254, 178, 215, 175, 85, 170, 106, 234, 106, 191, 234, 17, 58, 25, 30, 191, 78, 215, 142, 85, 250, 206, 200, 206, 255, 206, 170, 206, 251, 205, 87, 195, 255, 192, 0, 255, 95, 3, 183, 255, 183, 170, 183, 255, 183, 171, 123, 255, 235, 0, 3, 245, 255, 192, 0, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 0, 3, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 255, 192, 0, 229, 166, 230, 153, 233, 149, 229, 153, 234, 170, 255, 255, 255, 255, 0, 3, 154, 91, 154, 107, 154, 91, 150, 91, 170, 171, 255, 255, 192, 0, 213, 85, 207, 255, 207, 255, 204, 3, 206, 171, 206, 171, 223, 255, 0, 0, 85, 85, 255, 255, 213, 255, 64, 127, 21, 63, 192, 255, 255, 255, 206, 255, 206, 255, 206, 170, 205, 85, 206, 170, 205, 85, 195, 255, 192, 0, 0, 3, 85, 87, 255, 243, 170, 179, 255, 243, 0, 51, 170, 179, 255, 247, 255, 255, 221, 117, 239, 255, 236, 48, 239, 255, 223, 255, 192, 0, 255, 255, 255, 255, 213, 117, 255, 250, 234, 176, 192, 63, 255, 255, 0, 0, 255, 255, 255, 183, 255, 183, 170, 183, 255, 119, 170, 183, 85, 123, 255, 235, 0, 3, 255, 255, 213, 119, 255, 251, 197, 123, 202, 187, 255, 247, 0, 3, 255, 255, 255, 215, 68, 63, 85, 55, 1, 55, 170, 183, 255, 247, 85, 87, 255, 254, 170, 171, 85, 87, 85, 87, 255, 255, 170, 171, 85, 87, 85, 87, 255, 255, 127, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 213, 85, 255, 255, 255, 253, 0, 3, 170, 163, 170, 163, 170, 163, 170, 163, 85, 87, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 247, 119, 221, 221, 247, 119, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 119, 119, 221, 223, 119, 119, 255, 255, 213, 90, 213, 106, 213, 170, 255, 255, 192, 0, 192, 0, 192, 0, 192, 0, 170, 171, 170, 171, 170, 171, 255, 255, 0, 11, 0, 11, 0, 11, 0, 11] } }, reds_house: { blocks: [{ type: "Buffer", data: [170, 171, 170, 171, 186, 187, 186, 187, 170, 171, 170, 171, 186, 187, 186, 187] }, { type: "Buffer", data: [2, 3, 38, 39, 18, 19, 54, 55, 2, 3, 44, 42, 18, 19, 60, 58] }, { type: "Buffer", data: [40, 41, 2, 3, 56, 57, 18, 19, 42, 43, 2, 3, 58, 59, 18, 19] }, { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [38, 41, 38, 41, 48, 49, 48, 49, 34, 35, 34, 35, 50, 51, 50, 51] }, { type: "Buffer", data: [0, 0, 36, 37, 0, 0, 52, 53, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 14, 15, 1, 1, 30, 31, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [0, 0, 36, 37, 0, 0, 52, 53, 1, 1, 12, 13, 1, 1, 28, 29] }, { type: "Buffer", data: [0, 0, 36, 37, 0, 0, 52, 53, 1, 1, 10, 11, 1, 1, 26, 27] }, { type: "Buffer", data: [0, 0, 36, 37, 0, 0, 52, 53, 1, 1, 6, 7, 1, 1, 22, 23] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 20, 20, 20, 20] }, { type: "Buffer", data: [45, 46, 1, 1, 61, 62, 1, 1, 61, 62, 1, 1, 63, 47, 1, 1] }, { type: "Buffer", data: [1, 1, 6, 7, 1, 1, 22, 23, 1, 1, 14, 15, 1, 1, 30, 31] }, { type: "Buffer", data: [2, 3, 1, 1, 18, 19, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [64, 65, 0, 0, 32, 33, 38, 39, 66, 67, 44, 42, 50, 51, 60, 58] }, { type: "Buffer", data: [0, 0, 0, 0, 39, 41, 0, 0, 42, 43, 1, 1, 58, 59, 1, 1] }, { type: "Buffer", data: [68, 69, 1, 1, 8, 9, 1, 1, 70, 71, 1, 1, 24, 25, 1, 1] }], tiles: { type: "Buffer", data: [170, 170, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 128, 0, 32, 0, 8, 0, 2, 0, 8, 128, 32, 32, 128, 8, 0, 2, 128, 0, 32, 0, 8, 0, 2, 0, 8, 128, 35, 255, 140, 0, 12, 42, 128, 0, 32, 0, 8, 0, 2, 0, 8, 128, 255, 224, 0, 56, 168, 50, 0, 0, 102, 102, 85, 85, 170, 170, 85, 85, 105, 85, 105, 85, 85, 85, 255, 255, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 255, 255, 15, 255, 50, 170, 63, 255, 202, 170, 202, 170, 213, 85, 223, 255, 222, 169, 255, 240, 170, 172, 255, 252, 170, 171, 170, 171, 85, 87, 255, 247, 85, 119, 62, 150, 231, 86, 58, 110, 233, 103, 249, 223, 235, 239, 59, 51, 12, 3, 182, 188, 85, 235, 217, 93, 217, 155, 247, 159, 251, 235, 252, 236, 60, 60, 253, 85, 253, 85, 253, 85, 253, 85, 255, 255, 255, 254, 255, 234, 254, 175, 85, 85, 85, 127, 87, 235, 126, 175, 234, 239, 174, 255, 239, 87, 255, 87, 0, 0, 0, 0, 0, 0, 0, 3, 0, 63, 3, 243, 171, 187, 171, 255, 0, 63, 3, 243, 63, 51, 243, 255, 51, 3, 255, 3, 3, 3, 3, 63, 128, 0, 47, 255, 52, 0, 54, 86, 55, 255, 48, 0, 177, 169, 48, 0, 128, 0, 224, 0, 120, 0, 122, 0, 120, 128, 56, 32, 56, 8, 56, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140, 42, 44, 42, 12, 0, 14, 170, 14, 255, 46, 213, 142, 230, 15, 233, 168, 48, 168, 48, 0, 48, 170, 176, 255, 176, 87, 176, 107, 184, 171, 242, 85, 85, 85, 105, 85, 105, 85, 85, 170, 170, 85, 85, 102, 102, 0, 0, 255, 255, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 255, 255, 222, 9, 222, 169, 221, 85, 221, 85, 221, 85, 223, 255, 213, 213, 127, 255, 85, 119, 85, 119, 85, 119, 85, 119, 85, 119, 255, 247, 87, 87, 255, 253, 13, 191, 13, 106, 3, 82, 3, 127, 3, 90, 0, 210, 0, 63, 0, 0, 254, 112, 169, 112, 85, 192, 253, 192, 85, 192, 87, 0, 252, 0, 0, 0, 234, 239, 175, 255, 239, 87, 255, 167, 215, 167, 215, 167, 215, 167, 215, 87, 87, 87, 167, 87, 167, 87, 167, 87, 167, 127, 167, 247, 191, 183, 119, 183, 87, 3, 255, 3, 215, 3, 215, 63, 215, 243, 215, 51, 215, 255, 255, 255, 3, 243, 63, 51, 243, 255, 51, 87, 255, 87, 85, 87, 85, 87, 255, 255, 181, 85, 47, 255, 11, 170, 3, 3, 8, 252, 32, 32, 128, 8, 0, 2, 120, 240, 235, 12, 172, 71, 240, 3, 197, 62, 197, 232, 48, 200, 15, 2, 206, 255, 206, 255, 206, 170, 205, 85, 206, 170, 205, 85, 195, 255, 192, 0, 255, 183, 255, 183, 170, 183, 255, 119, 170, 183, 85, 123, 255, 235, 0, 3, 218, 170, 223, 255, 222, 187, 222, 179, 220, 51, 223, 251, 223, 255, 218, 170, 170, 167, 255, 247, 174, 183, 12, 55, 12, 55, 255, 247, 255, 247, 170, 167, 170, 170, 127, 255, 123, 128, 127, 255, 187, 128, 127, 255, 123, 128, 127, 255, 170, 170, 255, 253, 0, 237, 255, 253, 0, 238, 255, 253, 0, 237, 255, 253, 63, 255, 192, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 190, 170, 195, 234, 20, 58, 255, 252, 0, 3, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 85, 85, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 85, 95, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 245, 85, 255, 255, 202, 170, 202, 170, 255, 255, 213, 85, 213, 255, 255, 128, 249, 170, 255, 255, 170, 163, 170, 163, 255, 255, 85, 87, 255, 87, 2, 255, 170, 111, 255, 255, 170, 163, 170, 163, 255, 255, 85, 87, 85, 87, 85, 87, 255, 255, 213, 85, 223, 255, 222, 238, 222, 204, 220, 204, 220, 238, 223, 238, 223, 255, 85, 87, 255, 247, 235, 183, 235, 183, 195, 55, 195, 55, 255, 247, 255, 247, 223, 255, 218, 171, 218, 171, 218, 171, 218, 171, 255, 255, 218, 170, 191, 255, 255, 247, 234, 167, 234, 167, 234, 167, 234, 167, 255, 255, 170, 167, 255, 254, 187, 128, 127, 255, 123, 128, 127, 255, 170, 170, 85, 85, 85, 85, 85, 85, 0, 238, 255, 253, 0, 237, 255, 253, 170, 170, 85, 85, 85, 85, 85, 85, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 171, 60, 171, 207, 172, 189, 172, 243, 171, 202, 169, 202, 169, 114, 170, 95, 20, 58, 195, 234, 254, 58, 223, 58, 167, 234, 167, 106, 157, 106, 245, 170, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 170, 167, 255, 255, 85, 85, 255, 255, 85, 85, 255, 255, 170, 170, 170, 170, 0, 0, 255, 255, 85, 87, 255, 252, 93, 92, 254, 172, 174, 172, 175, 252, 0, 0, 255, 255, 213, 85, 63, 255, 53, 117, 50, 191, 50, 186, 63, 250, 0, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 0, 11, 255, 255, 202, 170, 202, 170, 255, 255, 213, 85, 213, 85, 213, 85, 255, 255, 171, 255, 92, 0, 92, 0, 92, 0, 174, 170, 94, 255, 254, 199, 206, 255, 255, 234, 0, 53, 0, 53, 0, 53, 170, 186, 255, 181, 255, 191, 255, 187, 215, 255, 252, 68, 206, 85, 204, 68, 206, 170, 223, 255, 213, 85, 191, 255, 255, 215, 68, 63, 85, 55, 1, 55, 170, 183, 255, 247, 85, 87, 255, 254, 12, 0, 59, 192, 62, 188, 233, 187, 61, 91, 230, 85, 61, 127, 255, 235, 0, 48, 3, 236, 62, 159, 238, 87, 101, 125, 215, 171, 250, 124, 215, 192, 0, 3, 0, 0, 0, 13, 0, 254, 3, 116, 0, 249, 14, 244, 14, 253, 112, 0, 176, 0, 112, 0, 191, 0, 157, 192, 111, 0, 159, 176, 127, 176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, ship: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [5, 51, 51, 51, 21, 1, 1, 1, 21, 1, 1, 1, 21, 1, 1, 1] }, { type: "Buffer", data: [51, 51, 51, 51, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [51, 51, 51, 6, 1, 1, 1, 22, 1, 1, 1, 22, 1, 1, 1, 22] }, { type: "Buffer", data: [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4] }, { type: "Buffer", data: [1, 1, 1, 1, 17, 17, 17, 17, 2, 3, 16, 16, 18, 19, 18, 19] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 9, 10, 10, 12, 25, 26, 44, 28] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 13, 29, 7, 8, 29, 13, 23, 24] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 7, 8, 13, 29, 23, 24, 29, 13] }, { type: "Buffer", data: [14, 15, 16, 16, 30, 31, 18, 19, 13, 29, 13, 29, 29, 13, 29, 13] }, { type: "Buffer", data: [2, 3, 16, 16, 18, 19, 18, 19, 13, 29, 13, 29, 29, 13, 29, 13] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 13, 29, 13, 29, 29, 13, 29, 13] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [21, 1, 1, 1, 21, 1, 1, 1, 21, 1, 1, 1, 21, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 22, 1, 1, 1, 22, 1, 1, 1, 22, 1, 1, 1, 22] }, { type: "Buffer", data: [21, 1, 1, 1, 50, 17, 17, 17, 32, 16, 16, 16, 48, 19, 18, 19] }, { type: "Buffer", data: [35, 4, 4, 4, 35, 4, 4, 4, 35, 4, 4, 4, 35, 4, 4, 4] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 21, 1, 1, 1, 21, 1, 1, 1] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22, 1, 1, 1, 22] }, { type: "Buffer", data: [1, 1, 1, 22, 17, 17, 17, 34, 16, 16, 16, 33, 18, 19, 18, 49] }, { type: "Buffer", data: [51, 6, 4, 4, 1, 22, 74, 74, 1, 38, 51, 51, 1, 1, 1, 1] }, { type: "Buffer", data: [5, 51, 51, 51, 21, 1, 1, 1, 37, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [4, 4, 4, 4, 4, 4, 4, 4, 35, 4, 4, 4, 35, 4, 4, 4] }, { type: "Buffer", data: [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 39, 40, 4, 4, 55, 56] }, { type: "Buffer", data: [41, 42, 4, 4, 57, 58, 4, 4, 35, 4, 4, 4, 35, 4, 4, 4] }, { type: "Buffer", data: [1, 1, 1, 1, 17, 17, 17, 17, 2, 3, 14, 15, 18, 19, 30, 31] }, { type: "Buffer", data: [39, 40, 4, 4, 55, 56, 4, 4, 35, 4, 4, 4, 35, 4, 4, 4] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 36, 36, 36, 36, 52, 52, 52, 52] }, { type: "Buffer", data: [32, 16, 16, 33, 48, 19, 18, 49, 4, 4, 39, 40, 4, 4, 55, 56] }, { type: "Buffer", data: [16, 16, 16, 33, 18, 19, 18, 49, 4, 4, 4, 4, 4, 4, 4, 4] }, { type: "Buffer", data: [20, 20, 46, 47, 20, 20, 62, 63, 46, 47, 46, 47, 62, 63, 62, 63] }, { type: "Buffer", data: [46, 47, 35, 35, 62, 63, 35, 4, 35, 35, 35, 4, 35, 4, 4, 4] }, { type: "Buffer", data: [46, 47, 35, 35, 62, 63, 35, 4, 46, 47, 35, 4, 62, 63, 35, 4] }, { type: "Buffer", data: [46, 47, 46, 47, 62, 63, 62, 63, 1, 1, 46, 47, 1, 1, 62, 63] }, { type: "Buffer", data: [35, 4, 4, 4, 35, 4, 4, 4, 46, 47, 35, 4, 62, 63, 35, 4] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [35, 35, 35, 35, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4] }, { type: "Buffer", data: [46, 47, 46, 47, 62, 63, 62, 63, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 46, 47, 46, 47, 62, 63, 62, 63] }, { type: "Buffer", data: [45, 35, 4, 4, 61, 35, 4, 4, 45, 35, 4, 4, 61, 35, 4, 4] }, { type: "Buffer", data: [1, 1, 1, 1, 1, 1, 1, 1, 20, 20, 1, 1, 20, 20, 1, 1] }, { type: "Buffer", data: [35, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4] }, { type: "Buffer", data: [25, 64, 65, 28, 25, 80, 81, 28, 25, 44, 26, 28, 25, 44, 44, 28] }, { type: "Buffer", data: [10, 10, 10, 10, 44, 64, 65, 44, 44, 80, 81, 44, 44, 44, 26, 44] }, { type: "Buffer", data: [25, 44, 44, 28, 11, 59, 60, 11, 13, 29, 13, 29, 29, 13, 29, 13] }, { type: "Buffer", data: [10, 10, 10, 10, 44, 53, 53, 44, 44, 53, 53, 44, 44, 44, 44, 44] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 39, 40, 13, 29, 55, 56, 29, 13] }, { type: "Buffer", data: [2, 3, 9, 12, 18, 19, 54, 43, 72, 73, 54, 43, 88, 89, 54, 43] }, { type: "Buffer", data: [2, 3, 16, 16, 18, 19, 84, 85, 13, 29, 66, 67, 29, 13, 23, 24] }, { type: "Buffer", data: [2, 3, 16, 16, 18, 19, 18, 19, 13, 29, 13, 29, 29, 13, 29, 13] }, { type: "Buffer", data: [9, 10, 10, 10, 25, 44, 68, 69, 25, 44, 44, 44, 59, 60, 11, 11] }, { type: "Buffer", data: [10, 12, 13, 29, 44, 28, 29, 13, 44, 28, 13, 29, 59, 60, 29, 13] }, { type: "Buffer", data: [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 41, 42, 4, 4, 57, 58] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 13, 29, 72, 73, 29, 13, 88, 89] }, { type: "Buffer", data: [13, 29, 70, 71, 29, 13, 86, 87, 13, 29, 86, 87, 29, 13, 86, 87] }, { type: "Buffer", data: [2, 3, 16, 16, 9, 10, 10, 12, 25, 26, 44, 28, 11, 11, 11, 11] }, { type: "Buffer", data: [16, 16, 2, 3, 18, 19, 18, 19, 13, 29, 70, 71, 29, 13, 86, 87] }, { type: "Buffer", data: [13, 29, 86, 87, 29, 13, 59, 60, 13, 29, 13, 29, 29, 13, 29, 13] }, { type: "Buffer", data: [21, 1, 1, 1, 21, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }, { type: "Buffer", data: [13, 29, 13, 29, 29, 13, 29, 13, 7, 8, 13, 29, 23, 24, 29, 13] }, { type: "Buffer", data: [14, 15, 2, 3, 30, 31, 18, 19, 13, 29, 70, 71, 29, 13, 86, 87] }, { type: "Buffer", data: [16, 16, 16, 16, 18, 19, 18, 19, 13, 29, 13, 29, 29, 13, 29, 13] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 15, 0, 48, 0, 193, 0, 197, 0, 197, 0, 193, 0, 48, 0, 15, 240, 0, 12, 0, 67, 0, 83, 0, 83, 0, 67, 0, 12, 0, 240, 0, 170, 170, 170, 170, 170, 170, 85, 85, 170, 170, 170, 170, 170, 170, 85, 85, 255, 255, 192, 0, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 255, 255, 0, 3, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 0, 0, 0, 0, 0, 255, 3, 106, 13, 170, 13, 170, 13, 170, 13, 106, 34, 34, 136, 136, 255, 34, 169, 200, 170, 114, 170, 112, 170, 114, 169, 112, 63, 255, 192, 0, 207, 170, 207, 170, 202, 170, 202, 170, 202, 170, 202, 170, 255, 255, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 213, 87, 255, 255, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 252, 0, 3, 170, 243, 170, 243, 170, 163, 170, 163, 170, 163, 170, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63, 255, 53, 85, 53, 85, 53, 85, 53, 85, 53, 85, 53, 85, 0, 0, 255, 252, 85, 92, 85, 92, 85, 92, 85, 92, 85, 92, 95, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 85, 85, 0, 0, 0, 0, 255, 255, 0, 0, 255, 255, 250, 170, 0, 0, 255, 255, 0, 0, 0, 0, 255, 255, 0, 0, 255, 255, 170, 175, 0, 0, 255, 255, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 13, 85, 131, 85, 0, 255, 136, 206, 3, 12, 139, 1, 34, 192, 136, 191, 85, 112, 85, 192, 255, 0, 179, 0, 48, 192, 64, 192, 3, 0, 252, 0, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 202, 170, 175, 234, 176, 58, 207, 206, 207, 207, 224, 43, 234, 179, 122, 190, 95, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 170, 163, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 34, 34, 136, 136, 53, 85, 53, 85, 53, 85, 181, 85, 181, 85, 181, 85, 181, 85, 127, 255, 92, 220, 92, 220, 94, 220, 94, 222, 87, 94, 85, 94, 85, 94, 255, 253, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 192, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 255, 243, 0, 3, 85, 87, 102, 102, 153, 153, 102, 102, 119, 119, 102, 102, 153, 153, 102, 102, 119, 119, 0, 0, 85, 85, 170, 170, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 207, 255, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 255, 240, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 85, 253, 85, 253, 85, 253, 85, 255, 255, 255, 254, 255, 234, 254, 175, 85, 85, 85, 127, 87, 235, 126, 175, 234, 239, 174, 255, 239, 87, 255, 87, 0, 0, 0, 0, 0, 0, 0, 3, 0, 63, 3, 243, 171, 187, 171, 255, 0, 63, 3, 243, 63, 51, 243, 255, 51, 3, 255, 3, 3, 3, 3, 63, 255, 255, 85, 87, 255, 247, 238, 183, 204, 55, 255, 247, 255, 247, 85, 119, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 159, 246, 120, 45, 235, 235, 236, 59, 123, 237, 124, 61, 123, 237, 124, 61, 255, 255, 192, 0, 207, 85, 207, 0, 196, 170, 196, 170, 196, 170, 196, 170, 255, 255, 0, 3, 85, 247, 0, 247, 170, 151, 170, 151, 170, 151, 170, 151, 192, 0, 192, 0, 255, 255, 192, 0, 255, 255, 250, 170, 192, 0, 255, 255, 0, 3, 0, 3, 255, 255, 0, 3, 255, 255, 250, 171, 0, 3, 255, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 207, 255, 192, 0, 213, 85, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 170, 85, 85, 0, 0, 175, 250, 179, 206, 193, 67, 245, 95, 245, 95, 193, 67, 179, 206, 175, 250, 255, 255, 213, 85, 223, 255, 222, 186, 220, 48, 223, 255, 223, 255, 221, 85, 234, 239, 175, 255, 239, 87, 255, 167, 215, 167, 215, 167, 215, 167, 215, 87, 87, 87, 167, 87, 167, 87, 167, 87, 167, 127, 167, 247, 191, 183, 119, 183, 87, 3, 255, 3, 215, 3, 215, 63, 215, 243, 215, 51, 215, 255, 255, 255, 3, 243, 63, 51, 243, 255, 51, 87, 255, 87, 85, 87, 85, 87, 255, 255, 255, 255, 85, 85, 255, 255, 213, 117, 213, 127, 213, 85, 213, 85, 191, 255, 255, 255, 85, 85, 255, 255, 93, 87, 253, 87, 85, 87, 85, 87, 255, 254, 123, 237, 124, 61, 123, 237, 127, 253, 120, 45, 229, 91, 231, 219, 255, 255, 196, 170, 207, 85, 207, 85, 202, 170, 213, 85, 213, 85, 213, 85, 255, 255, 170, 151, 85, 247, 85, 247, 170, 167, 85, 87, 85, 87, 85, 87, 255, 255, 170, 170, 170, 175, 170, 240, 171, 5, 172, 95, 172, 114, 177, 186, 177, 175, 170, 170, 250, 170, 15, 170, 124, 234, 203, 58, 235, 58, 255, 78, 150, 206, 3, 85, 3, 85, 3, 255, 3, 170, 13, 170, 13, 170, 13, 170, 13, 106, 85, 226, 85, 200, 255, 226, 170, 200, 170, 114, 170, 112, 170, 114, 169, 112, 175, 250, 176, 14, 226, 171, 224, 11, 226, 171, 224, 11, 213, 91, 255, 255, 191, 234, 192, 58, 170, 46, 128, 46, 170, 46, 128, 46, 149, 94, 255, 254, 63, 255, 192, 0, 198, 255, 203, 128, 203, 128, 203, 128, 207, 255, 240, 0, 255, 255, 0, 0, 255, 230, 0, 186, 0, 186, 0, 186, 255, 254, 0, 3, 0, 0, 0, 15, 0, 245, 3, 85, 13, 85, 13, 95, 13, 117, 15, 213, 34, 34, 200, 136, 126, 34, 87, 136, 85, 226, 213, 200, 117, 226, 95, 200, 102, 102, 153, 153, 102, 102, 119, 119, 102, 102, 153, 153, 102, 102, 119, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 171, 172, 107, 172, 90, 167, 5, 169, 240, 170, 95, 170, 170, 170, 170, 89, 206, 102, 250, 255, 58, 80, 218, 15, 106, 245, 170, 170, 170, 170, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 3, 106, 255, 106, 3, 85, 255, 85, 251, 85, 3, 85, 255, 85, 255, 0, 169, 192, 169, 255, 85, 192, 85, 255, 85, 234, 85, 192, 85, 255, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 224, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 44, 245, 140, 15, 45, 0, 135, 80, 39, 5, 137, 240, 34, 95, 136, 136, 124, 192, 192, 192, 1, 192, 23, 64, 67, 64, 61, 0, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, ship_port: { blocks: [{ type: "Buffer", data: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10] }, { type: "Buffer", data: [58, 58, 58, 58, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 26, 26, 10] }, { type: "Buffer", data: [72, 73, 74, 75, 88, 89, 60, 76, 10, 10, 10, 10, 10, 10, 10, 10] }, { type: "Buffer", data: [58, 58, 58, 58, 20, 20, 20, 20, 20, 20, 2, 3, 16, 17, 18, 19] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 4, 5, 6, 7, 0, 21, 22, 23] }, { type: "Buffer", data: [50, 59, 20, 20, 50, 59, 20, 20, 9, 9, 11, 11, 24, 25, 24, 25] }, { type: "Buffer", data: [58, 58, 58, 58, 20, 20, 20, 20, 12, 13, 14, 15, 28, 29, 30, 31] }, { type: "Buffer", data: [32, 33, 34, 35, 48, 33, 34, 51, 64, 65, 66, 67, 20, 81, 82, 83] }, { type: "Buffer", data: [36, 37, 38, 39, 52, 53, 54, 55, 68, 69, 69, 69, 85, 85, 85, 85] }, { type: "Buffer", data: [40, 41, 40, 41, 56, 57, 56, 57, 69, 69, 69, 69, 85, 85, 85, 85] }, { type: "Buffer", data: [44, 45, 46, 47, 62, 61, 62, 47, 69, 77, 78, 79, 85, 93, 90, 91] }, { type: "Buffer", data: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20] }, { type: "Buffer", data: [86, 87, 86, 87, 1, 80, 1, 80, 86, 87, 86, 87, 1, 80, 1, 80] }, { type: "Buffer", data: [92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92] }, { type: "Buffer", data: [49, 49, 20, 20, 49, 49, 20, 20, 49, 49, 49, 49, 49, 49, 49, 49] }, { type: "Buffer", data: [49, 49, 20, 20, 49, 49, 20, 20, 49, 49, 20, 20, 49, 49, 20, 20] }, { type: "Buffer", data: [20, 20, 20, 20, 20, 20, 20, 20, 49, 49, 49, 49, 49, 49, 49, 49] }, { type: "Buffer", data: [58, 58, 58, 58, 49, 49, 20, 20, 49, 49, 20, 20, 49, 49, 20, 20] }, { type: "Buffer", data: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 84, 63, 10, 10, 8, 71] }, { type: "Buffer", data: [50, 59, 49, 49, 50, 59, 49, 49, 50, 59, 20, 20, 50, 59, 20, 20] }, { type: "Buffer", data: [49, 49, 49, 49, 49, 49, 49, 49, 20, 20, 20, 20, 20, 20, 20, 20] }], tiles: { type: "Buffer", data: [240, 192, 240, 0, 192, 192, 3, 192, 195, 192, 195, 192, 195, 192, 195, 192, 230, 170, 229, 85, 234, 170, 255, 255, 221, 85, 223, 255, 221, 85, 191, 255, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 127, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 255, 255, 151, 187, 92, 5, 80, 64, 65, 20, 15, 87, 240, 127, 207, 207, 60, 60, 60, 60, 240, 5, 83, 127, 252, 192, 195, 3, 13, 12, 13, 12, 13, 48, 13, 48, 13, 255, 255, 245, 85, 95, 255, 240, 0, 192, 3, 192, 12, 192, 15, 192, 58, 199, 240, 252, 49, 48, 63, 192, 192, 0, 192, 0, 192, 128, 192, 224, 48, 193, 68, 193, 68, 192, 0, 63, 255, 14, 176, 92, 53, 87, 213, 0, 0, 85, 85, 85, 85, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 136, 170, 162, 170, 170, 170, 170, 170, 138, 170, 42, 34, 138, 138, 170, 170, 5, 80, 64, 65, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 80, 64, 65, 255, 240, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 5, 80, 64, 65, 20, 0, 85, 21, 244, 21, 15, 255, 15, 94, 0, 253, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 255, 255, 213, 94, 255, 253, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 253, 69, 215, 80, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 23, 65, 78, 81, 125, 5, 80, 64, 67, 20, 63, 87, 215, 126, 95, 229, 240, 223, 64, 243, 240, 15, 229, 249, 87, 181, 254, 127, 245, 123, 14, 215, 13, 234, 250, 213, 85, 123, 252, 247, 80, 183, 176, 93, 112, 170, 176, 85, 67, 170, 195, 85, 195, 5, 80, 64, 65, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 48, 13, 252, 13, 252, 13, 252, 13, 252, 13, 252, 13, 252, 13, 252, 13, 192, 202, 195, 2, 205, 87, 242, 168, 197, 85, 202, 170, 194, 170, 192, 170, 184, 53, 238, 48, 239, 176, 238, 240, 174, 0, 174, 128, 174, 128, 174, 160, 85, 127, 173, 170, 186, 159, 154, 127, 234, 127, 234, 127, 234, 95, 235, 85, 255, 213, 170, 158, 255, 215, 255, 247, 255, 247, 255, 247, 255, 215, 85, 87, 175, 250, 176, 14, 192, 3, 224, 11, 186, 174, 95, 245, 94, 181, 151, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 0, 0, 0, 3, 0, 12, 0, 242, 3, 85, 4, 170, 1, 85, 95, 237, 48, 215, 203, 255, 174, 234, 178, 234, 194, 234, 194, 234, 130, 234, 234, 173, 85, 87, 255, 254, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 254, 208, 87, 113, 170, 236, 213, 125, 250, 191, 253, 95, 251, 175, 251, 87, 5, 237, 67, 159, 30, 112, 121, 192, 119, 0, 231, 0, 220, 21, 220, 26, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 234, 170, 213, 85, 234, 170, 213, 85, 234, 170, 213, 85, 234, 170, 213, 85, 170, 195, 85, 195, 170, 195, 85, 195, 170, 195, 85, 195, 170, 195, 85, 195, 195, 192, 195, 192, 195, 192, 195, 192, 195, 192, 195, 192, 195, 192, 195, 192, 252, 13, 252, 13, 252, 13, 240, 13, 240, 3, 240, 3, 240, 0, 236, 0, 192, 42, 192, 10, 192, 2, 192, 0, 112, 0, 127, 255, 213, 85, 191, 255, 174, 160, 174, 168, 174, 168, 174, 170, 46, 170, 238, 170, 238, 170, 237, 85, 155, 85, 185, 245, 185, 95, 175, 85, 170, 191, 170, 170, 170, 170, 85, 85, 85, 95, 85, 127, 255, 222, 85, 122, 255, 170, 170, 170, 170, 170, 85, 85, 5, 80, 64, 65, 20, 0, 85, 23, 84, 23, 84, 23, 65, 71, 81, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 0, 42, 0, 10, 0, 2, 0, 0, 0, 0, 0, 0, 85, 85, 130, 234, 162, 234, 162, 234, 170, 234, 170, 234, 42, 234, 10, 234, 85, 234, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 251, 171, 251, 87, 251, 171, 251, 87, 251, 171, 251, 87, 251, 171, 251, 87, 240, 26, 240, 26, 252, 26, 204, 21, 115, 0, 112, 192, 76, 63, 83, 14, 15, 240, 120, 45, 52, 28, 117, 93, 120, 45, 120, 45, 69, 85, 81, 80, 213, 85, 255, 255, 213, 85, 255, 255, 213, 85, 255, 255, 213, 85, 255, 255, 170, 195, 85, 195, 170, 195, 85, 195, 170, 64, 85, 112, 170, 176, 85, 112, 195, 192, 195, 0, 192, 48, 0, 240, 48, 240, 240, 60, 240, 60, 240, 60, 236, 2, 59, 2, 58, 202, 14, 186, 14, 175, 3, 170, 2, 250, 2, 175, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 170, 171, 170, 171, 255, 255, 174, 170, 174, 170, 186, 170, 186, 170, 186, 170, 186, 170, 186, 170, 191, 255, 170, 170, 171, 255, 189, 85, 215, 255, 253, 85, 253, 85, 191, 255, 255, 255, 170, 170, 255, 170, 85, 250, 255, 94, 85, 254, 85, 254, 255, 250, 255, 255, 255, 255, 221, 221, 119, 119, 221, 221, 119, 119, 221, 221, 119, 119, 255, 255, 85, 87, 255, 255, 85, 87, 255, 255, 85, 87, 255, 255, 85, 87, 255, 255, 128, 0, 85, 85, 128, 0, 255, 255, 85, 85, 85, 85, 255, 255, 85, 127, 2, 234, 2, 234, 2, 234, 3, 234, 43, 234, 190, 234, 234, 234, 170, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 170, 171, 255, 254, 0, 0, 15, 240, 255, 252, 85, 87, 0, 3, 81, 67, 81, 3, 0, 3, 5, 195, 64, 114, 20, 14, 85, 23, 84, 21, 84, 21, 65, 69, 81, 80, 195, 112, 191, 112, 171, 240, 170, 191, 234, 171, 122, 170, 78, 170, 83, 234, 234, 250, 215, 13, 235, 14, 181, 245, 250, 90, 175, 213, 170, 191, 170, 170, 170, 144, 85, 92, 170, 172, 85, 84, 174, 171, 123, 85, 187, 170, 255, 85, 60, 15, 60, 15, 63, 3, 15, 0, 15, 192, 3, 242, 192, 255, 112, 63, 170, 170, 170, 170, 255, 255, 255, 255, 170, 170, 170, 170, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 67, 68, 67, 0, 3, 255, 252, 14, 176, 92, 53, 87, 213, 0, 0, 85, 85, 85, 87, 85, 252, 87, 172, 94, 112, 94, 112, 121, 112, 121, 112, 255, 253, 14, 171, 57, 87, 57, 87, 57, 87, 57, 87, 57, 87, 13, 107, 85, 85, 85, 85, 255, 255, 255, 255, 170, 170, 85, 85, 128, 0, 128, 0, 85, 85, 85, 85, 255, 245, 255, 221, 170, 221, 85, 221, 0, 221, 0, 221, 0, 221, 85, 221, 0, 221, 255, 221, 85, 93, 85, 93, 255, 245, 253, 85, 171, 255, 175, 234, 191, 255, 190, 213, 171, 213, 175, 213, 191, 215, 190, 221, 255, 255, 170, 170, 255, 255, 85, 85, 85, 85, 85, 85, 85, 87, 213, 93, 174, 171, 181, 87, 218, 175, 85, 95, 90, 189, 85, 237, 91, 181, 254, 176, 170, 155, 85, 91, 170, 171, 255, 255, 85, 119, 255, 247, 85, 119, 255, 254, 5, 126, 64, 67, 20, 0, 85, 21, 84, 21, 84, 21, 65, 69, 81, 80, 170, 170, 250, 170, 63, 234, 87, 255, 84, 63, 84, 23, 65, 69, 81, 80, 170, 255, 170, 170, 170, 170, 170, 170, 255, 234, 255, 255, 79, 255, 81, 95, 0, 0, 15, 240, 63, 255, 213, 85, 192, 0, 193, 4, 193, 68, 192, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 255, 255, 255, 255, 63, 255, 200, 136, 229, 85, 196, 136, 230, 170, 230, 170, 230, 170, 230, 170, 255, 252, 136, 139, 85, 83, 136, 155, 170, 155, 170, 155, 170, 155, 170, 155, 121, 112, 121, 92, 121, 92, 121, 247, 95, 85, 93, 85, 87, 255, 85, 127, 13, 87, 63, 255, 243, 3, 195, 3, 255, 255, 213, 87, 255, 255, 253, 85, 255, 255, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 255, 255, 255, 255, 234, 208, 170, 193, 171, 0, 175, 21, 252, 21, 252, 21, 241, 69, 209, 80, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 170, 191, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, underground: { blocks: [{ type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }, { type: "Buffer", data: [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [11, 12, 11, 12, 12, 11, 12, 11, 11, 12, 11, 12, 12, 11, 12, 11] }, { type: "Buffer", data: [6, 6, 6, 6, 9, 9, 9, 9, 11, 12, 11, 12, 12, 11, 12, 11] }, { type: "Buffer", data: [24, 21, 11, 12, 21, 24, 12, 11, 24, 21, 11, 12, 21, 24, 12, 11] }, { type: "Buffer", data: [11, 12, 3, 4, 12, 11, 19, 20, 11, 12, 11, 12, 12, 11, 12, 11] }, { type: "Buffer", data: [5, 6, 6, 6, 8, 9, 9, 9, 11, 12, 11, 12, 12, 11, 12, 11] }, { type: "Buffer", data: [6, 6, 6, 7, 9, 9, 9, 10, 11, 12, 11, 12, 12, 11, 12, 11] }, { type: "Buffer", data: [11, 12, 11, 12, 12, 11, 12, 11, 24, 21, 11, 12, 21, 24, 12, 11] }, { type: "Buffer", data: [6, 6, 6, 6, 9, 9, 9, 9, 24, 21, 11, 12, 21, 24, 12, 11] }, { type: "Buffer", data: [17, 2, 2, 2, 23, 16, 16, 16, 23, 16, 16, 16, 23, 16, 16, 16] }, { type: "Buffer", data: [2, 2, 2, 18, 16, 16, 16, 22, 16, 16, 16, 22, 16, 16, 16, 22] }, { type: "Buffer", data: [23, 16, 16, 16, 23, 16, 16, 16, 23, 16, 16, 16, 23, 16, 16, 16] }, { type: "Buffer", data: [16, 16, 16, 22, 16, 16, 16, 22, 16, 16, 16, 22, 16, 16, 16, 22] }, { type: "Buffer", data: [2, 2, 2, 2, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16] }, { type: "Buffer", data: [24, 21, 11, 12, 21, 24, 12, 11, 3, 4, 11, 12, 19, 20, 12, 11] }, { type: "Buffer", data: [24, 21, 11, 12, 21, 24, 12, 11, 11, 12, 11, 12, 12, 11, 12, 11] }], tiles: { type: "Buffer", data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 102, 102, 153, 153, 255, 255, 170, 170, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 170, 170, 170, 170, 170, 170, 170, 171, 170, 191, 171, 251, 171, 187, 171, 255, 170, 191, 171, 251, 191, 187, 251, 255, 187, 171, 255, 171, 171, 171, 171, 191, 229, 85, 229, 85, 229, 85, 239, 255, 229, 85, 229, 85, 229, 85, 239, 255, 85, 85, 85, 85, 85, 85, 255, 255, 85, 85, 85, 85, 85, 85, 255, 255, 85, 91, 85, 91, 85, 91, 255, 251, 85, 91, 85, 91, 85, 91, 255, 251, 239, 183, 238, 187, 237, 123, 239, 119, 231, 255, 229, 85, 229, 85, 191, 255, 255, 255, 170, 170, 85, 85, 255, 255, 255, 255, 85, 85, 85, 85, 255, 255, 222, 251, 238, 187, 237, 123, 221, 251, 255, 219, 85, 91, 85, 91, 255, 254, 106, 170, 154, 170, 166, 170, 169, 170, 170, 106, 170, 154, 170, 166, 170, 169, 170, 169, 170, 166, 170, 154, 170, 106, 169, 170, 166, 170, 154, 170, 106, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 234, 170, 239, 255, 239, 255, 239, 255, 239, 255, 239, 255, 239, 255, 255, 255, 170, 171, 255, 251, 255, 251, 255, 251, 255, 251, 255, 251, 255, 251, 171, 171, 255, 171, 255, 171, 255, 191, 255, 251, 255, 187, 255, 255, 255, 255, 171, 251, 191, 187, 251, 255, 187, 255, 255, 255, 255, 255, 255, 255, 255, 255, 102, 103, 153, 157, 102, 118, 153, 217, 103, 102, 157, 153, 118, 102, 217, 153, 255, 251, 255, 251, 255, 251, 255, 251, 255, 251, 255, 251, 255, 251, 255, 251, 239, 255, 239, 255, 239, 255, 239, 255, 239, 255, 239, 255, 239, 255, 239, 255, 230, 102, 185, 153, 110, 102, 155, 153, 102, 230, 153, 185, 102, 110, 153, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } } };
    }
  });

  // src/map.js
  var require_map = __commonJS({
    "src/map.js"(exports, module) {
      var rawLocations = require_locations();
      var rawGfx = require_gfx();
      var deserializeBuffers = (obj) => {
        if (obj.hasOwnProperty("type") && obj.type === "Buffer" && obj.hasOwnProperty("data")) {
          return typeof window === "undefined" ? Buffer.from(obj.data) : Uint8Array.from(obj.data);
        } else {
          Object.keys(obj).forEach((key) => {
            if (typeof obj[key] === "object") {
              if (Array.isArray(obj[key])) {
                obj[key] = obj[key].map(deserializeBuffers);
              } else {
                obj[key] = deserializeBuffers(obj[key]);
              }
            }
          });
          return obj;
        }
      };
      var locations2 = deserializeBuffers(rawLocations).filter((l) => !l.CONSTANT_NAME.startsWith("UNUSED") && !l.CONSTANT_NAME.endsWith("COPY"));
      var gfx2 = deserializeBuffers(rawGfx);
      module.exports = { locations: locations2, gfx: gfx2 };
    }
  });

  // node_modules/three/build/three.module.js
  var REVISION = "141";
  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var CineonToneMapping = 3;
  var ACESFilmicToneMapping = 4;
  var CustomToneMapping = 5;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = 306;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = 36492;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var AdditiveAnimationBlendMode = 2501;
  var LinearEncoding = 3e3;
  var sRGBEncoding = 3001;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var SRGBColorSpace = "srgb";
  var LinearSRGBColorSpace = "srgb-linear";
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var StaticDrawUsage = 35044;
  var GLSL3 = "300 es";
  var _SRGBAFormat = 1035;
  var EventDispatcher = class {
    addEventListener(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
    hasEventListener(type, listener) {
      if (this._listeners === void 0)
        return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
    dispatchEvent(event) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
        event.target = null;
      }
    }
  };
  var _lut = [];
  for (let i = 0; i < 256; i++) {
    _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
  }
  var DEG2RAD = Math.PI / 180;
  var RAD2DEG = 180 / Math.PI;
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toLowerCase();
  }
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  var Vector2 = class {
    constructor(x = 0, y = 0) {
      this.isVector2 = true;
      this.x = x;
      this.y = y;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y;
    }
    cross(v) {
      return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const x = this.x - center.x;
      const y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
    }
  };
  var Matrix3 = class {
    constructor() {
      this.isMatrix3 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp2;
      const m = this.elements;
      tmp2 = m[1];
      m[1] = m[3];
      m[3] = tmp2;
      tmp2 = m[2];
      m[2] = m[6];
      m[6] = tmp2;
      tmp2 = m[5];
      m[5] = m[7];
      m[7] = tmp2;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
      return this;
    }
    scale(sx, sy) {
      const te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    }
    rotate(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      const te = this.elements;
      const a11 = te[0], a12 = te[3], a13 = te[6];
      const a21 = te[1], a22 = te[4], a23 = te[7];
      te[0] = c * a11 + s * a21;
      te[3] = c * a12 + s * a22;
      te[6] = c * a13 + s * a23;
      te[1] = -s * a11 + c * a21;
      te[4] = -s * a12 + c * a22;
      te[7] = -s * a13 + c * a23;
      return this;
    }
    translate(tx, ty) {
      const te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 9; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  function arrayNeedsUint32(array) {
    for (let i = array.length - 1; i >= 0; --i) {
      if (array[i] > 65535)
        return true;
    }
    return false;
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  var FN = {
    [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
    [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
  };
  var ColorManagement = {
    legacyMode: true,
    get workingColorSpace() {
      return LinearSRGBColorSpace;
    },
    set workingColorSpace(colorSpace) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function(color, sourceColorSpace, targetColorSpace) {
      if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
        return color;
      }
      if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
        const fn = FN[sourceColorSpace][targetColorSpace];
        color.r = fn(color.r);
        color.g = fn(color.g);
        color.b = fn(color.b);
        return color;
      }
      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function(color, targetColorSpace) {
      return this.convert(color, this.workingColorSpace, targetColorSpace);
    },
    toWorkingColorSpace: function(color, sourceColorSpace) {
      return this.convert(color, sourceColorSpace, this.workingColorSpace);
    }
  };
  var _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  var _rgb = { r: 0, g: 0, b: 0 };
  var _hslA = { h: 0, s: 0, l: 0 };
  var _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  function toComponents(source, target) {
    target.r = source.r;
    target.g = source.g;
    target.b = source.b;
    return target;
  }
  var Color = class {
    constructor(r, g, b) {
      this.isColor = true;
      this.r = 1;
      this.g = 1;
      this.b = 1;
      if (g === void 0 && b === void 0) {
        return this.set(r);
      }
      return this.setRGB(r, g, b);
    }
    set(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setRGB(r, g, b, colorSpace = LinearSRGBColorSpace) {
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === void 0)
          return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              handleAlpha(color[4]);
              return this;
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              handleAlpha(color[4]);
              return this;
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              const h = parseFloat(color[1]) / 360;
              const s = parseInt(color[2], 10) / 100;
              const l = parseInt(color[3], 10) / 100;
              handleAlpha(color[4]);
              return this.setHSL(h, s, l, colorSpace);
            }
            break;
        }
      } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        const hex = m[1];
        const size = hex.length;
        if (size === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        } else if (size === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
      }
      if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
    setColorName(style, colorSpace = SRGBColorSpace) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex, colorSpace);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
    }
    getHexString(colorSpace = SRGBColorSpace) {
      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    getHSL(target, colorSpace = LinearSRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      const r = _rgb.r, g = _rgb.g, b = _rgb.b;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let hue, saturation;
      const lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getRGB(target, colorSpace = LinearSRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      target.r = _rgb.r;
      target.g = _rgb.g;
      target.b = _rgb.b;
      return target;
    }
    getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      if (colorSpace !== SRGBColorSpace) {
        return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
      }
      return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
    }
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      _hslA.h += h;
      _hslA.s += s;
      _hslA.l += l;
      this.setHSL(_hslA.h, _hslA.s, _hslA.l);
      return this;
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = lerp(_hslA.h, _hslB.h, alpha);
      const s = lerp(_hslA.s, _hslB.s, alpha);
      const l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      if (attribute.normalized === true) {
        this.r /= 255;
        this.g /= 255;
        this.b /= 255;
      }
      return this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r;
      yield this.g;
      yield this.b;
    }
  };
  Color.NAMES = _colorKeywords;
  var _canvas;
  var ImageUtils = class {
    static getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement == "undefined") {
        return image.src;
      }
      let canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === void 0)
          _canvas = createElementNS("canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        const context = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
        return canvas.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas.toDataURL("image/png");
      }
    }
    static sRGBToLinear(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const canvas = createElementNS("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, image.width, image.height);
        const imageData = context.getImageData(0, 0, image.width, image.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i++) {
          data[i] = SRGBToLinear(data[i] / 255) * 255;
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      } else if (image.data) {
        const data = image.data.slice(0);
        for (let i = 0; i < data.length; i++) {
          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
            data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
          } else {
            data[i] = SRGBToLinear(data[i]);
          }
        }
        return {
          data,
          width: image.width,
          height: image.height
        };
      } else {
        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
        return image;
      }
    }
  };
  var Source = class {
    constructor(data = null) {
      this.isSource = true;
      this.uuid = generateUUID();
      this.data = data;
      this.version = 0;
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.images[this.uuid] !== void 0) {
        return meta.images[this.uuid];
      }
      const output = {
        uuid: this.uuid,
        url: ""
      };
      const data = this.data;
      if (data !== null) {
        let url;
        if (Array.isArray(data)) {
          url = [];
          for (let i = 0, l = data.length; i < l; i++) {
            if (data[i].isDataTexture) {
              url.push(serializeImage(data[i].image));
            } else {
              url.push(serializeImage(data[i]));
            }
          }
        } else {
          url = serializeImage(data);
        }
        output.url = url;
      }
      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }
      return output;
    }
  };
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.prototype.slice.call(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  var textureId = 0;
  var Texture = class extends EventDispatcher {
    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
      super();
      this.isTexture = true;
      Object.defineProperty(this, "id", { value: textureId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.source = new Source(image);
      this.mipmaps = [];
      this.mapping = mapping;
      this.wrapS = wrapS;
      this.wrapT = wrapT;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.anisotropy = anisotropy;
      this.format = format;
      this.internalFormat = null;
      this.type = type;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.encoding = encoding;
      this.userData = {};
      this.version = 0;
      this.onUpdate = null;
      this.isRenderTargetTexture = false;
      this.needsPMREMUpdate = false;
    }
    get image() {
      return this.source.data;
    }
    set image(value) {
      this.source.data = value;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (JSON.stringify(this.userData) !== "{}")
        output.userData = this.userData;
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(uv) {
      if (this.mapping !== UVMapping)
        return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
    set needsUpdate(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
  };
  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  var Vector4 = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      this.isVector4 = true;
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setW(w) {
      this.w = w;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== void 0 ? v.w : 1;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z, w = this.w;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
      this.w = 2 * Math.acos(q.w);
      const s = Math.sqrt(1 - q.w * q.w);
      if (s < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m) {
      let angle, x, y, z;
      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this;
      }
      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 1e-3)
        s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
      yield this.w;
    }
  };
  var WebGLRenderTarget = class extends EventDispatcher {
    constructor(width2, height, options = {}) {
      super();
      this.isWebGLRenderTarget = true;
      this.width = width2;
      this.height = height;
      this.depth = 1;
      this.scissor = new Vector4(0, 0, width2, height);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width2, height);
      const image = { width: width2, height, depth: 1 };
      this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.isRenderTargetTexture = true;
      this.texture.flipY = false;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
      this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
      this.samples = options.samples !== void 0 ? options.samples : 0;
    }
    setSize(width2, height, depth = 1) {
      if (this.width !== width2 || this.height !== height || this.depth !== depth) {
        this.width = width2;
        this.height = height;
        this.depth = depth;
        this.texture.image.width = width2;
        this.texture.image.height = height;
        this.texture.image.depth = depth;
        this.dispose();
      }
      this.viewport.set(0, 0, width2, height);
      this.scissor.set(0, 0, width2, height);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.texture.isRenderTargetTexture = true;
      const image = Object.assign({}, source.texture.image);
      this.texture.source = new Source(image);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      if (source.depthTexture !== null)
        this.depthTexture = source.depthTexture.clone();
      this.samples = source.samples;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  var DataArrayTexture = class extends Texture {
    constructor(data = null, width2 = 1, height = 1, depth = 1) {
      super(null);
      this.isDataArrayTexture = true;
      this.image = { data, width: width2, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  var Data3DTexture = class extends Texture {
    constructor(data = null, width2 = 1, height = 1, depth = 1) {
      super(null);
      this.isData3DTexture = true;
      this.image = { data, width: width2, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  var Quaternion = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      this.isQuaternion = true;
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    static slerp(qa, qb, qm, t) {
      console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
      return qm.slerpQuaternions(qa, qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update) {
      if (!(euler && euler.isEuler)) {
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update !== false)
        this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let r = vFrom.dot(vTo) + 1;
      if (r < Number.EPSILON) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0)
        return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q, p) {
      if (p !== void 0) {
        console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
        return this.multiplyQuaternions(q, p);
      }
      return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t) {
      if (t === 0)
        return this;
      if (t === 1)
        return this.copy(qb);
      const x = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        this._onChangeCallback();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
    random() {
      const u1 = Math.random();
      const sqrt1u1 = Math.sqrt(1 - u1);
      const sqrtu1 = Math.sqrt(u1);
      const u2 = 2 * Math.PI * Math.random();
      const u3 = 2 * Math.PI * Math.random();
      return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      return this;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._w;
    }
  };
  var Vector3 = class {
    constructor(x = 0, y = 0, z = 0) {
      this.isVector3 = true;
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(x, y, z) {
      if (z === void 0)
        z = this.z;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    multiply(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
        return this.multiplyVectors(v, w);
      }
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyQuaternion(q) {
      const x = this.x, y = this.y, z = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const ix = qw * x + qy * z - qz * y;
      const iy = qw * y + qz * x - qx * z;
      const iz = qw * z + qx * y - qy * x;
      const iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
        return this.crossVectors(v, w);
      }
      return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0)
        return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0)
        return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    randomDirection() {
      const u = (Math.random() - 0.5) * 2;
      const t = Math.random() * Math.PI * 2;
      const f = Math.sqrt(1 - u ** 2);
      this.x = f * Math.cos(t);
      this.y = f * Math.sin(t);
      this.z = u;
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  };
  var _vector$c = /* @__PURE__ */ new Vector3();
  var _quaternion$4 = /* @__PURE__ */ new Quaternion();
  var Box3 = class {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.isBox3 = true;
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const x = array[i];
        const y = array[i + 1];
        const z = array[i + 2];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromBufferAttribute(attribute) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = attribute.count; i < l; i++) {
        const x = attribute.getX(i);
        const y = attribute.getY(i);
        const z = attribute.getZ(i);
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object, precise = false) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
          const position = geometry.attributes.position;
          for (let i = 0, l = position.count; i < l; i++) {
            _vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
          _box$3.applyMatrix4(object.matrixWorld);
          this.union(_box$3);
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        this.expandByObject(children[i], precise);
      }
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$3.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$3, _v1$7);
      _f2.subVectors(_v0$2, _v2$3);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty())
        this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty())
        return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  var _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  var _vector$b = /* @__PURE__ */ new Vector3();
  var _box$3 = /* @__PURE__ */ new Box3();
  var _v0$2 = /* @__PURE__ */ new Vector3();
  var _v1$7 = /* @__PURE__ */ new Vector3();
  var _v2$3 = /* @__PURE__ */ new Vector3();
  var _f0 = /* @__PURE__ */ new Vector3();
  var _f1 = /* @__PURE__ */ new Vector3();
  var _f2 = /* @__PURE__ */ new Vector3();
  var _center = /* @__PURE__ */ new Vector3();
  var _extents = /* @__PURE__ */ new Vector3();
  var _triangleNormal = /* @__PURE__ */ new Vector3();
  var _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  var _box$2 = /* @__PURE__ */ new Box3();
  var _v1$6 = /* @__PURE__ */ new Vector3();
  var _toFarthestPoint = /* @__PURE__ */ new Vector3();
  var _toPoint = /* @__PURE__ */ new Vector3();
  var Sphere = class {
    constructor(center = new Vector3(), radius = -1) {
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$2.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    expandByPoint(point) {
      _toPoint.subVectors(point, this.center);
      const lengthSq = _toPoint.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        const length = Math.sqrt(lengthSq);
        const missingRadiusHalf = (length - this.radius) * 0.5;
        this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
        this.radius += missingRadiusHalf;
      }
      return this;
    }
    union(sphere) {
      if (this.center.equals(sphere.center) === true) {
        _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
      } else {
        _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
      }
      this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$a = /* @__PURE__ */ new Vector3();
  var _segCenter = /* @__PURE__ */ new Vector3();
  var _segDir = /* @__PURE__ */ new Vector3();
  var _diff = /* @__PURE__ */ new Vector3();
  var _edge1 = /* @__PURE__ */ new Vector3();
  var _edge2 = /* @__PURE__ */ new Vector3();
  var _normal$1 = /* @__PURE__ */ new Vector3();
  var Ray = class {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t, target) {
      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
    recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
    closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      const tca = _vector$a.dot(this.direction);
      const d2 = _vector$a.dot(_vector$a) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t0 < 0 && t1 < 0)
        return null;
      if (t0 < 0)
        return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
      const t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax)
        return null;
      if (tymin > tmin || tmin !== tmin)
        tmin = tymin;
      if (tymax < tmax || tmax !== tmax)
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax)
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
      _edge1.subVectors(b, a);
      _edge2.subVectors(c, a);
      _normal$1.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal$1);
      let sign;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign * _diff.dot(_normal$1);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Matrix4 = class {
    constructor() {
      this.isMatrix4 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
    copyPosition(m) {
      const te = this.elements, me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
    setFromMatrix3(m) {
      const me = m.elements;
      this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
    extractRotation(m) {
      const te = this.elements;
      const me = m.elements;
      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      }
      const te = this.elements;
      const x = euler.x, y = euler.y, z = euler.z;
      const a = Math.cos(x), b = Math.sin(x);
      const c = Math.cos(y), d = Math.sin(y);
      const e = Math.cos(z), f = Math.sin(z);
      if (euler.order === "XYZ") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === "YXZ") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === "ZXY") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === "ZYX") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === "YZX") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === "XZY") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
      const te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
    multiply(m, n) {
      if (n !== void 0) {
        console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
        return this.multiplyMatrices(m, n);
      }
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te = this.elements;
      let tmp2;
      tmp2 = te[1];
      te[1] = te[4];
      te[4] = tmp2;
      tmp2 = te[2];
      te[2] = te[8];
      te[8] = tmp2;
      tmp2 = te[6];
      te[6] = te[9];
      te[9] = tmp2;
      tmp2 = te[3];
      te[3] = te[12];
      te[12] = tmp2;
      tmp2 = te[7];
      te[7] = te[13];
      te[13] = tmp2;
      tmp2 = te[11];
      te[11] = te[14];
      te[14] = tmp2;
      return this;
    }
    setPosition(x, y, z) {
      const te = this.elements;
      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v) {
      const te = this.elements;
      const x = v.x, y = v.y, z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
    getMaxScaleOnAxis() {
      const te = this.elements;
      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    }
    makeRotationX(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationY(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationZ(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const t = 1 - c;
      const x = axis.x, y = axis.y, z = axis.z;
      const tx = t * x, ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    }
    makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
      return this;
    }
    compose(position, quaternion, scale) {
      const te = this.elements;
      const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
      const x2 = x + x, y2 = y + y, z2 = z + z;
      const xx = x * x2, xy = x * y2, xz = x * z2;
      const yy = y * y2, yz = y * z2, zz = z * z2;
      const wx = w * x2, wy = w * y2, wz = w * z2;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te = this.elements;
      let sx = _v1$5.set(te[0], te[1], te[2]).length();
      const sy = _v1$5.set(te[4], te[5], te[6]).length();
      const sz = _v1$5.set(te[8], te[9], te[10]).length();
      const det = this.determinant();
      if (det < 0)
        sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      _m1$2.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
      if (far === void 0) {
        console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      }
      const te = this.elements;
      const x = 2 * near / (right - left);
      const y = 2 * near / (top - bottom);
      const a = (right + left) / (right - left);
      const b = (top + bottom) / (top - bottom);
      const c = -(far + near) / (far - near);
      const d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
      const te = this.elements;
      const w = 1 / (right - left);
      const h = 1 / (top - bottom);
      const p = 1 / (far - near);
      const x = (right + left) * w;
      const y = (top + bottom) * h;
      const z = (far + near) * p;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 16; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  };
  var _v1$5 = /* @__PURE__ */ new Vector3();
  var _m1$2 = /* @__PURE__ */ new Matrix4();
  var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  var _x = /* @__PURE__ */ new Vector3();
  var _y = /* @__PURE__ */ new Vector3();
  var _z = /* @__PURE__ */ new Vector3();
  var _matrix$1 = /* @__PURE__ */ new Matrix4();
  var _quaternion$3 = /* @__PURE__ */ new Quaternion();
  var Euler = class {
    constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
      this.isEuler = true;
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x, y, z, order = this._order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m, order = this._order, update = true) {
      const te = m.elements;
      const m11 = te[0], m12 = te[4], m13 = te[8];
      const m21 = te[1], m22 = te[5], m23 = te[9];
      const m31 = te[2], m32 = te[6], m33 = te[10];
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update === true)
        this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q, order, update) {
      _matrix$1.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix$1, order, update);
    }
    setFromVector3(v, order = this._order) {
      return this.set(v.x, v.y, v.z, order);
    }
    reorder(newOrder) {
      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0)
        this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._order;
    }
    toVector3() {
      console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
    }
  };
  Euler.DefaultOrder = "XYZ";
  Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var Layers = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
    isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  };
  var _object3DId = 0;
  var _v1$4 = /* @__PURE__ */ new Vector3();
  var _q1 = /* @__PURE__ */ new Quaternion();
  var _m1$1 = /* @__PURE__ */ new Matrix4();
  var _target = /* @__PURE__ */ new Vector3();
  var _position$3 = /* @__PURE__ */ new Vector3();
  var _scale$2 = /* @__PURE__ */ new Vector3();
  var _quaternion$2 = /* @__PURE__ */ new Quaternion();
  var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
  var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
  var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
  var _addedEvent = { type: "added" };
  var _removedEvent = { type: "removed" };
  var Object3D = class extends EventDispatcher {
    constructor() {
      super();
      this.isObject3D = true;
      Object.defineProperty(this, "id", { value: _object3DId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = Object3D.DefaultUp.clone();
      const position = new Vector3();
      const rotation = new Euler();
      const quaternion = new Quaternion();
      const scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.animations = [];
      this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(matrix) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
    setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m) {
      this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
      this.quaternion.copy(q);
    }
    rotateOnAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
    rotateOnWorldAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
    rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
    rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
    rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
    translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
    translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
    translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
    localToWorld(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x, y, z) {
      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }
      const parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    }
    add(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    }
    remove(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      const index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }
      return this;
    }
    removeFromParent() {
      const parent = this.parent;
      if (parent !== null) {
        parent.remove(this);
      }
      return this;
    }
    clear() {
      for (let i = 0; i < this.children.length; i++) {
        const object = this.children[i];
        object.parent = null;
        object.dispatchEvent(_removedEvent);
      }
      this.children.length = 0;
      return this;
    }
    attach(object) {
      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      this.add(object);
      object.updateWorldMatrix(false, true);
      return this;
    }
    getObjectById(id) {
      return this.getObjectByProperty("id", id);
    }
    getObjectByName(name) {
      return this.getObjectByProperty("name", name);
    }
    getObjectByProperty(name, value) {
      if (this[name] === value)
        return this;
      for (let i = 0, l = this.children.length; i < l; i++) {
        const child = this.children[i];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    }
    getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
    getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {
    }
    traverse(callback) {
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    }
    traverseVisible(callback) {
      if (this.visible === false)
        return;
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    }
    traverseAncestors(callback) {
      const parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(force);
      }
    }
    updateWorldMatrix(updateParents, updateChildren) {
      const parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      if (updateChildren === true) {
        const children = this.children;
        for (let i = 0, l = children.length; i < l; i++) {
          children[i].updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "")
        object.name = this.name;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      if (this.frustumCulled === false)
        object.frustumCulled = false;
      if (this.renderOrder !== 0)
        object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== "{}")
        object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false)
        object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null)
          object.instanceColor = this.instanceColor.toJSON();
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i = 0, l = shapes.length; i < l; i++) {
              const shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i = 0, l = this.material.length; i < l; i++) {
            uuids.push(serialize(meta.materials, this.material[i]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i = 0; i < this.animations.length; i++) {
          const animation = this.animations[i];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        const nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
        if (shapes.length > 0)
          output.shapes = shapes;
        if (skeletons.length > 0)
          output.skeletons = skeletons;
        if (animations.length > 0)
          output.animations = animations;
        if (nodes.length > 0)
          output.nodes = nodes;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
    clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i = 0; i < source.children.length; i++) {
          const child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  };
  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;
  var _v0$1 = /* @__PURE__ */ new Vector3();
  var _v1$3 = /* @__PURE__ */ new Vector3();
  var _v2$2 = /* @__PURE__ */ new Vector3();
  var _v3$1 = /* @__PURE__ */ new Vector3();
  var _vab = /* @__PURE__ */ new Vector3();
  var _vac = /* @__PURE__ */ new Vector3();
  var _vbc = /* @__PURE__ */ new Vector3();
  var _vap = /* @__PURE__ */ new Vector3();
  var _vbp = /* @__PURE__ */ new Vector3();
  var _vcp = /* @__PURE__ */ new Vector3();
  var Triangle = class {
    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
      this.a = a;
      this.b = b;
      this.c = c;
    }
    static getNormal(a, b, c, target) {
      target.subVectors(c, b);
      _v0$1.subVectors(a, b);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    static getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);
      _v1$3.subVectors(b, a);
      _v2$2.subVectors(point, a);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$2);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$2);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (denom === 0) {
        return target.set(-2, -1, -1);
      }
      const invDenom = 1 / denom;
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
      this.getBarycoord(point, a, b, c, _v3$1);
      return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, _v3$1);
      target.set(0, 0);
      target.addScaledVector(uv1, _v3$1.x);
      target.addScaledVector(uv2, _v3$1.y);
      target.addScaledVector(uv3, _v3$1.z);
      return target;
    }
    static isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);
      _v1$3.subVectors(a, b);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
      const a = this.a, b = this.b, c = this.c;
      let v, w;
      _vab.subVectors(b, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }
      _vbp.subVectors(p, b);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(_vac, w);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b).addScaledVector(_vbc, w);
      }
      const denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  var materialId = 0;
  var Material = class extends EventDispatcher {
    constructor() {
      super();
      this.isMaterial = true;
      Object.defineProperty(this, "id", { value: materialId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Material";
      this.blending = NormalBlending;
      this.side = FrontSide;
      this.vertexColors = false;
      this.opacity = 1;
      this.transparent = false;
      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaToCoverage = false;
      this.premultipliedAlpha = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
      this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(values) {
      if (values === void 0)
        return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }
        if (key === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.color && this.color.isColor)
        data.color = this.color.getHex();
      if (this.roughness !== void 0)
        data.roughness = this.roughness;
      if (this.metalness !== void 0)
        data.metalness = this.metalness;
      if (this.sheen !== void 0)
        data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor)
        data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== void 0)
        data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor)
        data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1)
        data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor)
        data.specular = this.specular.getHex();
      if (this.specularIntensity !== void 0)
        data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor)
        data.specularColor = this.specularColor.getHex();
      if (this.shininess !== void 0)
        data.shininess = this.shininess;
      if (this.clearcoat !== void 0)
        data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0)
        data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.iridescence !== void 0)
        data.iridescence = this.iridescence;
      if (this.iridescenceIOR !== void 0)
        data.iridescenceIOR = this.iridescenceIOR;
      if (this.iridescenceThicknessRange !== void 0)
        data.iridescenceThicknessRange = this.iridescenceThicknessRange;
      if (this.iridescenceMap && this.iridescenceMap.isTexture) {
        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
      }
      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
      }
      if (this.map && this.map.isTexture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture)
        data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture)
        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture)
        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture)
        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
        data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture)
        data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== void 0)
          data.combine = this.combine;
      }
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== void 0)
        data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== void 0)
        data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== void 0)
        data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture)
        data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== void 0)
        data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture)
        data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== void 0)
        data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== void 0)
        data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== void 0)
        data.size = this.size;
      if (this.shadowSide !== null)
        data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== void 0)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending)
        data.blending = this.blending;
      if (this.side !== FrontSide)
        data.side = this.side;
      if (this.vertexColors)
        data.vertexColors = true;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.transparent === true)
        data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      data.colorWrite = this.colorWrite;
      data.stencilWrite = this.stencilWrite;
      data.stencilWriteMask = this.stencilWriteMask;
      data.stencilFunc = this.stencilFunc;
      data.stencilRef = this.stencilRef;
      data.stencilFuncMask = this.stencilFuncMask;
      data.stencilFail = this.stencilFail;
      data.stencilZFail = this.stencilZFail;
      data.stencilZPass = this.stencilZPass;
      if (this.rotation !== void 0 && this.rotation !== 0)
        data.rotation = this.rotation;
      if (this.polygonOffset === true)
        data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0)
        data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0)
        data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== void 0 && this.linewidth !== 1)
        data.linewidth = this.linewidth;
      if (this.dashSize !== void 0)
        data.dashSize = this.dashSize;
      if (this.gapSize !== void 0)
        data.gapSize = this.gapSize;
      if (this.scale !== void 0)
        data.scale = this.scale;
      if (this.dithering === true)
        data.dithering = true;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.alphaToCoverage === true)
        data.alphaToCoverage = this.alphaToCoverage;
      if (this.premultipliedAlpha === true)
        data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true)
        data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round")
        data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round")
        data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true)
        data.flatShading = this.flatShading;
      if (this.visible === false)
        data.visible = false;
      if (this.toneMapped === false)
        data.toneMapped = false;
      if (this.fog === false)
        data.fog = false;
      if (JSON.stringify(this.userData) !== "{}")
        data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRootObject) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0)
          data.textures = textures;
        if (images.length > 0)
          data.images = images;
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (let i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    get vertexTangents() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
      return false;
    }
    set vertexTangents(value) {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  };
  Material.fromType = function() {
    return null;
  };
  var MeshBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshBasicMaterial = true;
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  };
  var _vector$9 = /* @__PURE__ */ new Vector3();
  var _vector2$1 = /* @__PURE__ */ new Vector2();
  var BufferAttribute = class {
    constructor(array, itemSize, normalized) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.isBufferAttribute = true;
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized === true;
      this.usage = StaticDrawUsage;
      this.updateRange = { offset: 0, count: -1 };
      this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
    copyArray(array) {
      this.array.set(array);
      return this;
    }
    copyColorsArray(colors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = colors.length; i < l; i++) {
        let color = colors[i];
        if (color === void 0) {
          console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
          color = new Color();
        }
        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }
      return this;
    }
    copyVector2sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
          vector = new Vector2();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }
      return this;
    }
    copyVector3sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
          vector = new Vector3();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }
      return this;
    }
    copyVector4sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
          vector = new Vector4();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }
      return this;
    }
    applyMatrix3(m) {
      if (this.itemSize === 2) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector2$1.fromBufferAttribute(this, i);
          _vector2$1.applyMatrix3(m);
          this.setXY(i, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector$9.fromBufferAttribute(this, i);
          _vector$9.applyMatrix3(m);
          this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
    applyMatrix4(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix4(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    applyNormalMatrix(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyNormalMatrix(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    transformDirection(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.transformDirection(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
    getX(index) {
      return this.array[index * this.itemSize];
    }
    setX(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    }
    getY(index) {
      return this.array[index * this.itemSize + 1];
    }
    setY(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
    getZ(index) {
      return this.array[index * this.itemSize + 2];
    }
    setZ(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
    getW(index) {
      return this.array[index * this.itemSize + 3];
    }
    setW(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
    setXY(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    }
    setXYZ(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
    setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
      if (this.name !== "")
        data.name = this.name;
      if (this.usage !== StaticDrawUsage)
        data.usage = this.usage;
      if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
        data.updateRange = this.updateRange;
      return data;
    }
  };
  var Uint16BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  };
  var Uint32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint32Array(array), itemSize, normalized);
    }
  };
  var Float32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Float32Array(array), itemSize, normalized);
    }
  };
  var _id$1 = 0;
  var _m1 = /* @__PURE__ */ new Matrix4();
  var _obj = /* @__PURE__ */ new Object3D();
  var _offset = /* @__PURE__ */ new Vector3();
  var _box$1 = /* @__PURE__ */ new Box3();
  var _boxMorphTargets = /* @__PURE__ */ new Box3();
  var _vector$8 = /* @__PURE__ */ new Vector3();
  var BufferGeometry = class extends EventDispatcher {
    constructor() {
      super();
      this.isBufferGeometry = true;
      Object.defineProperty(this, "id", { value: _id$1++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = { start: 0, count: Infinity };
      this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    }
    getAttribute(name) {
      return this.attributes[name];
    }
    setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
    deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    hasAttribute(name) {
      return this.attributes[name] !== void 0;
    }
    addGroup(start, count, materialIndex = 0) {
      this.groups.push({
        start,
        count,
        materialIndex
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
    applyQuaternion(q) {
      _m1.makeRotationFromQuaternion(q);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateX(angle) {
      _m1.makeRotationX(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateY(angle) {
      _m1.makeRotationY(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateZ(angle) {
      _m1.makeRotationZ(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    translate(x, y, z) {
      _m1.makeTranslation(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    scale(x, y, z) {
      _m1.makeScale(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
    center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
    setFromPoints(points) {
      const position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
      return this;
    }
    computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _box$1.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$1.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$1.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$1.min);
              this.boundingBox.expandByPoint(_box$1.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$1.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
              _box$1.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
              _box$1.expandByPoint(_vector$8);
            } else {
              _box$1.expandByPoint(_boxMorphTargets.min);
              _box$1.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$1.getCenter(center);
        let maxRadiusSq = 0;
        for (let i = 0, il = position.count; i < il; i++) {
          _vector$8.fromBufferAttribute(position, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
    computeTangents() {
      const index = this.index;
      const attributes = this.attributes;
      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const indices = index.array;
      const positions = attributes.position.array;
      const normals = attributes.normal.array;
      const uvs = attributes.uv.array;
      const nVertices = positions.length / 3;
      if (this.hasAttribute("tangent") === false) {
        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
      }
      const tangents = this.getAttribute("tangent").array;
      const tan1 = [], tan2 = [];
      for (let i = 0; i < nVertices; i++) {
        tan1[i] = new Vector3();
        tan2[i] = new Vector3();
      }
      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
      function handleTriangle(a, b, c) {
        vA.fromArray(positions, a * 3);
        vB.fromArray(positions, b * 3);
        vC.fromArray(positions, c * 3);
        uvA.fromArray(uvs, a * 2);
        uvB.fromArray(uvs, b * 2);
        uvC.fromArray(uvs, c * 2);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
        if (!isFinite(r))
          return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      }
      let groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.length
        }];
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
      }
      const tmp2 = new Vector3(), tmp22 = new Vector3();
      const n = new Vector3(), n2 = new Vector3();
      function handleVertex(v) {
        n.fromArray(normals, v * 3);
        n2.copy(n);
        const t = tan1[v];
        tmp2.copy(t);
        tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
        tmp22.crossVectors(n2, t);
        const test = tmp22.dot(tan2[v]);
        const w = test < 0 ? -1 : 1;
        tangents[v * 4] = tmp2.x;
        tangents[v * 4 + 1] = tmp2.y;
        tangents[v * 4 + 2] = tmp2.z;
        tangents[v * 4 + 3] = w;
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleVertex(indices[j + 0]);
          handleVertex(indices[j + 1]);
          handleVertex(indices[j + 2]);
        }
      }
    }
    computeVertexNormals() {
      const index = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i = 0, il = normalAttribute.count; i < il; i++) {
            normalAttribute.setXYZ(i, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index) {
          for (let i = 0, il = index.count; i < il; i += 3) {
            const vA = index.getX(i + 0);
            const vB = index.getX(i + 1);
            const vC = index.getX(i + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
            pA.fromBufferAttribute(positionAttribute, i + 0);
            pB.fromBufferAttribute(positionAttribute, i + 1);
            pC.fromBufferAttribute(positionAttribute, i + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
    merge(geometry, offset) {
      if (!(geometry && geometry.isBufferGeometry)) {
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
        return;
      }
      if (offset === void 0) {
        offset = 0;
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        if (geometry.attributes[key] === void 0)
          continue;
        const attribute1 = attributes[key];
        const attributeArray1 = attribute1.array;
        const attribute2 = geometry.attributes[key];
        const attributeArray2 = attribute2.array;
        const attributeOffset = attribute2.itemSize * offset;
        const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
        for (let i = 0, j = attributeOffset; i < length; i++, j++) {
          attributeArray1[j] = attributeArray2[i];
        }
      }
      return this;
    }
    normalizeNormals() {
      const normals = this.attributes.normal;
      for (let i = 0, il = normals.count; i < il; i++) {
        _vector$8.fromBufferAttribute(normals, i);
        _vector$8.normalize();
        normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    toNonIndexed() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index = 0, index2 = 0;
        for (let i = 0, l = indices2.length; i < l; i++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices2[i] * attribute.data.stride + attribute.offset;
          } else {
            index = indices2[i] * itemSize;
          }
          for (let j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
        return this;
      }
      const geometry2 = new BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, il = morphAttribute.length; i < il; i++) {
          const attribute = morphAttribute[i];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      const index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        data.data.attributes[key] = attribute.toJSON(data.data);
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          array.push(attribute.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      if (source.parameters !== void 0)
        this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
  var _ray$2 = /* @__PURE__ */ new Ray();
  var _sphere$3 = /* @__PURE__ */ new Sphere();
  var _vA$1 = /* @__PURE__ */ new Vector3();
  var _vB$1 = /* @__PURE__ */ new Vector3();
  var _vC$1 = /* @__PURE__ */ new Vector3();
  var _tempA = /* @__PURE__ */ new Vector3();
  var _tempB = /* @__PURE__ */ new Vector3();
  var _tempC = /* @__PURE__ */ new Vector3();
  var _morphA = /* @__PURE__ */ new Vector3();
  var _morphB = /* @__PURE__ */ new Vector3();
  var _morphC = /* @__PURE__ */ new Vector3();
  var _uvA$1 = /* @__PURE__ */ new Vector2();
  var _uvB$1 = /* @__PURE__ */ new Vector2();
  var _uvC$1 = /* @__PURE__ */ new Vector2();
  var _intersectionPoint = /* @__PURE__ */ new Vector3();
  var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
  var Mesh = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
      super();
      this.isMesh = true;
      this.type = "Mesh";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    }
    raycast(raycaster, intersects) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0)
        return;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere);
      _sphere$3.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere$3) === false)
        return;
      _inverseMatrix$2.copy(matrixWorld).invert();
      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
      if (geometry.boundingBox !== null) {
        if (_ray$2.intersectsBox(geometry.boundingBox) === false)
          return;
      }
      let intersection;
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        }
      }
    }
  };
  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA$1.fromBufferAttribute(position, a);
    _vB$1.fromBufferAttribute(position, b);
    _vC$1.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, a);
        _tempB.fromBufferAttribute(morphAttribute, b);
        _tempC.fromBufferAttribute(morphAttribute, c);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
          _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
          _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
        }
      }
      _vA$1.add(_morphA);
      _vB$1.add(_morphB);
      _vC$1.add(_morphC);
    }
    if (object.isSkinnedMesh) {
      object.boneTransform(a, _vA$1);
      object.boneTransform(b, _vB$1);
      object.boneTransform(c, _vC$1);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a);
        _uvB$1.fromBufferAttribute(uv, b);
        _uvC$1.fromBufferAttribute(uv, c);
        intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv2) {
        _uvA$1.fromBufferAttribute(uv2, a);
        _uvB$1.fromBufferAttribute(uv2, b);
        _uvC$1.fromBufferAttribute(uv2, c);
        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      const face = {
        a,
        b,
        c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  var BoxGeometry = class extends BufferGeometry {
    constructor(width2 = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      this.type = "BoxGeometry";
      this.parameters = {
        width: width2,
        height,
        depth,
        widthSegments,
        heightSegments,
        depthSegments
      };
      const scope = this;
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let numberOfVertices = 0;
      let groupStart = 0;
      buildPlane("z", "y", "x", -1, -1, depth, height, width2, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height, -width2, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width2, depth, height, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width2, depth, -height, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width2, height, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width2, height, -depth, widthSegments, heightSegments, 5);
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function buildPlane(u, v, w, udir, vdir, width3, height2, depth2, gridX, gridY, materialIndex) {
        const segmentWidth = width3 / gridX;
        const segmentHeight = height2 / gridY;
        const widthHalf = width3 / 2;
        const heightHalf = height2 / 2;
        const depthHalf = depth2 / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let groupCount = 0;
        const vector = new Vector3();
        for (let iy = 0; iy < gridY1; iy++) {
          const y = iy * segmentHeight - heightHalf;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth2 > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = numberOfVertices + ix + gridX1 * iy;
            const b = numberOfVertices + ix + gridX1 * (iy + 1);
            const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            const d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }
    }
    static fromJSON(data) {
      return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
  };
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u = 0; u < uniforms.length; u++) {
      const tmp2 = cloneUniforms(uniforms[u]);
      for (const p in tmp2) {
        merged[p] = tmp2[p];
      }
    }
    return merged;
  }
  var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  var ShaderMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isShaderMaterial = true;
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
      };
      this.defaultAttributeValues = {
        "color": [1, 1, 1],
        "uv": [0, 0],
        "uv2": [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      this.glslVersion = null;
      if (parameters !== void 0) {
        if (parameters.attributes !== void 0) {
          console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
        }
        this.setValues(parameters);
      }
    }
    copy(source) {
      super.copy(source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (const name in this.uniforms) {
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0)
        data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      const extensions = {};
      for (const key in this.extensions) {
        if (this.extensions[key] === true)
          extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0)
        data.extensions = extensions;
      return data;
    }
  };
  var Camera = class extends Object3D {
    constructor() {
      super();
      this.isCamera = true;
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
      super.updateWorldMatrix(updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var PerspectiveCamera = class extends Camera {
    constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
      super();
      this.isPerspectiveCamera = true;
      this.type = "PerspectiveCamera";
      this.fov = fov2;
      this.zoom = 1;
      this.near = near;
      this.far = far;
      this.focus = 10;
      this.aspect = aspect2;
      this.view = null;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }
    setFocalLength(focalLength) {
      const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }
    getFocalLength() {
      const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(fullWidth, fullHeight, x, y, width2, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width2;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const near = this.near;
      let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      let height = 2 * top;
      let width2 = this.aspect * height;
      let left = -0.5 * width2;
      const view = this.view;
      if (this.view !== null && this.view.enabled) {
        const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width2 / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width2 *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      const skew = this.filmOffset;
      if (skew !== 0)
        left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width2, top, top - height, near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  };
  var fov = 90;
  var aspect = 1;
  var CubeCamera = class extends Object3D {
    constructor(near, far, renderTarget) {
      super();
      this.type = "CubeCamera";
      if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        return;
      }
      this.renderTarget = renderTarget;
      const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = this.layers;
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new Vector3(1, 0, 0));
      this.add(cameraPX);
      const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = this.layers;
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new Vector3(-1, 0, 0));
      this.add(cameraNX);
      const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = this.layers;
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new Vector3(0, 1, 0));
      this.add(cameraPY);
      const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = this.layers;
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new Vector3(0, -1, 0));
      this.add(cameraNY);
      const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = this.layers;
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new Vector3(0, 0, 1));
      this.add(cameraPZ);
      const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = this.layers;
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new Vector3(0, 0, -1));
      this.add(cameraNZ);
    }
    update(renderer2, scene) {
      if (this.parent === null)
        this.updateMatrixWorld();
      const renderTarget = this.renderTarget;
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
      const currentRenderTarget = renderer2.getRenderTarget();
      const currentToneMapping = renderer2.toneMapping;
      const currentXrEnabled = renderer2.xr.enabled;
      renderer2.toneMapping = NoToneMapping;
      renderer2.xr.enabled = false;
      const generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer2.setRenderTarget(renderTarget, 0);
      renderer2.render(scene, cameraPX);
      renderer2.setRenderTarget(renderTarget, 1);
      renderer2.render(scene, cameraNX);
      renderer2.setRenderTarget(renderTarget, 2);
      renderer2.render(scene, cameraPY);
      renderer2.setRenderTarget(renderTarget, 3);
      renderer2.render(scene, cameraNY);
      renderer2.setRenderTarget(renderTarget, 4);
      renderer2.render(scene, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer2.setRenderTarget(renderTarget, 5);
      renderer2.render(scene, cameraNZ);
      renderer2.setRenderTarget(currentRenderTarget);
      renderer2.toneMapping = currentToneMapping;
      renderer2.xr.enabled = currentXrEnabled;
      renderTarget.texture.needsPMREMUpdate = true;
    }
  };
  var CubeTexture = class extends Texture {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
      images = images !== void 0 ? images : [];
      mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
      super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.isCubeTexture = true;
      this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(value) {
      this.image = value;
    }
  };
  var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
    constructor(size, options = {}) {
      super(size, size, options);
      this.isWebGLCubeRenderTarget = true;
      const image = { width: size, height: size, depth: 1 };
      const images = [image, image, image, image, image, image];
      this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.isRenderTargetTexture = true;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    }
    fromEquirectangularTexture(renderer2, texture) {
      this.texture.type = texture.type;
      this.texture.encoding = texture.encoding;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      const shader = {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      };
      const geometry = new BoxGeometry(5, 5, 5);
      const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      const mesh = new Mesh(geometry, material);
      const currentMinFilter = texture.minFilter;
      if (texture.minFilter === LinearMipmapLinearFilter)
        texture.minFilter = LinearFilter;
      const camera = new CubeCamera(1, 10, this);
      camera.update(renderer2, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
    clear(renderer2, color, depth, stencil) {
      const currentRenderTarget = renderer2.getRenderTarget();
      for (let i = 0; i < 6; i++) {
        renderer2.setRenderTarget(this, i);
        renderer2.clear(color, depth, stencil);
      }
      renderer2.setRenderTarget(currentRenderTarget);
    }
  };
  var _vector1 = /* @__PURE__ */ new Vector3();
  var _vector2 = /* @__PURE__ */ new Vector3();
  var _normalMatrix = /* @__PURE__ */ new Matrix3();
  var Plane = class {
    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
      this.isPlane = true;
      this.normal = normal;
      this.constant = constant;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a, b, c) {
      const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      const inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
      const direction = line.delta(_vector1);
      const denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return null;
      }
      const t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return null;
      }
      return target.copy(direction).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
      const startSign = this.distanceToPoint(line.start);
      const endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      const normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _sphere$2 = /* @__PURE__ */ new Sphere();
  var _vector$7 = /* @__PURE__ */ new Vector3();
  var Frustum = class {
    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
      this.planes = [p0, p1, p2, p3, p4, p5];
    }
    set(p0, p1, p2, p3, p4, p5) {
      const planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    copy(frustum) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
    setFromProjectionMatrix(m) {
      const planes = this.planes;
      const me = m.elements;
      const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
      const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
      const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
      const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    }
    intersectsObject(object) {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSprite(sprite) {
      _sphere$2.center.set(0, 0, 0);
      _sphere$2.radius = 0.7071067811865476;
      _sphere$2.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSphere(sphere) {
      const planes = this.planes;
      const center = sphere.center;
      const negRadius = -sphere.radius;
      for (let i = 0; i < 6; i++) {
        const distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        const plane = planes[i];
        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type;
      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type = 5131;
          } else {
            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type = 5123;
        }
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      } else if (array instanceof Uint8ClampedArray) {
        type = 5121;
      } else {
        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
        } else {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        }
        updateRange.count = -1;
      }
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update
    };
  }
  var PlaneGeometry = class extends BufferGeometry {
    constructor(width2 = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneGeometry";
      this.parameters = {
        width: width2,
        height,
        widthSegments,
        heightSegments
      };
      const width_half = width2 / 2;
      const height_half = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width2 / gridX;
      const segment_height = height / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segment_width - width_half;
          vertices.push(x, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b = ix + gridX1 * (iy + 1);
          const c = ix + 1 + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  };
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
  var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
  var iridescence_fragment = "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n	material.iridescence = 0.0;\n} else {\n	material.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
  var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
  var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
  var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
  var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
  var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
  var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
  var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
  var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
  var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
  var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    output_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_vert: vertex$g,
    background_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
  };
  var UniformsLib = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Matrix3() },
      uv2Transform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaTest: { value: 0 }
    },
    specularmap: {
      specularMap: { value: null }
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 }
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 }
    },
    emissivemap: {
      emissiveMap: { value: null }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new Vector2(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: {
      roughnessMap: { value: null }
    },
    metalnessmap: {
      metalnessMap: { value: null }
    },
    gradientmap: {
      gradientMap: { value: null }
    },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: {
        direction: {},
        color: {}
      } },
      directionalLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      } },
      spotLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      } },
      pointLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() }
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() }
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
      uniforms: mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    cube: {
      uniforms: mergeUniforms([
        UniformsLib.envmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: new Color(0) },
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new Vector2(1, 1) },
        clearcoatNormalMap: { value: null },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        sheen: { value: 0 },
        sheenColor: { value: new Color(0) },
        sheenColorMap: { value: null },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionSamplerSize: { value: new Vector2() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new Color(0) },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularColor: { value: new Color(1, 1, 1) },
        specularColorMap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  function WebGLBackground(renderer2, cubemaps, state, objects, alpha, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = alpha === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene) {
      let forceClear = false;
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        background = cubemaps.get(background);
      }
      const xr = renderer2.xr;
      const session = xr.getSession && xr.getSession();
      if (session && session.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      if (renderer2.autoClear || forceClear) {
        renderer2.clear(renderer2.autoClearColor, renderer2.autoClearDepth, renderer2.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer3, scene2, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer2.toneMapping;
        }
        boxMesh.layers.enableAll();
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer2.toneMapping;
        }
        planeMesh.layers.enableAll();
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha2) {
      state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha2 = 1) {
        clearColor.set(color);
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha2) {
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    let forceUpdate = false;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state = getBindingState(geometry, program, material);
        if (currentState !== state) {
          currentState = state;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(object, geometry, program, index);
        if (updateBuffers)
          saveCache(object, geometry, program, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (index !== null) {
        attributes.update(index, 34963);
      }
      if (updateBuffers || forceUpdate) {
        forceUpdate = false;
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(34963, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i = 0; i < maxVertexAttributes; i++) {
        newAttributes[i] = 0;
        enabledAttributes[i] = 0;
        attributeDivisors[i] = 0;
      }
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(object, geometry, program, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          const cachedAttribute = cachedAttributes[name];
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (cachedAttribute === void 0)
            return true;
          if (cachedAttribute.attribute !== geometryAttribute)
            return true;
          if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
            return true;
          attributesNum++;
        }
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(object, geometry, program, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let attribute = attributes2[name];
          if (attribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              attribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              attribute = object.instanceColor;
          }
          const data = {};
          data.attribute = attribute;
          if (attribute && attribute.data) {
            data.data = attribute.data;
          }
          cache[name] = data;
          attributesNum++;
        }
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i = 0, il = newAttributes.length; i < il; i++) {
        newAttributes[i] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i = 0, il = enabledAttributes.length; i < il; i++) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
      if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
        gl.vertexAttribIPointer(index, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data.isInstancedInterleavedBuffer) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement);
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement);
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      forceUpdate = true;
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start, count) {
      gl.drawArrays(mode, start, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start, count, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      drawBuffers,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
      const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
      resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer2) {
    let cubemaps = /* @__PURE__ */ new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer2, texture);
              cubemaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var OrthographicCamera = class extends Camera {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
      super();
      this.isOrthographicCamera = true;
      this.type = "OrthographicCamera";
      this.zoom = 1;
      this.view = null;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = near;
      this.far = far;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
    setViewOffset(fullWidth, fullHeight, x, y, width2, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width2;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const dx = (this.right - this.left) / (2 * this.zoom);
      const dy = (this.top - this.bottom) / (2 * this.zoom);
      const cx = (this.right + this.left) / 2;
      const cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      return data;
    }
  };
  var LOD_MIN = 4;
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var MAX_SAMPLES = 20;
  var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
  var _clearColor = /* @__PURE__ */ new Color();
  var _oldTarget = null;
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;
  var _axisDirections = [
    /* @__PURE__ */ new Vector3(1, 1, 1),
    /* @__PURE__ */ new Vector3(-1, 1, 1),
    /* @__PURE__ */ new Vector3(1, 1, -1),
    /* @__PURE__ */ new Vector3(-1, 1, -1),
    /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
    /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
    /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
  ];
  var PMREMGenerator = class {
    constructor(renderer2) {
      this._renderer = renderer2;
      this._pingPongRenderTarget = null;
      this._lodMax = 0;
      this._cubeSize = 0;
      this._lodPlanes = [];
      this._sizeLods = [];
      this._sigmas = [];
      this._blurMaterial = null;
      this._cubemapMaterial = null;
      this._equirectMaterial = null;
      this._compileMaterial(this._blurMaterial);
    }
    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
      _oldTarget = this._renderer.getRenderTarget();
      this._setSize(256);
      const cubeUVRenderTarget = this._allocateTargets();
      cubeUVRenderTarget.depthBuffer = true;
      this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
      if (sigma > 0) {
        this._blur(cubeUVRenderTarget, 0, 0, sigma);
      }
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    fromEquirectangular(equirectangular, renderTarget = null) {
      return this._fromTexture(equirectangular, renderTarget);
    }
    fromCubemap(cubemap, renderTarget = null) {
      return this._fromTexture(cubemap, renderTarget);
    }
    compileCubemapShader() {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
        this._compileMaterial(this._cubemapMaterial);
      }
    }
    compileEquirectangularShader() {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
        this._compileMaterial(this._equirectMaterial);
      }
    }
    dispose() {
      this._dispose();
      if (this._cubemapMaterial !== null)
        this._cubemapMaterial.dispose();
      if (this._equirectMaterial !== null)
        this._equirectMaterial.dispose();
    }
    _setSize(cubeSize) {
      this._lodMax = Math.floor(Math.log2(cubeSize));
      this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      if (this._blurMaterial !== null)
        this._blurMaterial.dispose();
      if (this._pingPongRenderTarget !== null)
        this._pingPongRenderTarget.dispose();
      for (let i = 0; i < this._lodPlanes.length; i++) {
        this._lodPlanes[i].dispose();
      }
    }
    _cleanup(outputTarget) {
      this._renderer.setRenderTarget(_oldTarget);
      outputTarget.scissorTest = false;
      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture, renderTarget) {
      if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
        this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
      } else {
        this._setSize(texture.image.width / 4);
      }
      _oldTarget = this._renderer.getRenderTarget();
      const cubeUVRenderTarget = renderTarget || this._allocateTargets();
      this._textureToCubeUV(texture, cubeUVRenderTarget);
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    _allocateTargets() {
      const width2 = 3 * Math.max(this._cubeSize, 16 * 7);
      const height = 4 * this._cubeSize;
      const params = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: false,
        type: HalfFloatType,
        format: RGBAFormat,
        encoding: LinearEncoding,
        depthBuffer: false
      };
      const cubeUVRenderTarget = _createRenderTarget(width2, height, params);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width2) {
        if (this._pingPongRenderTarget !== null) {
          this._dispose();
        }
        this._pingPongRenderTarget = _createRenderTarget(width2, height, params);
        const { _lodMax } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
        this._blurMaterial = _getBlurShader(_lodMax, width2, height);
      }
      return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
      const tmpMesh = new Mesh(this._lodPlanes[0], material);
      this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
      const fov2 = 90;
      const aspect2 = 1;
      const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
      const upSign = [1, -1, 1, 1, 1, 1];
      const forwardSign = [1, 1, 1, -1, -1, -1];
      const renderer2 = this._renderer;
      const originalAutoClear = renderer2.autoClear;
      const toneMapping = renderer2.toneMapping;
      renderer2.getClearColor(_clearColor);
      renderer2.toneMapping = NoToneMapping;
      renderer2.autoClear = false;
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
      let useSolidColor = false;
      const background = scene.background;
      if (background) {
        if (background.isColor) {
          backgroundMaterial.color.copy(background);
          scene.background = null;
          useSolidColor = true;
        }
      } else {
        backgroundMaterial.color.copy(_clearColor);
        useSolidColor = true;
      }
      for (let i = 0; i < 6; i++) {
        const col = i % 3;
        if (col === 0) {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(forwardSign[i], 0, 0);
        } else if (col === 1) {
          cubeCamera.up.set(0, 0, upSign[i]);
          cubeCamera.lookAt(0, forwardSign[i], 0);
        } else {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(0, 0, forwardSign[i]);
        }
        const size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
        renderer2.setRenderTarget(cubeUVRenderTarget);
        if (useSolidColor) {
          renderer2.render(backgroundBox, cubeCamera);
        }
        renderer2.render(scene, cubeCamera);
      }
      backgroundBox.geometry.dispose();
      backgroundBox.material.dispose();
      renderer2.toneMapping = toneMapping;
      renderer2.autoClear = originalAutoClear;
      scene.background = background;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
      const renderer2 = this._renderer;
      const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
      if (isCubeTexture) {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
        }
        this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
      } else {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
        }
      }
      const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
      const mesh = new Mesh(this._lodPlanes[0], material);
      const uniforms = material.uniforms;
      uniforms["envMap"].value = texture;
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
      renderer2.setRenderTarget(cubeUVRenderTarget);
      renderer2.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
      const renderer2 = this._renderer;
      const autoClear = renderer2.autoClear;
      renderer2.autoClear = false;
      for (let i = 1; i < this._lodPlanes.length; i++) {
        const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
        const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
        this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
      }
      renderer2.autoClear = autoClear;
    }
    _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      const pingPongRenderTarget = this._pingPongRenderTarget;
      this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
      this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      const renderer2 = this._renderer;
      const blurMaterial = this._blurMaterial;
      if (direction !== "latitudinal" && direction !== "longitudinal") {
        console.error("blur direction must be either latitudinal or longitudinal!");
      }
      const STANDARD_DEVIATIONS = 3;
      const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
      const blurUniforms = blurMaterial.uniforms;
      const pixels = this._sizeLods[lodIn] - 1;
      const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      const sigmaPixels = sigmaRadians / radiansPerPixel;
      const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
      if (samples > MAX_SAMPLES) {
        console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
      }
      const weights = [];
      let sum = 0;
      for (let i = 0; i < MAX_SAMPLES; ++i) {
        const x2 = i / sigmaPixels;
        const weight = Math.exp(-x2 * x2 / 2);
        weights.push(weight);
        if (i === 0) {
          sum += weight;
        } else if (i < samples) {
          sum += 2 * weight;
        }
      }
      for (let i = 0; i < weights.length; i++) {
        weights[i] = weights[i] / sum;
      }
      blurUniforms["envMap"].value = targetIn.texture;
      blurUniforms["samples"].value = samples;
      blurUniforms["weights"].value = weights;
      blurUniforms["latitudinal"].value = direction === "latitudinal";
      if (poleAxis) {
        blurUniforms["poleAxis"].value = poleAxis;
      }
      const { _lodMax } = this;
      blurUniforms["dTheta"].value = radiansPerPixel;
      blurUniforms["mipInt"].value = _lodMax - lodIn;
      const outputSize = this._sizeLods[lodOut];
      const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
      const y = 4 * (this._cubeSize - outputSize);
      _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
      renderer2.setRenderTarget(targetOut);
      renderer2.render(blurMesh, _flatCamera);
    }
  };
  function _createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i = 0; i < totalLods; i++) {
      const sizeLod = Math.pow(2, lod);
      sizeLods.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i > lodMax - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
      } else if (i === 0) {
        sigma = 0;
      }
      sigmas.push(sigma);
      const texelSize = 1 / (sizeLod - 2);
      const min = -texelSize;
      const max = 1 + texelSize;
      const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x = face % 3 * 2 / 3 - 1;
        const y = face > 2 ? 0 : -1;
        const coordinates = [
          x,
          y,
          0,
          x + 2 / 3,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      lodPlanes.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { lodPlanes, sizeLods, sigmas };
  }
  function _createRenderTarget(width2, height, params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(width2, height, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x, y, width2, height) {
    target.viewport.set(x, y, width2, height);
    target.scissor.set(x, y, width2, height);
  }
  function _getBlurShader(lodMax, width2, height) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: {
        "n": MAX_SAMPLES,
        "CUBEUV_TEXEL_WIDTH": 1 / width2,
        "CUBEUV_TEXEL_HEIGHT": 1 / height,
        "CUBEUV_MAX_MIP": `${lodMax}.0`
      },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectMaterial() {
    return new ShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCubemapMaterial() {
    return new ShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "flipEnvMap": { value: -1 }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function WebGLCubeUVMaps(renderer2) {
    let cubeUVmaps = /* @__PURE__ */ new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
            texture.needsPMREMUpdate = false;
            let renderTarget = cubeUVmaps.get(texture);
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer2);
            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
            cubeUVmaps.set(texture, renderTarget);
            return renderTarget.texture;
          } else {
            if (cubeUVmaps.has(texture)) {
              return cubeUVmaps.get(texture).texture;
            } else {
              const image = texture.image;
              if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer2);
                const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                cubeUVmaps.set(texture, renderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image) {
      let count = 0;
      const length = 6;
      for (let i = 0; i < length; i++) {
        if (image[i] !== void 0)
          count++;
      }
      return count === length;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = /* @__PURE__ */ new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension(name) !== null;
      },
      init: function(capabilities) {
        if (capabilities.isWebGL2) {
          getExtension("EXT_color_buffer_float");
        } else {
          getExtension("WEBGL_depth_texture");
          getExtension("OES_texture_float");
          getExtension("OES_texture_half_float");
          getExtension("OES_texture_half_float_linear");
          getExtension("OES_standard_derivatives");
          getExtension("OES_element_index_uint");
          getExtension("OES_vertex_array_object");
          getExtension("ANGLE_instanced_arrays");
        }
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
        getExtension("WEBGL_multisampled_render_to_texture");
      },
      get: function(name) {
        const extension = getExtension(name);
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = /* @__PURE__ */ new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i = 0, l = array.length; i < l; i++) {
          attributes.update(array[i], 34962);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i = 0, l = array.length; i < l; i += 3) {
          const a = array[i + 0];
          const b = array[i + 1];
          const c = array[i + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          const a = i + 0;
          const b = i + 1;
          const c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      }
      const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
      gl.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count / 3);
          break;
        case 1:
          render.lines += instanceCount * (count / 2);
          break;
        case 3:
          render.lines += instanceCount * (count - 1);
          break;
        case 2:
          render.lines += instanceCount * count;
          break;
        case 0:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function numericalSort(a, b) {
    return a[0] - b[0];
  }
  function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function denormalize(morph, attribute) {
    let denominator = 1;
    const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
    if (array instanceof Int8Array)
      denominator = 127;
    else if (array instanceof Int16Array)
      denominator = 32767;
    else if (array instanceof Int32Array)
      denominator = 2147483647;
    else
      console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
    morph.divideScalar(denominator);
  }
  function WebGLMorphtargets(gl, capabilities, textures) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const morphTextures = /* @__PURE__ */ new WeakMap();
    const morph = new Vector4();
    const workInfluences = [];
    for (let i = 0; i < 8; i++) {
      workInfluences[i] = [i, 0];
    }
    function update(object, geometry, material, program) {
      const objectInfluences = object.morphTargetInfluences;
      if (capabilities.isWebGL2 === true) {
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
        let entry = morphTextures.get(geometry);
        if (entry === void 0 || entry.count !== morphTargetsCount) {
          let disposeTexture = function() {
            texture.dispose();
            morphTextures.delete(geometry);
            geometry.removeEventListener("dispose", disposeTexture);
          };
          if (entry !== void 0)
            entry.texture.dispose();
          const hasMorphPosition = geometry.morphAttributes.position !== void 0;
          const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
          const hasMorphColors = geometry.morphAttributes.color !== void 0;
          const morphTargets = geometry.morphAttributes.position || [];
          const morphNormals = geometry.morphAttributes.normal || [];
          const morphColors = geometry.morphAttributes.color || [];
          let vertexDataCount = 0;
          if (hasMorphPosition === true)
            vertexDataCount = 1;
          if (hasMorphNormals === true)
            vertexDataCount = 2;
          if (hasMorphColors === true)
            vertexDataCount = 3;
          let width2 = geometry.attributes.position.count * vertexDataCount;
          let height = 1;
          if (width2 > capabilities.maxTextureSize) {
            height = Math.ceil(width2 / capabilities.maxTextureSize);
            width2 = capabilities.maxTextureSize;
          }
          const buffer = new Float32Array(width2 * height * 4 * morphTargetsCount);
          const texture = new DataArrayTexture(buffer, width2, height, morphTargetsCount);
          texture.type = FloatType;
          texture.needsUpdate = true;
          const vertexDataStride = vertexDataCount * 4;
          for (let i = 0; i < morphTargetsCount; i++) {
            const morphTarget = morphTargets[i];
            const morphNormal = morphNormals[i];
            const morphColor = morphColors[i];
            const offset = width2 * height * 4 * i;
            for (let j = 0; j < morphTarget.count; j++) {
              const stride = j * vertexDataStride;
              if (hasMorphPosition === true) {
                morph.fromBufferAttribute(morphTarget, j);
                if (morphTarget.normalized === true)
                  denormalize(morph, morphTarget);
                buffer[offset + stride + 0] = morph.x;
                buffer[offset + stride + 1] = morph.y;
                buffer[offset + stride + 2] = morph.z;
                buffer[offset + stride + 3] = 0;
              }
              if (hasMorphNormals === true) {
                morph.fromBufferAttribute(morphNormal, j);
                if (morphNormal.normalized === true)
                  denormalize(morph, morphNormal);
                buffer[offset + stride + 4] = morph.x;
                buffer[offset + stride + 5] = morph.y;
                buffer[offset + stride + 6] = morph.z;
                buffer[offset + stride + 7] = 0;
              }
              if (hasMorphColors === true) {
                morph.fromBufferAttribute(morphColor, j);
                if (morphColor.normalized === true)
                  denormalize(morph, morphColor);
                buffer[offset + stride + 8] = morph.x;
                buffer[offset + stride + 9] = morph.y;
                buffer[offset + stride + 10] = morph.z;
                buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
              }
            }
          }
          entry = {
            count: morphTargetsCount,
            texture,
            size: new Vector2(width2, height)
          };
          morphTextures.set(geometry, entry);
          geometry.addEventListener("dispose", disposeTexture);
        }
        let morphInfluencesSum = 0;
        for (let i = 0; i < objectInfluences.length; i++) {
          morphInfluencesSum += objectInfluences[i];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
        program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
        program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
      } else {
        const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === void 0 || influences.length !== length) {
          influences = [];
          for (let i = 0; i < length; i++) {
            influences[i] = [i, 0];
          }
          influencesList[geometry.id] = influences;
        }
        for (let i = 0; i < length; i++) {
          const influence = influences[i];
          influence[0] = i;
          influence[1] = objectInfluences[i];
        }
        influences.sort(absNumericalSort);
        for (let i = 0; i < 8; i++) {
          if (i < length && influences[i][1]) {
            workInfluences[i][0] = influences[i][0];
            workInfluences[i][1] = influences[i][1];
          } else {
            workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i][1] = 0;
          }
        }
        workInfluences.sort(numericalSort);
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for (let i = 0; i < 8; i++) {
          const influence = workInfluences[i];
          const index = influence[0];
          const value = influence[1];
          if (index !== Number.MAX_SAFE_INTEGER && value) {
            if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
              geometry.setAttribute("morphTarget" + i, morphTargets[index]);
            }
            if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
              geometry.setAttribute("morphNormal" + i, morphNormals[index]);
            }
            morphInfluences[i] = value;
            morphInfluencesSum += value;
          } else {
            if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
              geometry.deleteAttribute("morphTarget" + i);
            }
            if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
              geometry.deleteAttribute("morphNormal" + i);
            }
            morphInfluences[i] = 0;
          }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
      }
    }
    return {
      update
    };
  }
  function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = /* @__PURE__ */ new WeakMap();
    function update(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        attributes.update(object.instanceMatrix, 34962);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, 34962);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = /* @__PURE__ */ new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  var emptyTexture = new Texture();
  var emptyArrayTexture = new DataArrayTexture();
  var empty3dTexture = new Data3DTexture();
  var emptyCubeTexture = new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (let i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function copyArray(a, b) {
    for (let i = 0, l = b.length; i < l; i++) {
      a[i] = b[i];
    }
  }
  function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (let i = 0; i !== n; ++i) {
      r[i] = textures.allocateTextureUnit();
    }
    return r;
  }
  function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }
  function setValueV2ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2D(v || emptyTexture, unit);
  }
  function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || empty3dTexture, unit);
  }
  function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTextureCube(v || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyArrayTexture, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }
  function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }
  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }
  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }
  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }
  function setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
  }
  function setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
  }
  function setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
  }
  function setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
  }
  function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2D(v[i] || emptyTexture, units[i]);
    }
  }
  function setValueT3DArray(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTexture3D(v[i] || empty3dTexture, units[i]);
    }
  }
  function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }
  function setValueT2DArrayArray(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3DArray;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArrayArray;
    }
  }
  var SingleUniform = class {
    constructor(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.setValue = getSingularSetter(activeInfo.type);
    }
  };
  var PureArrayUniform = class {
    constructor(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.size = activeInfo.size;
      this.setValue = getPureArraySetter(activeInfo.type);
    }
  };
  var StructuredUniform = class {
    constructor(id) {
      this.id = id;
      this.seq = [];
      this.map = {};
    }
    setValue(gl, value, textures) {
      const seq = this.seq;
      for (let i = 0, n = seq.length; i !== n; ++i) {
        const u = seq[i];
        u.setValue(gl, value[u.id], textures);
      }
    }
  };
  var RePathPart = /(\w+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  var WebGLUniforms = class {
    constructor(gl, program) {
      this.seq = [];
      this.map = {};
      const n = gl.getProgramParameter(program, 35718);
      for (let i = 0; i < n; ++i) {
        const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
      }
    }
    setValue(gl, name, value, textures) {
      const u = this.map[name];
      if (u !== void 0)
        u.setValue(gl, value, textures);
    }
    setOptional(gl, object, name) {
      const v = object[name];
      if (v !== void 0)
        this.setValue(gl, name, v);
    }
    static upload(gl, seq, values, textures) {
      for (let i = 0, n = seq.length; i !== n; ++i) {
        const u = seq[i], v = values[u.id];
        if (v.needsUpdate !== false) {
          u.setValue(gl, v.value, textures);
        }
      }
    }
    static seqWithValue(seq, values) {
      const r = [];
      for (let i = 0, n = seq.length; i !== n; ++i) {
        const u = seq[i];
        if (u.id in values)
          r.push(u);
      }
      return r;
    }
  };
  function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  var programIdCount = 0;
  function handleSource(string, errorLine) {
    const lines = string.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i = from; i < to; i++) {
      const line = i + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
    }
    return lines2.join("\n");
  }
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
        return ["Linear", "( value )"];
    }
  }
  function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === "")
      return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
    } else {
      return errors;
    }
  }
  function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for (let i = 0; i < n; i++) {
      const info = gl.getActiveAttrib(program, i);
      const name = info.name;
      let locationSize = 1;
      if (info.type === 35674)
        locationSize = 2;
      if (info.type === 35675)
        locationSize = 3;
      if (info.type === 35676)
        locationSize = 4;
      attributes[name] = {
        type: info.type,
        location: gl.getAttribLocation(program, name),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
  }
  var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
  }
  function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return loopReplacer(match, start, end, snippet);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i = parseInt(start); i < parseInt(end); i++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function generateCubeUVSize(parameters) {
    const imageHeight = parameters.envMapCubeUVHeight;
    if (imageHeight === null)
      return null;
    const maxMip = Math.log2(imageHeight) - 2;
    const texelHeight = 1 / imageHeight;
    const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
  }
  function WebGLProgram(renderer2, cacheKey, parameters, bindingStates) {
    const gl = renderer2.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const envMapCubeUVSize = generateCubeUVSize(parameters);
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
        envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.opaque ? "#define OPAQUE" : "",
        ShaderChunk["encodings_pars_fragment"],
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
        parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer2.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  var _id = 0;
  var WebGLShaderCache = class {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map();
      this.materialCache = /* @__PURE__ */ new Map();
    }
    update(material) {
      const vertexShader = material.vertexShader;
      const fragmentShader = material.fragmentShader;
      const vertexShaderStage = this._getShaderStage(vertexShader);
      const fragmentShaderStage = this._getShaderStage(fragmentShader);
      const materialShaders = this._getShaderCacheForMaterial(material);
      if (materialShaders.has(vertexShaderStage) === false) {
        materialShaders.add(vertexShaderStage);
        vertexShaderStage.usedTimes++;
      }
      if (materialShaders.has(fragmentShaderStage) === false) {
        materialShaders.add(fragmentShaderStage);
        fragmentShaderStage.usedTimes++;
      }
      return this;
    }
    remove(material) {
      const materialShaders = this.materialCache.get(material);
      for (const shaderStage of materialShaders) {
        shaderStage.usedTimes--;
        if (shaderStage.usedTimes === 0)
          this.shaderCache.delete(shaderStage.code);
      }
      this.materialCache.delete(material);
      return this;
    }
    getVertexShaderID(material) {
      return this._getShaderStage(material.vertexShader).id;
    }
    getFragmentShaderID(material) {
      return this._getShaderStage(material.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear();
      this.materialCache.clear();
    }
    _getShaderCacheForMaterial(material) {
      const cache = this.materialCache;
      if (cache.has(material) === false) {
        cache.set(material, /* @__PURE__ */ new Set());
      }
      return cache.get(material);
    }
    _getShaderStage(code) {
      const cache = this.shaderCache;
      if (cache.has(code) === false) {
        const stage = new WebGLShaderStage(code);
        cache.set(code, stage);
      }
      return cache.get(code);
    }
  };
  var WebGLShaderStage = class {
    constructor(code) {
      this.id = _id++;
      this.code = code;
      this.usedTimes = 0;
    }
  };
  function WebGLPrograms(renderer2, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new Layers();
    const _customShaders = new WebGLShaderCache();
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const geometry = object.geometry;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
      const shaderID = shaderIDs[material.type];
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let morphTextureStride = 0;
      if (geometry.morphAttributes.position !== void 0)
        morphTextureStride = 1;
      if (geometry.morphAttributes.normal !== void 0)
        morphTextureStride = 2;
      if (geometry.morphAttributes.color !== void 0)
        morphTextureStride = 3;
      let vertexShader, fragmentShader;
      let customVertexShaderID, customFragmentShaderID;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
        _customShaders.update(material);
        customVertexShaderID = _customShaders.getVertexShaderID(material);
        customFragmentShaderID = _customShaders.getFragmentShaderID(material);
      }
      const currentRenderTarget = renderer2.getRenderTarget();
      const useAlphaTest = material.alphaTest > 0;
      const useClearcoat = material.clearcoat > 0;
      const useIridescence = material.iridescence > 0;
      const parameters = {
        isWebGL2,
        shaderID,
        shaderName: material.type,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        customVertexShaderID,
        customFragmentShaderID,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: object.isInstancedMesh === true,
        instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
        supportsVertexTextures: vertexTextures,
        outputEncoding: currentRenderTarget === null ? renderer2.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
        map: !!material.map,
        matcap: !!material.matcap,
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapCubeUVHeight,
        lightMap: !!material.lightMap,
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
        clearcoat: useClearcoat,
        clearcoatMap: useClearcoat && !!material.clearcoatMap,
        clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
        clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
        iridescence: useIridescence,
        iridescenceMap: useIridescence && !!material.iridescenceMap,
        iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        specularIntensityMap: !!material.specularIntensityMap,
        specularColorMap: !!material.specularColorMap,
        opaque: material.transparent === false && material.blending === NormalBlending,
        alphaMap: !!material.alphaMap,
        alphaTest: useAlphaTest,
        gradientMap: !!material.gradientMap,
        sheen: material.sheen > 0,
        sheenColorMap: !!material.sheenColorMap,
        sheenRoughnessMap: !!material.sheenRoughnessMap,
        transmission: material.transmission > 0,
        transmissionMap: !!material.transmissionMap,
        thicknessMap: !!material.thicknessMap,
        combine: material.combine,
        vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog === true,
        fogExp2: fog && fog.isFogExp2,
        flatShading: !!material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer,
        skinning: object.isSkinnedMesh === true,
        morphTargets: geometry.morphAttributes.position !== void 0,
        morphNormals: geometry.morphAttributes.normal !== void 0,
        morphColors: geometry.morphAttributes.color !== void 0,
        morphTargetsCount,
        morphTextureStride,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer2.shadowMap.type,
        toneMapping: material.toneMapped ? renderer2.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer2.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        useDepthPacking: !!material.depthPacking,
        depthPacking: material.depthPacking || 0,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.fragDepth,
        extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.customVertexShaderID);
        array.push(parameters.customFragmentShaderID);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        getProgramCacheKeyParameters(array, parameters);
        getProgramCacheKeyBooleans(array, parameters);
        array.push(renderer2.outputEncoding);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
      array.push(parameters.precision);
      array.push(parameters.outputEncoding);
      array.push(parameters.envMapMode);
      array.push(parameters.envMapCubeUVHeight);
      array.push(parameters.combine);
      array.push(parameters.vertexUvs);
      array.push(parameters.fogExp2);
      array.push(parameters.sizeAttenuation);
      array.push(parameters.morphTargetsCount);
      array.push(parameters.morphAttributeCount);
      array.push(parameters.numDirLights);
      array.push(parameters.numPointLights);
      array.push(parameters.numSpotLights);
      array.push(parameters.numHemiLights);
      array.push(parameters.numRectAreaLights);
      array.push(parameters.numDirLightShadows);
      array.push(parameters.numPointLightShadows);
      array.push(parameters.numSpotLightShadows);
      array.push(parameters.shadowMapType);
      array.push(parameters.toneMapping);
      array.push(parameters.numClippingPlanes);
      array.push(parameters.numClipIntersection);
      array.push(parameters.depthPacking);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
      _programLayers.disableAll();
      if (parameters.isWebGL2)
        _programLayers.enable(0);
      if (parameters.supportsVertexTextures)
        _programLayers.enable(1);
      if (parameters.instancing)
        _programLayers.enable(2);
      if (parameters.instancingColor)
        _programLayers.enable(3);
      if (parameters.map)
        _programLayers.enable(4);
      if (parameters.matcap)
        _programLayers.enable(5);
      if (parameters.envMap)
        _programLayers.enable(6);
      if (parameters.lightMap)
        _programLayers.enable(7);
      if (parameters.aoMap)
        _programLayers.enable(8);
      if (parameters.emissiveMap)
        _programLayers.enable(9);
      if (parameters.bumpMap)
        _programLayers.enable(10);
      if (parameters.normalMap)
        _programLayers.enable(11);
      if (parameters.objectSpaceNormalMap)
        _programLayers.enable(12);
      if (parameters.tangentSpaceNormalMap)
        _programLayers.enable(13);
      if (parameters.clearcoat)
        _programLayers.enable(14);
      if (parameters.clearcoatMap)
        _programLayers.enable(15);
      if (parameters.clearcoatRoughnessMap)
        _programLayers.enable(16);
      if (parameters.clearcoatNormalMap)
        _programLayers.enable(17);
      if (parameters.iridescence)
        _programLayers.enable(18);
      if (parameters.iridescenceMap)
        _programLayers.enable(19);
      if (parameters.iridescenceThicknessMap)
        _programLayers.enable(20);
      if (parameters.displacementMap)
        _programLayers.enable(21);
      if (parameters.specularMap)
        _programLayers.enable(22);
      if (parameters.roughnessMap)
        _programLayers.enable(23);
      if (parameters.metalnessMap)
        _programLayers.enable(24);
      if (parameters.gradientMap)
        _programLayers.enable(25);
      if (parameters.alphaMap)
        _programLayers.enable(26);
      if (parameters.alphaTest)
        _programLayers.enable(27);
      if (parameters.vertexColors)
        _programLayers.enable(28);
      if (parameters.vertexAlphas)
        _programLayers.enable(29);
      if (parameters.vertexUvs)
        _programLayers.enable(30);
      if (parameters.vertexTangents)
        _programLayers.enable(31);
      if (parameters.uvsVertexOnly)
        _programLayers.enable(32);
      if (parameters.fog)
        _programLayers.enable(33);
      array.push(_programLayers.mask);
      _programLayers.disableAll();
      if (parameters.useFog)
        _programLayers.enable(0);
      if (parameters.flatShading)
        _programLayers.enable(1);
      if (parameters.logarithmicDepthBuffer)
        _programLayers.enable(2);
      if (parameters.skinning)
        _programLayers.enable(3);
      if (parameters.morphTargets)
        _programLayers.enable(4);
      if (parameters.morphNormals)
        _programLayers.enable(5);
      if (parameters.morphColors)
        _programLayers.enable(6);
      if (parameters.premultipliedAlpha)
        _programLayers.enable(7);
      if (parameters.shadowMapEnabled)
        _programLayers.enable(8);
      if (parameters.physicallyCorrectLights)
        _programLayers.enable(9);
      if (parameters.doubleSided)
        _programLayers.enable(10);
      if (parameters.flipSided)
        _programLayers.enable(11);
      if (parameters.useDepthPacking)
        _programLayers.enable(12);
      if (parameters.dithering)
        _programLayers.enable(13);
      if (parameters.specularIntensityMap)
        _programLayers.enable(14);
      if (parameters.specularColorMap)
        _programLayers.enable(15);
      if (parameters.transmission)
        _programLayers.enable(16);
      if (parameters.transmissionMap)
        _programLayers.enable(17);
      if (parameters.thicknessMap)
        _programLayers.enable(18);
      if (parameters.sheen)
        _programLayers.enable(19);
      if (parameters.sheenColorMap)
        _programLayers.enable(20);
      if (parameters.sheenRoughnessMap)
        _programLayers.enable(21);
      if (parameters.decodeVideoTexture)
        _programLayers.enable(22);
      if (parameters.opaque)
        _programLayers.enable(23);
      array.push(_programLayers.mask);
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p = 0, pl = programs.length; p < pl; p++) {
        const preexistingProgram = programs[p];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer2, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    function releaseShaderCache(material) {
      _customShaders.remove(material);
    }
    function dispose() {
      _customShaders.dispose();
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      releaseShaderCache,
      programs,
      dispose
    };
  }
  function WebGLProperties() {
    let properties = /* @__PURE__ */ new WeakMap();
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      remove,
      update,
      dispose
    };
  }
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
      let renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1)
        transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
        const renderItem = renderItems[i];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists() {
    let lists = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth) {
      let list;
      if (lists.has(scene) === false) {
        list = new WebGLRenderList();
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= lists.get(scene).length) {
          list = new WebGLRenderList();
          lists.get(scene).push(list);
        } else {
          list = lists.get(scene)[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  var nextVersion = 0;
  function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    for (let i = 0; i < 9; i++)
      state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, physicallyCorrectLights) {
      let r = 0, g = 0, b = 0;
      for (let i = 0; i < 9; i++)
        state.probe[i].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      lights.sort(shadowCastingLightsFirst);
      const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r += color.r * intensity * scaleFactor;
          g += color.g * intensity * scaleFactor;
          b += color.b * intensity * scaleFactor;
        } else if (light.isLightProbe) {
          for (let j = 0; j < 9; j++) {
            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
            numSpotShadows++;
          }
          state.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state.ambient[0] = r;
      state.ambient[1] = g;
      state.ambient[2] = b;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotShadowMatrix.length = numSpotShadows;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        state.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        if (light.isDirectionalLight) {
          const uniforms = state.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(physicallyCorrectLights) {
      lights.setup(lightsArray, physicallyCorrectLights);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init,
      state,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth = 0) {
      let renderState;
      if (renderStates.has(scene) === false) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStates.get(scene).length) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStates.get(scene).push(renderState);
        } else {
          renderState = renderStates.get(scene)[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var MeshDepthMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshDepthMaterial = true;
      this.type = "MeshDepthMaterial";
      this.depthPacking = BasicDepthPacking;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.depthPacking = source.depthPacking;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  };
  var MeshDistanceMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshDistanceMaterial = true;
      this.type = "MeshDistanceMaterial";
      this.referencePosition = new Vector3();
      this.nearDistance = 1;
      this.farDistance = 1e3;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  };
  var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
  var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (let i = 0, il = lights.length; i < il; i++) {
        const light = lights[i];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
          shadow.camera.updateProjectionMatrix();
        }
        if (shadow.map === null) {
          const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
          _state.viewport(_viewport);
          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }
        if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
        shadow.needsUpdate = false;
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
      const geometry = _objects.update(fullScreenMesh);
      if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
        shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialVertical.needsUpdate = true;
        shadowMaterialHorizontal.needsUpdate = true;
      }
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
      let result = null;
      const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      }
      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k = 0, kl = groups.length; k < kl; k++) {
              const group = groups[k];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        renderObject(children[i], camera, shadowCamera, light, type);
      }
    }
  }
  function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }
          color.set(r, g, b, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;
                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;
                case LessDepth:
                  gl.depthFunc(513);
                  break;
                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;
                case EqualDepth:
                  gl.depthFunc(514);
                  break;
                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;
                case GreaterDepth:
                  gl.depthFunc(516);
                  break;
                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;
                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);
      for (let i = 0; i < count; i++) {
        gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (isWebGL2) {
          if (target === 36009) {
            currentBoundFramebuffers[36160] = framebuffer;
          }
          if (target === 36160) {
            currentBoundFramebuffers[36009] = framebuffer;
          }
        }
        return true;
      }
      return false;
    }
    function drawBuffers(renderTarget, framebuffer) {
      let drawBuffers2 = defaultDrawbuffers;
      let needsUpdate = false;
      if (renderTarget) {
        drawBuffers2 = currentDrawbuffers.get(framebuffer);
        if (drawBuffers2 === void 0) {
          drawBuffers2 = [];
          currentDrawbuffers.set(framebuffer, drawBuffers2);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures = renderTarget.texture;
          if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
            for (let i = 0, il = textures.length; i < il; i++) {
              drawBuffers2[i] = 36064 + i;
            }
            drawBuffers2.length = textures.length;
            needsUpdate = true;
          }
        } else {
          if (drawBuffers2[0] !== 36064) {
            drawBuffers2[0] = 36064;
            needsUpdate = true;
          }
        }
      } else {
        if (drawBuffers2[0] !== 1029) {
          drawBuffers2[0] = 1029;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          gl.drawBuffers(drawBuffers2);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
        }
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: 32774,
      [SubtractEquation]: 32778,
      [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: 0,
      [OneFactor]: 1,
      [SrcColorFactor]: 768,
      [SrcAlphaFactor]: 770,
      [SrcAlphaSaturateFactor]: 776,
      [DstColorFactor]: 774,
      [DstAlphaFactor]: 772,
      [OneMinusSrcColorFactor]: 769,
      [OneMinusSrcAlphaFactor]: 771,
      [OneMinusDstColorFactor]: 775,
      [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width2) {
      if (width2 !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width2);
        currentLineWidth = width2;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }
      let boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage2D() {
      try {
        gl.texSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage3D() {
      try {
        gl.texSubImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage2D() {
      try {
        gl.compressedTexSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage2D() {
      try {
        gl.texStorage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage3D() {
      try {
        gl.texStorage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function reset() {
      gl.disable(3042);
      gl.disable(2884);
      gl.disable(2929);
      gl.disable(32823);
      gl.disable(3089);
      gl.disable(2960);
      gl.disable(32926);
      gl.blendEquation(32774);
      gl.blendFunc(1, 0);
      gl.blendFuncSeparate(1, 0, 1, 0);
      gl.colorMask(true, true, true, true);
      gl.clearColor(0, 0, 0, 0);
      gl.depthMask(true);
      gl.depthFunc(513);
      gl.clearDepth(1);
      gl.stencilMask(4294967295);
      gl.stencilFunc(519, 0, 4294967295);
      gl.stencilOp(7680, 7680, 7680);
      gl.clearStencil(0);
      gl.cullFace(1029);
      gl.frontFace(2305);
      gl.polygonOffset(0, 0);
      gl.activeTexture(33984);
      gl.bindFramebuffer(36160, null);
      if (isWebGL2 === true) {
        gl.bindFramebuffer(36009, null);
        gl.bindFramebuffer(36008, null);
      }
      gl.useProgram(null);
      gl.lineWidth(1);
      gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentBoundFramebuffers = {};
      currentDrawbuffers = /* @__PURE__ */ new WeakMap();
      defaultDrawbuffers = [];
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
      currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      drawBuffers,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      texImage2D,
      texImage3D,
      texStorage2D,
      texStorage3D,
      texSubImage2D,
      texSubImage3D,
      compressedTexSubImage2D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
    const supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);
    const _videoTextures = /* @__PURE__ */ new WeakMap();
    let _canvas2;
    const _sources = /* @__PURE__ */ new WeakMap();
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width2, height) {
      return useOffscreenCanvas ? new OffscreenCanvas(width2, height) : createElementNS("canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }
      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
          const width2 = floor(scale * image.width);
          const height = floor(scale * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width2, height);
          const canvas = needsNewCanvas ? createCanvas(width2, height) : _canvas2;
          canvas.width = width2;
          canvas.height = height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width2, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width2 + "x" + height + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo$1(image) {
      return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target) {
      _gl.generateMipmap(target);
    }
    function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 33319) {
        if (glType === 5126)
          internalFormat = 33328;
        if (glType === 5131)
          internalFormat = 33327;
        if (glType === 5121)
          internalFormat = 33323;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
        if (glType === 32819)
          internalFormat = 32854;
        if (glType === 32820)
          internalFormat = 32855;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function getMipLevels(texture, image, supportsMips) {
      if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        return Math.log2(Math.max(image.width, image.height)) + 1;
      } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
        return texture.mipmaps.length;
      } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
        return image.mipmaps.length;
      } else {
        return 1;
      }
    }
    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      const source = texture.source;
      const webglTextures = _sources.get(source);
      if (webglTextures) {
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        webglTexture.usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
        if (Object.keys(webglTextures).length === 0) {
          _sources.delete(source);
        }
      }
      properties.remove(texture);
    }
    function deleteTexture(texture) {
      const textureProperties = properties.get(texture);
      _gl.deleteTexture(textureProperties.__webglTexture);
      const source = texture.source;
      const webglTextures = _sources.get(source);
      delete webglTextures[textureProperties.__cacheKey];
      info.memory.textures--;
    }
    function deallocateRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
        info.memory.textures--;
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer) {
          for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
            if (renderTargetProperties.__webglColorRenderbuffer[i])
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
          }
        }
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        for (let i = 0, il = texture.length; i < il; i++) {
          const attachmentProperties = properties.get(texture[i]);
          if (attachmentProperties.__webglTexture) {
            _gl.deleteTexture(attachmentProperties.__webglTexture);
            info.memory.textures--;
          }
          properties.remove(texture[i]);
        }
      }
      properties.remove(texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function getTextureCacheKey(texture) {
      const array = [];
      array.push(texture.wrapS);
      array.push(texture.wrapT);
      array.push(texture.magFilter);
      array.push(texture.minFilter);
      array.push(texture.anisotropy);
      array.push(texture.internalFormat);
      array.push(texture.format);
      array.push(texture.type);
      array.push(texture.generateMipmaps);
      array.push(texture.premultiplyAlpha);
      array.push(texture.flipY);
      array.push(texture.unpackAlignment);
      array.push(texture.encoding);
      return array.join();
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === null) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
      [RepeatWrapping]: 10497,
      [ClampToEdgeWrapping]: 33071,
      [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
      [NearestFilter]: 9728,
      [NearestMipmapNearestFilter]: 9984,
      [NearestMipmapLinearFilter]: 9986,
      [LinearFilter]: 9729,
      [LinearMipmapNearestFilter]: 9985,
      [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      let forceUpload = false;
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
      }
      const source = texture.source;
      let webglTextures = _sources.get(source);
      if (webglTextures === void 0) {
        webglTextures = {};
        _sources.set(source, webglTextures);
      }
      const textureCacheKey = getTextureCacheKey(texture);
      if (textureCacheKey !== textureProperties.__cacheKey) {
        if (webglTextures[textureCacheKey] === void 0) {
          webglTextures[textureCacheKey] = {
            texture: _gl.createTexture(),
            usedTimes: 0
          };
          info.memory.textures++;
          forceUpload = true;
        }
        webglTextures[textureCacheKey].usedTimes++;
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        if (webglTexture !== void 0) {
          webglTextures[textureProperties.__cacheKey].usedTimes--;
          if (webglTexture.usedTimes === 0) {
            deleteTexture(texture);
          }
        }
        textureProperties.__cacheKey = textureCacheKey;
        textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
      }
      return forceUpload;
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = 3553;
      if (texture.isDataArrayTexture)
        textureType = 35866;
      if (texture.isData3DTexture)
        textureType = 32879;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.activeTexture(33984 + slot);
      state.bindTexture(textureType, textureProperties.__webglTexture);
      if (source.version !== source.__currentVersion || forceUpload === true) {
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
        let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        image = verifyColorSpace(texture, image);
        const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = source.__currentVersion === void 0 || forceUpload === true;
        const levels = getMipLevels(texture, image, supportsMips);
        if (texture.isDepthTexture) {
          glInternalFormat = 6402;
          if (isWebGL2) {
            if (texture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (texture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            } else if (texture.type === UnsignedInt248Type) {
              glInternalFormat = 35056;
            } else {
              glInternalFormat = 33189;
            }
          } else {
            if (texture.type === FloatType) {
              console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
            }
          }
          if (texture.format === DepthFormat && glInternalFormat === 6402) {
            if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
              console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
              texture.type = UnsignedIntType;
              glType = utils.convert(texture.type);
            }
          }
          if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
            glInternalFormat = 34041;
            if (texture.type !== UnsignedInt248Type) {
              console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
              texture.type = UnsignedInt248Type;
              glType = utils.convert(texture.type);
            }
          }
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
            } else {
              state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
          }
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
              }
              state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            } else {
              state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
          }
        } else if (texture.isCompressedTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else if (texture.isDataArrayTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isData3DTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isFramebufferTexture) {
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            } else {
              let width2 = image.width, height = image.height;
              for (let i = 0; i < levels; i++) {
                state.texImage2D(3553, i, glInternalFormat, width2, height, 0, glFormat, glType, null);
                width2 >>= 1;
                height >>= 1;
              }
            }
          }
        } else {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                state.texSubImage2D(3553, i, 0, 0, glFormat, glType, mipmap);
              } else {
                state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
              }
              state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
            } else {
              state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(textureType);
        }
        source.__currentVersion = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
      if (source.version !== source.__currentVersion || forceUpload === true) {
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for (let i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
          cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
        }
        const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = source.__currentVersion === void 0 || forceUpload === true;
        let levels = getMipLevels(texture, image, supportsMips);
        setTextureParameters(34067, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
          }
          for (let i = 0; i < 6; i++) {
            mipmaps = cubeImage[i].mipmaps;
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state.compressedTexSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  } else {
                    state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                if (useTexStorage) {
                  state.texSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else {
          mipmaps = texture.mipmaps;
          if (useTexStorage && allocateMemory) {
            if (mipmaps.length > 0)
              levels++;
            state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
          }
          for (let i = 0; i < 6; i++) {
            if (isDataTexture) {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
              } else {
                state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                const mipmapImage = mipmap.image[i].image;
                if (useTexStorage) {
                  state.texSubImage2D(34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                } else {
                  state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
              } else {
                state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                if (useTexStorage) {
                  state.texSubImage2D(34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                } else {
                  state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                }
              }
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067);
        }
        source.__currentVersion = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
      const glFormat = utils.convert(texture.format, texture.encoding);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const renderTargetProperties = properties.get(renderTarget);
      if (!renderTargetProperties.__hasExternalTextures) {
        if (textureTarget === 32879 || textureTarget === 35866) {
          state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
      }
      state.bindFramebuffer(36160, framebuffer);
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
      } else {
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
      }
      state.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = 33189;
        if (isMultisample || useMultisampledRTT(renderTarget)) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
        for (let i = 0; i < textures.length; i++) {
          const texture = textures[i];
          const glFormat = utils.convert(texture.format, texture.encoding);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          if (isMultisample && useMultisampledRTT(renderTarget) === false) {
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      const samples = getRenderTargetSamples(renderTarget);
      if (renderTarget.depthTexture.format === DepthFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        }
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        }
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++) {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          }
        } else {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state.bindFramebuffer(36160, null);
    }
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      if (colorTexture !== void 0) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
      }
      if (depthTexture !== void 0) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      if (renderTarget.isWebGLMultipleRenderTargets !== true) {
        if (textureProperties.__webglTexture === void 0) {
          textureProperties.__webglTexture = _gl.createTexture();
        }
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i = 0; i < 6; i++) {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultipleRenderTargets) {
          if (capabilities.drawBuffers) {
            const textures = renderTarget.texture;
            for (let i = 0, il = textures.length; i < il; i++) {
              const attachmentProperties = properties.get(textures[i]);
              if (attachmentProperties.__webglTexture === void 0) {
                attachmentProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
              }
            }
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          }
        }
        if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
          const textures = isMultipleRenderTargets ? texture : [texture];
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = [];
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          for (let i = 0; i < textures.length; i++) {
            const texture2 = textures[i];
            renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer[i]);
            const glFormat = utils.convert(texture2.format, texture2.encoding);
            const glType = utils.convert(texture2.type);
            const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[i]);
          }
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        }
      }
      if (isCube) {
        state.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, texture, supportsMips);
        for (let i = 0; i < 6; i++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i);
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067);
        }
        state.unbindTexture();
      } else if (isMultipleRenderTargets) {
        const textures = renderTarget.texture;
        for (let i = 0, il = textures.length; i < il; i++) {
          const attachment = textures[i];
          const attachmentProperties = properties.get(attachment);
          state.bindTexture(3553, attachmentProperties.__webglTexture);
          setTextureParameters(3553, attachment, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);
          if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
            generateMipmap(3553);
          }
        }
        state.unbindTexture();
      } else {
        let glTextureType = 3553;
        if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
          if (isWebGL2) {
            glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
          } else {
            console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
          }
        }
        state.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(glTextureType);
        }
        state.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i = 0, il = textures.length; i < il; i++) {
        const texture = textures[i];
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
          const webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(target, webglTexture);
          generateMipmap(target);
          state.unbindTexture();
        }
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
        const width2 = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        const invalidationArray = [];
        const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064 + i, 36161, null);
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(36009, 36064 + i, 3553, null, 0);
          }
        }
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          invalidationArray.push(36064 + i);
          if (renderTarget.depthBuffer) {
            invalidationArray.push(depthStyle);
          }
          const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
          if (ignoreDepthValues === false) {
            if (renderTarget.depthBuffer)
              mask |= 256;
            if (renderTarget.stencilBuffer)
              mask |= 1024;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[i]);
          }
          if (ignoreDepthValues === true) {
            _gl.invalidateFramebuffer(36008, [depthStyle]);
            _gl.invalidateFramebuffer(36009, [depthStyle]);
          }
          if (isMultipleRenderTargets) {
            const webglTexture = properties.get(textures[i]).__webglTexture;
            _gl.framebufferTexture2D(36009, 36064, 3553, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width2, height, 0, 0, width2, height, mask, 9728);
          if (supportsInvalidateFramebuffer) {
            _gl.invalidateFramebuffer(36008, invalidationArray);
          }
        }
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, null);
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(36009, 36064 + i, 3553, webglTexture, 0);
          }
        }
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return Math.min(maxSamples, renderTarget.samples);
    }
    function useMultisampledRTT(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    function verifyColorSpace(texture, image) {
      const encoding = texture.encoding;
      const format = texture.format;
      const type = texture.type;
      if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
        return image;
      if (encoding !== LinearEncoding) {
        if (encoding === sRGBEncoding) {
          if (isWebGL2 === false) {
            if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
              texture.format = _SRGBAFormat;
              texture.minFilter = LinearFilter;
              texture.generateMipmaps = false;
            } else {
              image = ImageUtils.sRGBToLinear(image);
            }
          } else {
            if (format !== RGBAFormat || type !== UnsignedByteType) {
              console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
            }
          }
        } else {
          console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
        }
      }
      return image;
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.useMultisampledRTT = useMultisampledRTT;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p, encoding = null) {
      let extension;
      if (p === UnsignedByteType)
        return 5121;
      if (p === UnsignedShort4444Type)
        return 32819;
      if (p === UnsignedShort5551Type)
        return 32820;
      if (p === ByteType)
        return 5120;
      if (p === ShortType)
        return 5122;
      if (p === UnsignedShortType)
        return 5123;
      if (p === IntType)
        return 5124;
      if (p === UnsignedIntType)
        return 5125;
      if (p === FloatType)
        return 5126;
      if (p === HalfFloatType) {
        if (isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p === AlphaFormat)
        return 6406;
      if (p === RGBAFormat)
        return 6408;
      if (p === LuminanceFormat)
        return 6409;
      if (p === LuminanceAlphaFormat)
        return 6410;
      if (p === DepthFormat)
        return 6402;
      if (p === DepthStencilFormat)
        return 34041;
      if (p === RedFormat)
        return 6403;
      if (p === RGBFormat) {
        console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
        return 6408;
      }
      if (p === _SRGBAFormat) {
        extension = extensions.get("EXT_sRGB");
        if (extension !== null) {
          return extension.SRGB_ALPHA_EXT;
        } else {
          return null;
        }
      }
      if (p === RedIntegerFormat)
        return 36244;
      if (p === RGFormat)
        return 33319;
      if (p === RGIntegerFormat)
        return 33320;
      if (p === RGBAIntegerFormat)
        return 36249;
      if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
        if (encoding === sRGBEncoding) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        } else {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
      }
      if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p === RGB_ETC2_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
          if (p === RGBA_ETC2_EAC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        } else {
          return null;
        }
      }
      if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          if (p === RGBA_ASTC_4x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (p === RGBA_ASTC_5x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (p === RGBA_ASTC_5x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (p === RGBA_ASTC_6x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (p === RGBA_ASTC_6x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (p === RGBA_ASTC_8x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (p === RGBA_ASTC_8x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (p === RGBA_ASTC_8x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (p === RGBA_ASTC_10x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (p === RGBA_ASTC_10x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (p === RGBA_ASTC_10x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (p === RGBA_ASTC_10x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (p === RGBA_ASTC_12x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (p === RGBA_ASTC_12x12_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else {
          return null;
        }
      }
      if (p === RGBA_BPTC_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          if (p === RGBA_BPTC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        } else {
          return null;
        }
      }
      if (p === UnsignedInt248Type) {
        if (isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
      return gl[p] !== void 0 ? gl[p] : null;
    }
    return { convert };
  }
  var ArrayCamera = class extends PerspectiveCamera {
    constructor(array = []) {
      super();
      this.isArrayCamera = true;
      this.cameras = array;
    }
  };
  var Group = class extends Object3D {
    constructor() {
      super();
      this.isGroup = true;
      this.type = "Group";
    }
  };
  var _moveEvent = { type: "move" };
  var WebXRController = class {
    constructor() {
      this._targetRay = null;
      this._grip = null;
      this._hand = null;
    }
    getHandSpace() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = { pinching: false };
      }
      return this._hand;
    }
    getTargetRaySpace() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
        this._targetRay.hasLinearVelocity = false;
        this._targetRay.linearVelocity = new Vector3();
        this._targetRay.hasAngularVelocity = false;
        this._targetRay.angularVelocity = new Vector3();
      }
      return this._targetRay;
    }
    getGripSpace() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
        this._grip.hasLinearVelocity = false;
        this._grip.linearVelocity = new Vector3();
        this._grip.hasAngularVelocity = false;
        this._grip.angularVelocity = new Vector3();
      }
      return this._grip;
    }
    dispatchEvent(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }
      return this;
    }
    disconnect(inputSource) {
      this.dispatchEvent({ type: "disconnected", data: inputSource });
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    }
    update(inputSource, frame, referenceSpace) {
      let inputPose = null;
      let gripPose = null;
      let handPose = null;
      const targetRay = this._targetRay;
      const grip = this._grip;
      const hand = this._hand;
      if (inputSource && frame.session.visibilityState !== "visible-blurred") {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
            if (inputPose.linearVelocity) {
              targetRay.hasLinearVelocity = true;
              targetRay.linearVelocity.copy(inputPose.linearVelocity);
            } else {
              targetRay.hasLinearVelocity = false;
            }
            if (inputPose.angularVelocity) {
              targetRay.hasAngularVelocity = true;
              targetRay.angularVelocity.copy(inputPose.angularVelocity);
            } else {
              targetRay.hasAngularVelocity = false;
            }
            this.dispatchEvent(_moveEvent);
          }
        }
        if (hand && inputSource.hand) {
          handPose = true;
          for (const inputjoint of inputSource.hand.values()) {
            const jointPose = frame.getJointPose(inputjoint, referenceSpace);
            if (hand.joints[inputjoint.jointName] === void 0) {
              const joint2 = new Group();
              joint2.matrixAutoUpdate = false;
              joint2.visible = false;
              hand.joints[inputjoint.jointName] = joint2;
              hand.add(joint2);
            }
            const joint = hand.joints[inputjoint.jointName];
            if (jointPose !== null) {
              joint.matrix.fromArray(jointPose.transform.matrix);
              joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
              joint.jointRadius = jointPose.radius;
            }
            joint.visible = jointPose !== null;
          }
          const indexTip = hand.joints["index-finger-tip"];
          const thumbTip = hand.joints["thumb-tip"];
          const distance = indexTip.position.distanceTo(thumbTip.position);
          const distanceToPinch = 0.02;
          const threshold = 5e-3;
          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: "pinchend",
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: "pinchstart",
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              if (gripPose.linearVelocity) {
                grip.hasLinearVelocity = true;
                grip.linearVelocity.copy(gripPose.linearVelocity);
              } else {
                grip.hasLinearVelocity = false;
              }
              if (gripPose.angularVelocity) {
                grip.hasAngularVelocity = true;
                grip.angularVelocity.copy(gripPose.angularVelocity);
              } else {
                grip.hasAngularVelocity = false;
              }
            }
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }
  };
  var DepthTexture = class extends Texture {
    constructor(width2, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
      format = format !== void 0 ? format : DepthFormat;
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      }
      if (type === void 0 && format === DepthFormat)
        type = UnsignedIntType;
      if (type === void 0 && format === DepthStencilFormat)
        type = UnsignedInt248Type;
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.isDepthTexture = true;
      this.image = { width: width2, height };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
    }
  };
  var WebXRManager = class extends EventDispatcher {
    constructor(renderer2, gl) {
      super();
      const scope = this;
      let session = null;
      let framebufferScaleFactor = 1;
      let referenceSpace = null;
      let referenceSpaceType = "local-floor";
      let customReferenceSpace = null;
      let pose = null;
      let glBinding = null;
      let glProjLayer = null;
      let glBaseLayer = null;
      let xrFrame = null;
      const attributes = gl.getContextAttributes();
      let initialRenderTarget = null;
      let newRenderTarget = null;
      const controllers = [];
      const inputSourcesMap = /* @__PURE__ */ new Map();
      const cameraL = new PerspectiveCamera();
      cameraL.layers.enable(1);
      cameraL.viewport = new Vector4();
      const cameraR = new PerspectiveCamera();
      cameraR.layers.enable(2);
      cameraR.viewport = new Vector4();
      const cameras = [cameraL, cameraR];
      const cameraVR = new ArrayCamera();
      cameraVR.layers.enable(1);
      cameraVR.layers.enable(2);
      let _currentDepthNear = null;
      let _currentDepthFar = null;
      this.cameraAutoUpdate = true;
      this.enabled = false;
      this.isPresenting = false;
      this.getController = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
      };
      this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getGripSpace();
      };
      this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getHandSpace();
      };
      function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller !== void 0) {
          controller.dispatchEvent({ type: event.type, data: event.inputSource });
        }
      }
      function onSessionEnd() {
        session.removeEventListener("select", onSessionEvent);
        session.removeEventListener("selectstart", onSessionEvent);
        session.removeEventListener("selectend", onSessionEvent);
        session.removeEventListener("squeeze", onSessionEvent);
        session.removeEventListener("squeezestart", onSessionEvent);
        session.removeEventListener("squeezeend", onSessionEvent);
        session.removeEventListener("end", onSessionEnd);
        session.removeEventListener("inputsourceschange", onInputSourcesChange);
        inputSourcesMap.forEach(function(controller, inputSource) {
          if (controller !== void 0) {
            controller.disconnect(inputSource);
          }
        });
        inputSourcesMap.clear();
        _currentDepthNear = null;
        _currentDepthFar = null;
        renderer2.setRenderTarget(initialRenderTarget);
        glBaseLayer = null;
        glProjLayer = null;
        glBinding = null;
        session = null;
        newRenderTarget = null;
        animation.stop();
        scope.isPresenting = false;
        scope.dispatchEvent({ type: "sessionend" });
      }
      this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }
      };
      this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }
      };
      this.getReferenceSpace = function() {
        return customReferenceSpace || referenceSpace;
      };
      this.setReferenceSpace = function(space) {
        customReferenceSpace = space;
      };
      this.getBaseLayer = function() {
        return glProjLayer !== null ? glProjLayer : glBaseLayer;
      };
      this.getBinding = function() {
        return glBinding;
      };
      this.getFrame = function() {
        return xrFrame;
      };
      this.getSession = function() {
        return session;
      };
      this.setSession = async function(value) {
        session = value;
        if (session !== null) {
          initialRenderTarget = renderer2.getRenderTarget();
          session.addEventListener("select", onSessionEvent);
          session.addEventListener("selectstart", onSessionEvent);
          session.addEventListener("selectend", onSessionEvent);
          session.addEventListener("squeeze", onSessionEvent);
          session.addEventListener("squeezestart", onSessionEvent);
          session.addEventListener("squeezeend", onSessionEvent);
          session.addEventListener("end", onSessionEnd);
          session.addEventListener("inputsourceschange", onInputSourcesChange);
          if (attributes.xrCompatible !== true) {
            await gl.makeXRCompatible();
          }
          if (session.renderState.layers === void 0 || renderer2.capabilities.isWebGL2 === false) {
            const layerInit = {
              antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
              alpha: attributes.alpha,
              depth: attributes.depth,
              stencil: attributes.stencil,
              framebufferScaleFactor
            };
            glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({ baseLayer: glBaseLayer });
            newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
              format: RGBAFormat,
              type: UnsignedByteType,
              encoding: renderer2.outputEncoding
            });
          } else {
            let depthFormat = null;
            let depthType = null;
            let glDepthFormat = null;
            if (attributes.depth) {
              glDepthFormat = attributes.stencil ? 35056 : 33190;
              depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
              depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
            }
            const projectionlayerInit = {
              colorFormat: renderer2.outputEncoding === sRGBEncoding ? 35907 : 32856,
              depthFormat: glDepthFormat,
              scaleFactor: framebufferScaleFactor
            };
            glBinding = new XRWebGLBinding(session, gl);
            glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
            session.updateRenderState({ layers: [glProjLayer] });
            newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              encoding: renderer2.outputEncoding,
              samples: attributes.antialias ? 4 : 0
            });
            const renderTargetProperties = renderer2.properties.get(newRenderTarget);
            renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
          }
          newRenderTarget.isXRRenderTarget = true;
          this.setFoveation(1);
          customReferenceSpace = null;
          referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
          animation.setContext(session);
          animation.start();
          scope.isPresenting = true;
          scope.dispatchEvent({ type: "sessionstart" });
        }
      };
      function onInputSourcesChange(event) {
        const inputSources = session.inputSources;
        for (let i = 0; i < inputSources.length; i++) {
          const index = inputSources[i].handedness === "right" ? 1 : 0;
          inputSourcesMap.set(inputSources[i], controllers[index]);
        }
        for (let i = 0; i < event.removed.length; i++) {
          const inputSource = event.removed[i];
          const controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({ type: "disconnected", data: inputSource });
            inputSourcesMap.delete(inputSource);
          }
        }
        for (let i = 0; i < event.added.length; i++) {
          const inputSource = event.added[i];
          const controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({ type: "connected", data: inputSource });
          }
        }
      }
      const cameraLPos = new Vector3();
      const cameraRPos = new Vector3();
      function setProjectionFromUnion(camera, cameraL2, cameraR2) {
        cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL2.projectionMatrix.elements;
        const projR = cameraR2.projectionMatrix.elements;
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      }
      function updateCamera(camera, parent) {
        if (parent === null) {
          camera.matrixWorld.copy(camera.matrix);
        } else {
          camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        }
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      }
      this.updateCamera = function(camera) {
        if (session === null)
          return;
        cameraVR.near = cameraR.near = cameraL.near = camera.near;
        cameraVR.far = cameraR.far = cameraL.far = camera.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
          session.updateRenderState({
            depthNear: cameraVR.near,
            depthFar: cameraVR.far
          });
          _currentDepthNear = cameraVR.near;
          _currentDepthFar = cameraVR.far;
        }
        const parent = camera.parent;
        const cameras2 = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for (let i = 0; i < cameras2.length; i++) {
          updateCamera(cameras2[i], parent);
        }
        cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
        camera.position.copy(cameraVR.position);
        camera.quaternion.copy(cameraVR.quaternion);
        camera.scale.copy(cameraVR.scale);
        camera.matrix.copy(cameraVR.matrix);
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        const children = camera.children;
        for (let i = 0, l = children.length; i < l; i++) {
          children[i].updateMatrixWorld(true);
        }
        if (cameras2.length === 2) {
          setProjectionFromUnion(cameraVR, cameraL, cameraR);
        } else {
          cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        }
      };
      this.getCamera = function() {
        return cameraVR;
      };
      this.getFoveation = function() {
        if (glProjLayer !== null) {
          return glProjLayer.fixedFoveation;
        }
        if (glBaseLayer !== null) {
          return glBaseLayer.fixedFoveation;
        }
        return void 0;
      };
      this.setFoveation = function(foveation) {
        if (glProjLayer !== null) {
          glProjLayer.fixedFoveation = foveation;
        }
        if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
          glBaseLayer.fixedFoveation = foveation;
        }
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
        xrFrame = frame;
        if (pose !== null) {
          const views = pose.views;
          if (glBaseLayer !== null) {
            renderer2.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
            renderer2.setRenderTarget(newRenderTarget);
          }
          let cameraVRNeedsUpdate = false;
          if (views.length !== cameraVR.cameras.length) {
            cameraVR.cameras.length = 0;
            cameraVRNeedsUpdate = true;
          }
          for (let i = 0; i < views.length; i++) {
            const view = views[i];
            let viewport = null;
            if (glBaseLayer !== null) {
              viewport = glBaseLayer.getViewport(view);
            } else {
              const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
              viewport = glSubImage.viewport;
              if (i === 0) {
                renderer2.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
                renderer2.setRenderTarget(newRenderTarget);
              }
            }
            let camera = cameras[i];
            if (camera === void 0) {
              camera = new PerspectiveCamera();
              camera.layers.enable(i);
              camera.viewport = new Vector4();
              cameras[i] = camera;
            }
            camera.matrix.fromArray(view.transform.matrix);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
            if (i === 0) {
              cameraVR.matrix.copy(camera.matrix);
            }
            if (cameraVRNeedsUpdate === true) {
              cameraVR.cameras.push(camera);
            }
          }
        }
        const inputSources = session.inputSources;
        for (let i = 0; i < controllers.length; i++) {
          const inputSource = inputSources[i];
          const controller = inputSourcesMap.get(inputSource);
          if (controller !== void 0) {
            controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
          }
        }
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time, frame);
        xrFrame = null;
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
      };
      this.dispose = function() {
      };
    }
  };
  function WebGLMaterials(renderer2, properties) {
    function refreshFogUniforms(uniforms, fog) {
      uniforms.fogColor.value.copy(fog.color);
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsStandard(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        const scaleFactor = renderer2.physicallyCorrectLights !== true ? Math.PI : 1;
        uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      } else if (material.clearcoatMap) {
        uvScaleMap = material.clearcoatMap;
      } else if (material.clearcoatNormalMap) {
        uvScaleMap = material.clearcoatNormalMap;
      } else if (material.clearcoatRoughnessMap) {
        uvScaleMap = material.clearcoatRoughnessMap;
      } else if (material.iridescenceMap) {
        uvScaleMap = material.iridescenceMap;
      } else if (material.iridescenceThicknessMap) {
        uvScaleMap = material.iridescenceThicknessMap;
      } else if (material.specularIntensityMap) {
        uvScaleMap = material.specularIntensityMap;
      } else if (material.specularColorMap) {
        uvScaleMap = material.specularColorMap;
      } else if (material.transmissionMap) {
        uvScaleMap = material.transmissionMap;
      } else if (material.thicknessMap) {
        uvScaleMap = material.thicknessMap;
      } else if (material.sheenColorMap) {
        uvScaleMap = material.sheenColorMap;
      } else if (material.sheenRoughnessMap) {
        uvScaleMap = material.sheenRoughnessMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
      let uv2ScaleMap;
      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }
      if (uv2ScaleMap !== void 0) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }
        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }
        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
        if (material.sheenColorMap) {
          uniforms.sheenColorMap.value = material.sheenColorMap;
        }
        if (material.sheenRoughnessMap) {
          uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        }
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.iridescence > 0) {
        uniforms.iridescence.value = material.iridescence;
        uniforms.iridescenceIOR.value = material.iridescenceIOR;
        uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
        uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
        if (material.iridescenceMap) {
          uniforms.iridescenceMap.value = material.iridescenceMap;
        }
        if (material.iridescenceThicknessMap) {
          uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationColor.value.copy(material.attenuationColor);
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularColor.value.copy(material.specularColor);
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
      }
      if (material.specularColorMap) {
        uniforms.specularColorMap.value = material.specularColorMap;
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function createCanvasElement() {
    const canvas = createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
  }
  function WebGLRenderer(parameters = {}) {
    this.isWebGLRenderer = true;
    const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
    let _alpha;
    if (_context !== null) {
      _alpha = _context.getContextAttributes().alpha;
    } else {
      _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
    }
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = _canvas2;
    this.debug = {
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    Object.defineProperties(this, {
      gammaFactor: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          return 2;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        }
      }
    });
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix = new Matrix4();
    const _vector22 = new Vector2();
    const _vector3 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context;
    function getContext(contextNames, contextAttributes) {
      for (let i = 0; i < contextNames.length; i++) {
        const contextName = contextNames[i];
        const context = _canvas2.getContext(contextName, contextAttributes);
        if (context !== null)
          return context;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in _canvas2)
        _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      _canvas2.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width2, height, updateStyle) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width2;
      _height = height;
      _canvas2.width = Math.floor(width2 * _pixelRatio);
      _canvas2.height = Math.floor(height * _pixelRatio);
      if (updateStyle !== false) {
        _canvas2.style.width = width2 + "px";
        _canvas2.style.height = height + "px";
      }
      this.setViewport(0, 0, width2, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width2, height, pixelRatio) {
      _width = width2;
      _height = height;
      _pixelRatio = pixelRatio;
      _canvas2.width = Math.floor(width2 * pixelRatio);
      _canvas2.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width2, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width2, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width2, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width2, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width2, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth = true, stencil = true) {
      let bits = 0;
      if (color)
        bits |= 16384;
      if (depth)
        bits |= 256;
      if (stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      _canvas2.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      const position = geometry.attributes.position;
      if (index === null) {
        if (position === void 0 || position.count === 0)
          return;
      } else if (index.count === 0) {
        return;
      }
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer2 = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer2 = indexedBufferRenderer;
        renderer2.setIndex(attribute);
      }
      const dataCount = index !== null ? index.count : position.count;
      const rangeStart = geometry.drawRange.start * rangeFactor;
      const rangeCount = geometry.drawRange.count * rangeFactor;
      const groupStart = group !== null ? group.start * rangeFactor : 0;
      const groupCount = group !== null ? group.count * rangeFactor : Infinity;
      const drawStart = Math.max(rangeStart, groupStart);
      const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      const drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0)
        return;
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer2.setMode(1);
        } else {
          renderer2.setMode(4);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer2.setMode(1);
        } else if (object.isLineLoop) {
          renderer2.setMode(2);
        } else {
          renderer2.setMode(3);
        }
      } else if (object.isPoints) {
        renderer2.setMode(0);
      } else if (object.isSprite) {
        renderer2.setMode(4);
      }
      if (object.isInstancedMesh) {
        renderer2.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
        renderer2.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer2.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene, camera) {
      currentRenderState = renderStates.get(scene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      scene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              getProgram(material2, scene, object);
            }
          } else {
            getProgram(material, scene, object);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined")
      animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.autoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null)
        camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true)
          xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i = 0, l = cameras.length; i < l; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info.render.frame;
            }
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, scene, camera);
      if (viewport)
        state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, scene, camera) {
      const isWebGL2 = capabilities.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 && _antialias === true ? 4 : 0
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      _this.toneMapping = currentToneMapping;
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      _this.setRenderTarget(currentRenderTarget);
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputEncoding = parameters2.outputEncoding;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputEncoding !== encoding) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
          }
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
        morphtargets.update(object, geometry, material, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(36160, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
      }
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(36160, framebuffer);
      if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width2, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(36160, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width2 && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width2, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(36160, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width2 = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width2, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width2 = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level, position.x, position.y, width2, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(3553);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width2 = sourceBox.max.x - sourceBox.min.x + 1;
      const height = sourceBox.max.y - sourceBox.min.y + 1;
      const depth = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = 32879;
      } else if (dstTexture.isDataArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = 35866;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(3314);
      const unpackImageHeight = _gl.getParameter(32878);
      const unpackSkipPixels = _gl.getParameter(3316);
      const unpackSkipRows = _gl.getParameter(3315);
      const unpackSkipImages = _gl.getParameter(32877);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(3314, image.width);
      _gl.pixelStorei(32878, image.height);
      _gl.pixelStorei(3316, sourceBox.min.x);
      _gl.pixelStorei(3315, sourceBox.min.y);
      _gl.pixelStorei(32877, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height, depth, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height, depth, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height, depth, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(3314, unpackRowLen);
      _gl.pixelStorei(32878, unpackImageHeight);
      _gl.pixelStorei(3316, unpackSkipPixels);
      _gl.pixelStorei(3315, unpackSkipRows);
      _gl.pixelStorei(32877, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      textures.setTexture2D(texture, 0);
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  var WebGL1Renderer = class extends WebGLRenderer {
  };
  WebGL1Renderer.prototype.isWebGL1Renderer = true;
  var Scene = class extends Object3D {
    constructor() {
      super();
      this.isScene = true;
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null)
        this.background = source.background.clone();
      if (source.environment !== null)
        this.environment = source.environment.clone();
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
      return data;
    }
  };
  var SpriteMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isSpriteMaterial = true;
      this.type = "SpriteMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.rotation = 0;
      this.sizeAttenuation = true;
      this.transparent = true;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      this.fog = source.fog;
      return this;
    }
  };
  var DataTexture = class extends Texture {
    constructor(data = null, width2 = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.isDataTexture = true;
      this.image = { data, width: width2, height };
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  var LineBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isLineBasicMaterial = true;
      this.type = "LineBasicMaterial";
      this.color = new Color(16777215);
      this.linewidth = 1;
      this.linecap = "round";
      this.linejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      this.fog = source.fog;
      return this;
    }
  };
  var PointsMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isPointsMaterial = true;
      this.type = "PointsMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.fog = source.fog;
      return this;
    }
  };
  function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }
  var tmp = new Vector3();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();
  var _v0 = new Vector3();
  var _v1$1 = new Vector3();
  var _normal = new Vector3();
  var _triangle = new Triangle();
  var ShadowMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isShadowMaterial = true;
      this.type = "ShadowMaterial";
      this.color = new Color(0);
      this.transparent = true;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.fog = source.fog;
      return this;
    }
  };
  var RawShaderMaterial = class extends ShaderMaterial {
    constructor(parameters) {
      super(parameters);
      this.isRawShaderMaterial = true;
      this.type = "RawShaderMaterial";
    }
  };
  var MeshStandardMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshStandardMaterial = true;
      this.defines = { "STANDARD": "" };
      this.type = "MeshStandardMaterial";
      this.color = new Color(16777215);
      this.roughness = 1;
      this.metalness = 0;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.roughnessMap = null;
      this.metalnessMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapIntensity = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.flatShading = false;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "STANDARD": "" };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  };
  var MeshPhysicalMaterial = class extends MeshStandardMaterial {
    constructor(parameters) {
      super();
      this.isMeshPhysicalMaterial = true;
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.type = "MeshPhysicalMaterial";
      this.clearcoatMap = null;
      this.clearcoatRoughness = 0;
      this.clearcoatRoughnessMap = null;
      this.clearcoatNormalScale = new Vector2(1, 1);
      this.clearcoatNormalMap = null;
      this.ior = 1.5;
      Object.defineProperty(this, "reflectivity", {
        get: function() {
          return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(reflectivity) {
          this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
        }
      });
      this.iridescenceMap = null;
      this.iridescenceIOR = 1.3;
      this.iridescenceThicknessRange = [100, 400];
      this.iridescenceThicknessMap = null;
      this.sheenColor = new Color(0);
      this.sheenColorMap = null;
      this.sheenRoughness = 1;
      this.sheenRoughnessMap = null;
      this.transmissionMap = null;
      this.thickness = 0;
      this.thicknessMap = null;
      this.attenuationDistance = 0;
      this.attenuationColor = new Color(1, 1, 1);
      this.specularIntensity = 1;
      this.specularIntensityMap = null;
      this.specularColor = new Color(1, 1, 1);
      this.specularColorMap = null;
      this._sheen = 0;
      this._clearcoat = 0;
      this._iridescence = 0;
      this._transmission = 0;
      this.setValues(parameters);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(value) {
      if (this._sheen > 0 !== value > 0) {
        this.version++;
      }
      this._sheen = value;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(value) {
      if (this._clearcoat > 0 !== value > 0) {
        this.version++;
      }
      this._clearcoat = value;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(value) {
      if (this._iridescence > 0 !== value > 0) {
        this.version++;
      }
      this._iridescence = value;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(value) {
      if (this._transmission > 0 !== value > 0) {
        this.version++;
      }
      this._transmission = value;
    }
    copy(source) {
      super.copy(source);
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.ior = source.ior;
      this.iridescence = source.iridescence;
      this.iridescenceMap = source.iridescenceMap;
      this.iridescenceIOR = source.iridescenceIOR;
      this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
      this.iridescenceThicknessMap = source.iridescenceThicknessMap;
      this.sheen = source.sheen;
      this.sheenColor.copy(source.sheenColor);
      this.sheenColorMap = source.sheenColorMap;
      this.sheenRoughness = source.sheenRoughness;
      this.sheenRoughnessMap = source.sheenRoughnessMap;
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      this.thickness = source.thickness;
      this.thicknessMap = source.thicknessMap;
      this.attenuationDistance = source.attenuationDistance;
      this.attenuationColor.copy(source.attenuationColor);
      this.specularIntensity = source.specularIntensity;
      this.specularIntensityMap = source.specularIntensityMap;
      this.specularColor.copy(source.specularColor);
      this.specularColorMap = source.specularColorMap;
      return this;
    }
  };
  var MeshPhongMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshPhongMaterial = true;
      this.type = "MeshPhongMaterial";
      this.color = new Color(16777215);
      this.specular = new Color(1118481);
      this.shininess = 30;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.flatShading = false;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  };
  var MeshToonMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshToonMaterial = true;
      this.defines = { "TOON": "" };
      this.type = "MeshToonMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.gradientMap = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  };
  var MeshNormalMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshNormalMaterial = true;
      this.type = "MeshNormalMaterial";
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  var MeshLambertMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshLambertMaterial = true;
      this.type = "MeshLambertMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  };
  var MeshMatcapMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshMatcapMaterial = true;
      this.defines = { "MATCAP": "" };
      this.type = "MeshMatcapMaterial";
      this.color = new Color(16777215);
      this.matcap = null;
      this.map = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.flatShading = false;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "MATCAP": "" };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  };
  var LineDashedMaterial = class extends LineBasicMaterial {
    constructor(parameters) {
      super();
      this.isLineDashedMaterial = true;
      this.type = "LineDashedMaterial";
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    }
  };
  var materialLib = {
    ShadowMaterial,
    SpriteMaterial,
    RawShaderMaterial,
    ShaderMaterial,
    PointsMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshPhongMaterial,
    MeshToonMaterial,
    MeshNormalMaterial,
    MeshLambertMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshBasicMaterial,
    MeshMatcapMaterial,
    LineDashedMaterial,
    LineBasicMaterial,
    Material
  };
  Material.fromType = function(type) {
    return new materialLib[type]();
  };
  var AnimationUtils = {
    arraySlice: function(array, from, to) {
      if (AnimationUtils.isTypedArray(array)) {
        return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
      }
      return array.slice(from, to);
    },
    convertArray: function(array, type, forceClone) {
      if (!array || !forceClone && array.constructor === type)
        return array;
      if (typeof type.BYTES_PER_ELEMENT === "number") {
        return new type(array);
      }
      return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
      return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function(times) {
      function compareTime(i, j) {
        return times[i] - times[j];
      }
      const n = times.length;
      const result = new Array(n);
      for (let i = 0; i !== n; ++i)
        result[i] = i;
      result.sort(compareTime);
      return result;
    },
    sortedArray: function(values, stride, order) {
      const nValues = values.length;
      const result = new values.constructor(nValues);
      for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
        const srcOffset = order[i] * stride;
        for (let j = 0; j !== stride; ++j) {
          result[dstOffset++] = values[srcOffset + j];
        }
      }
      return result;
    },
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
      let i = 1, key = jsonKeys[0];
      while (key !== void 0 && key[valuePropertyName] === void 0) {
        key = jsonKeys[i++];
      }
      if (key === void 0)
        return;
      let value = key[valuePropertyName];
      if (value === void 0)
        return;
      if (Array.isArray(value)) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push.apply(values, value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else if (value.toArray !== void 0) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            value.toArray(values, values.length);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push(value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      }
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
      const clip = sourceClip.clone();
      clip.name = name;
      const tracks = [];
      for (let i = 0; i < clip.tracks.length; ++i) {
        const track = clip.tracks[i];
        const valueSize = track.getValueSize();
        const times = [];
        const values = [];
        for (let j = 0; j < track.times.length; ++j) {
          const frame = track.times[j] * fps;
          if (frame < startFrame || frame >= endFrame)
            continue;
          times.push(track.times[j]);
          for (let k = 0; k < valueSize; ++k) {
            values.push(track.values[j * valueSize + k]);
          }
        }
        if (times.length === 0)
          continue;
        track.times = AnimationUtils.convertArray(times, track.times.constructor);
        track.values = AnimationUtils.convertArray(values, track.values.constructor);
        tracks.push(track);
      }
      clip.tracks = tracks;
      let minStartTime = Infinity;
      for (let i = 0; i < clip.tracks.length; ++i) {
        if (minStartTime > clip.tracks[i].times[0]) {
          minStartTime = clip.tracks[i].times[0];
        }
      }
      for (let i = 0; i < clip.tracks.length; ++i) {
        clip.tracks[i].shift(-1 * minStartTime);
      }
      clip.resetDuration();
      return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
      if (fps <= 0)
        fps = 30;
      const numTracks = referenceClip.tracks.length;
      const referenceTime = referenceFrame / fps;
      for (let i = 0; i < numTracks; ++i) {
        const referenceTrack = referenceClip.tracks[i];
        const referenceTrackType = referenceTrack.ValueTypeName;
        if (referenceTrackType === "bool" || referenceTrackType === "string")
          continue;
        const targetTrack = targetClip.tracks.find(function(track) {
          return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
        });
        if (targetTrack === void 0)
          continue;
        let referenceOffset = 0;
        const referenceValueSize = referenceTrack.getValueSize();
        if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          referenceOffset = referenceValueSize / 3;
        }
        let targetOffset = 0;
        const targetValueSize = targetTrack.getValueSize();
        if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          targetOffset = targetValueSize / 3;
        }
        const lastIndex = referenceTrack.times.length - 1;
        let referenceValue;
        if (referenceTime <= referenceTrack.times[0]) {
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else if (referenceTime >= referenceTrack.times[lastIndex]) {
          const startIndex = lastIndex * referenceValueSize + referenceOffset;
          const endIndex = startIndex + referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else {
          const interpolant = referenceTrack.createInterpolant();
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          interpolant.evaluate(referenceTime);
          referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
        }
        if (referenceTrackType === "quaternion") {
          const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
          referenceQuat.toArray(referenceValue);
        }
        const numTimes = targetTrack.times.length;
        for (let j = 0; j < numTimes; ++j) {
          const valueStart = j * targetValueSize + targetOffset;
          if (referenceTrackType === "quaternion") {
            Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
          } else {
            const valueEnd = targetValueSize - targetOffset * 2;
            for (let k = 0; k < valueEnd; ++k) {
              targetTrack.values[valueStart + k] -= referenceValue[k];
            }
          }
        }
      }
      targetClip.blendMode = AdditiveAnimationBlendMode;
      return targetClip;
    }
  };
  var Interpolant = class {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
      this.settings = null;
      this.DefaultSettings_ = {};
    }
    evaluate(t) {
      const pp = this.parameterPositions;
      let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          let right;
          linear_scan: {
            forward_scan:
              if (!(t < t1)) {
                for (let giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t < t0)
                      break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.copySampleValue_(i1 - 1);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
            if (!(t >= t0)) {
              const t1global = pp[1];
              if (t < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (let giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.copySampleValue_(0);
                }
                if (i1 === giveUpAt)
                  break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            const mid = i1 + right >>> 1;
            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.copySampleValue_(0);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.copySampleValue_(i1 - 1);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t, t1);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }
      return result;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  };
  var CubicInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;
      this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
    }
    intervalChanged_(i1, t0, t1) {
      const pp = this.parameterPositions;
      let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
      const sP = -wP * ppp + 2 * wP * pp - wP * p;
      const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      const sN = wN * ppp - wN * pp;
      for (let i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }
      return result;
    }
  };
  var LinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }
      return result;
    }
  };
  var DiscreteInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  };
  var KeyframeTrack = class {
    constructor(name, times, values, interpolation) {
      if (name === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (times === void 0 || times.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
      this.name = name;
      this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
      this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    static toJSON(track) {
      const trackType = track.constructor;
      let json;
      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        json = {
          "name": track.name,
          "times": AnimationUtils.convertArray(track.times, Array),
          "values": AnimationUtils.convertArray(track.values, Array)
        };
        const interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
      let factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(timeOffset) {
      if (timeOffset !== 0) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }
      return this;
    }
    scale(timeScale) {
      if (timeScale !== 1) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }
      return this;
    }
    trim(startTime, endTime) {
      const times = this.times, nKeys = times.length;
      let from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        const stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }
      return this;
    }
    validate() {
      let valid = true;
      const valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      const times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      let prevTime = null;
      for (let i = 0; i !== nKeys; i++) {
        const currTime = times[i];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (AnimationUtils.isTypedArray(values)) {
          for (let i = 0, n = values.length; i !== n; ++i) {
            const value = values[i];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    }
    optimize() {
      const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
      let writeIndex = 1;
      for (let i = 1; i < lastIndex; ++i) {
        let keep = false;
        const time = times[i];
        const timeNext = times[i + 1];
        if (time !== timeNext && (i !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
            for (let j = 0; j !== stride; ++j) {
              const value = values[offset + j];
              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            const readOffset = i * stride, writeOffset = writeIndex * stride;
            for (let j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
          values[writeOffset + j] = values[readOffset + j];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    }
    clone() {
      const times = AnimationUtils.arraySlice(this.times, 0);
      const values = AnimationUtils.arraySlice(this.values, 0);
      const TypedKeyframeTrack = this.constructor;
      const track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  };
  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  var BooleanKeyframeTrack = class extends KeyframeTrack {
  };
  BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var ColorKeyframeTrack = class extends KeyframeTrack {
  };
  ColorKeyframeTrack.prototype.ValueTypeName = "color";
  var NumberKeyframeTrack = class extends KeyframeTrack {
  };
  NumberKeyframeTrack.prototype.ValueTypeName = "number";
  var QuaternionLinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
      let offset = i1 * stride;
      for (let end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  };
  var QuaternionKeyframeTrack = class extends KeyframeTrack {
    InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  };
  QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
  QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var StringKeyframeTrack = class extends KeyframeTrack {
  };
  StringKeyframeTrack.prototype.ValueTypeName = "string";
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var VectorKeyframeTrack = class extends KeyframeTrack {
  };
  VectorKeyframeTrack.prototype.ValueTypeName = "vector";
  var LoadingManager = class {
    constructor(onLoad, onProgress, onError) {
      const scope = this;
      let isLoading = false;
      let itemsLoaded = 0;
      let itemsTotal = 0;
      let urlModifier = void 0;
      const handlers = [];
      this.onStart = void 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== void 0) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== void 0) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== void 0) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== void 0) {
          scope.onError(url);
        }
      };
      this.resolveURL = function(url) {
        if (urlModifier) {
          return urlModifier(url);
        }
        return url;
      };
      this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
      };
      this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
      };
      this.removeHandler = function(regex) {
        const index = handlers.indexOf(regex);
        if (index !== -1) {
          handlers.splice(index, 2);
        }
        return this;
      };
      this.getHandler = function(file) {
        for (let i = 0, l = handlers.length; i < l; i += 2) {
          const regex = handlers[i];
          const loader = handlers[i + 1];
          if (regex.global)
            regex.lastIndex = 0;
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      };
    }
  };
  var DefaultLoadingManager = new LoadingManager();
  var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
  var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
  var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
  var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
  var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
  var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
  var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
  var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
  var _supportedObjectNames = ["material", "materials", "bones"];
  var Composite = class {
    constructor(targetGroup, path, optionalParsedPath) {
      const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    getValue(array, offset) {
      this.bind();
      const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0)
        binding.getValue(array, offset);
    }
    setValue(array, offset) {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    }
    bind() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    }
    unbind() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  };
  var PropertyBinding = class {
    constructor(rootNode, path, parsedPath) {
      this.path = path;
      this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
      this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
      this.rootNode = rootNode;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    }
    static sanitizeNodeName(name) {
      return name.replace(/\s/g, "_").replace(_reservedRe, "");
    }
    static parseTrackName(trackName) {
      const matches = _trackRe.exec(trackName);
      if (matches === null) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      const results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
      };
      const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        const objectName = results.nodeName.substring(lastDot + 1);
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    }
    static findNode(root, nodeName) {
      if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        const bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        const searchNodeSubtree = function(children) {
          for (let i = 0; i < children.length; i++) {
            const childNode = children[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            const result = searchNodeSubtree(childNode.children);
            if (result)
              return result;
          }
          return null;
        };
        const subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(buffer, offset) {
      buffer[offset] = this.targetObject[this.propertyName];
    }
    _getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    }
    _getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
    _setValue_direct(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
    }
    _setValue_array_setNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    }
    _setValue_unbound(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    }
    bind() {
      let targetObject = this.node;
      const parsedPath = this.parsedPath;
      const objectName = parsedPath.objectName;
      const propertyName = parsedPath.propertyName;
      let propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        return;
      }
      if (objectName) {
        let objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (let i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      const nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        const nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      let versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== void 0) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      let bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  };
  PropertyBinding.Composite = Composite;
  PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  PropertyBinding.prototype.GetterByBindingType = [
    PropertyBinding.prototype._getValue_direct,
    PropertyBinding.prototype._getValue_array,
    PropertyBinding.prototype._getValue_arrayElement,
    PropertyBinding.prototype._getValue_toArray
  ];
  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
    [
      PropertyBinding.prototype._setValue_direct,
      PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
      PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      PropertyBinding.prototype._setValue_array,
      PropertyBinding.prototype._setValue_array_setNeedsUpdate,
      PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      PropertyBinding.prototype._setValue_arrayElement,
      PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
      PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      PropertyBinding.prototype._setValue_fromArray,
      PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
      PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  var Raycaster = class {
    constructor(origin, direction, near = 0, far = Infinity) {
      this.ray = new Ray(origin, direction);
      this.near = near;
      this.far = far;
      this.camera = null;
      this.layers = new Layers();
      this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {}
      };
    }
    set(origin, direction) {
      this.ray.set(origin, direction);
    }
    setFromCamera(coords, camera) {
      if (camera.isPerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        this.camera = camera;
      } else if (camera.isOrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        this.camera = camera;
      } else {
        console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
      }
    }
    intersectObject(object, recursive = true, intersects = []) {
      intersectObject(object, this, intersects, recursive);
      intersects.sort(ascSort);
      return intersects;
    }
    intersectObjects(objects, recursive = true, intersects = []) {
      for (let i = 0, l = objects.length; i < l; i++) {
        intersectObject(objects[i], this, intersects, recursive);
      }
      intersects.sort(ascSort);
      return intersects;
    }
  };
  function ascSort(a, b) {
    return a.distance - b.distance;
  }
  function intersectObject(object, raycaster, intersects, recursive) {
    if (object.layers.test(raycaster.layers)) {
      object.raycast(raycaster, intersects);
    }
    if (recursive === true) {
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        intersectObject(children[i], raycaster, intersects, true);
      }
    }
  }
  var Spherical = class {
    constructor(radius = 1, phi = 0, theta = 0) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }
    makeSafe() {
      const EPS = 1e-6;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
    setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(clamp(y / this.radius, -1, 1));
      }
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _buffer = new ArrayBuffer(4);
  var _floatView = new Float32Array(_buffer);
  var _uint32View = new Uint32Array(_buffer);
  var _baseTable = new Uint32Array(512);
  var _shiftTable = new Uint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      _baseTable[i] = 0;
      _baseTable[i | 256] = 32768;
      _shiftTable[i] = 24;
      _shiftTable[i | 256] = 24;
    } else if (e < -14) {
      _baseTable[i] = 1024 >> -e - 14;
      _baseTable[i | 256] = 1024 >> -e - 14 | 32768;
      _shiftTable[i] = -e - 1;
      _shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      _baseTable[i] = e + 15 << 10;
      _baseTable[i | 256] = e + 15 << 10 | 32768;
      _shiftTable[i] = 13;
      _shiftTable[i | 256] = 13;
    } else if (e < 128) {
      _baseTable[i] = 31744;
      _baseTable[i | 256] = 64512;
      _shiftTable[i] = 24;
      _shiftTable[i | 256] = 24;
    } else {
      _baseTable[i] = 31744;
      _baseTable[i | 256] = 64512;
      _shiftTable[i] = 13;
      _shiftTable[i | 256] = 13;
    }
  }
  var _mantissaTable = new Uint32Array(2048);
  var _exponentTable = new Uint32Array(64);
  var _offsetTable = new Uint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= ~8388608;
    e += 947912704;
    _mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    _mantissaTable[i] = 939524096 + (i - 1024 << 13);
  }
  for (let i = 1; i < 31; ++i) {
    _exponentTable[i] = i << 23;
  }
  _exponentTable[31] = 1199570944;
  _exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    _exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  _exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      _offsetTable[i] = 1024;
    }
  }
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }

  // node_modules/three/examples/jsm/controls/OrbitControls.js
  var _changeEvent = { type: "change" };
  var _startEvent = { type: "start" };
  var _endEvent = { type: "end" };
  var OrbitControls = class extends EventDispatcher {
    constructor(object, domElement) {
      super();
      if (domElement === void 0)
        console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
      if (domElement === document)
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      this.object = object;
      this.domElement = domElement;
      this.domElement.style.touchAction = "none";
      this.enabled = true;
      this.target = new Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minZoom = 0;
      this.maxZoom = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.minAzimuthAngle = -Infinity;
      this.maxAzimuthAngle = Infinity;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.enableZoom = true;
      this.zoomSpeed = 1;
      this.enableRotate = true;
      this.rotateSpeed = 1;
      this.enablePan = true;
      this.panSpeed = 1;
      this.screenSpacePanning = true;
      this.keyPanSpeed = 7;
      this.autoRotate = false;
      this.autoRotateSpeed = 2;
      this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
      this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
      this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.zoom0 = this.object.zoom;
      this._domElementKeyEvents = null;
      this.getPolarAngle = function() {
        return spherical.phi;
      };
      this.getAzimuthalAngle = function() {
        return spherical.theta;
      };
      this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      };
      this.listenToKeyEvents = function(domElement2) {
        domElement2.addEventListener("keydown", onKeyDown);
        this._domElementKeyEvents = domElement2;
      };
      this.saveState = function() {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
      };
      this.reset = function() {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(_changeEvent);
        scope.update();
        state = STATE.NONE;
      };
      this.update = function() {
        const offset = new Vector3();
        const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
        const quatInverse = quat.clone().invert();
        const lastPosition = new Vector3();
        const lastQuaternion = new Quaternion();
        const twoPI = 2 * Math.PI;
        return function update() {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state === STATE.NONE) {
            rotateLeft(getAutoRotationAngle());
          }
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          let min = scope.minAzimuthAngle;
          let max = scope.maxAzimuthAngle;
          if (isFinite(min) && isFinite(max)) {
            if (min < -Math.PI)
              min += twoPI;
            else if (min > Math.PI)
              min -= twoPI;
            if (max < -Math.PI)
              max += twoPI;
            else if (max > Math.PI)
              max -= twoPI;
            if (min <= max) {
              spherical.theta = Math.max(min, Math.min(max, spherical.theta));
            } else {
              spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
            }
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping === true) {
            scope.target.addScaledVector(panOffset, scope.dampingFactor);
          } else {
            scope.target.add(panOffset);
          }
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping === true) {
            sphericalDelta.theta *= 1 - scope.dampingFactor;
            sphericalDelta.phi *= 1 - scope.dampingFactor;
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
            scope.dispatchEvent(_changeEvent);
            lastPosition.copy(scope.object.position);
            lastQuaternion.copy(scope.object.quaternion);
            zoomChanged = false;
            return true;
          }
          return false;
        };
      }();
      this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu);
        scope.domElement.removeEventListener("pointerdown", onPointerDown);
        scope.domElement.removeEventListener("pointercancel", onPointerCancel);
        scope.domElement.removeEventListener("wheel", onMouseWheel);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
        if (scope._domElementKeyEvents !== null) {
          scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        }
      };
      const scope = this;
      const STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let state = STATE.NONE;
      const EPS = 1e-6;
      const spherical = new Spherical();
      const sphericalDelta = new Spherical();
      let scale = 1;
      const panOffset = new Vector3();
      let zoomChanged = false;
      const rotateStart = new Vector2();
      const rotateEnd = new Vector2();
      const rotateDelta = new Vector2();
      const panStart = new Vector2();
      const panEnd = new Vector2();
      const panDelta = new Vector2();
      const dollyStart = new Vector2();
      const dollyEnd = new Vector2();
      const dollyDelta = new Vector2();
      const pointers = [];
      const pointerPositions = {};
      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }
      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }
      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }
      const panLeft = function() {
        const v = new Vector3();
        return function panLeft2(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.multiplyScalar(-distance);
          panOffset.add(v);
        };
      }();
      const panUp = function() {
        const v = new Vector3();
        return function panUp2(distance, objectMatrix) {
          if (scope.screenSpacePanning === true) {
            v.setFromMatrixColumn(objectMatrix, 1);
          } else {
            v.setFromMatrixColumn(objectMatrix, 0);
            v.crossVectors(scope.object.up, v);
          }
          v.multiplyScalar(distance);
          panOffset.add(v);
        };
      }();
      const pan = function() {
        const offset = new Vector3();
        return function pan2(deltaX, deltaY) {
          const element = scope.domElement;
          if (scope.object.isPerspectiveCamera) {
            const position = scope.object.position;
            offset.copy(position).sub(scope.target);
            let targetDistance = offset.length();
            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
            panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
            panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
          } else if (scope.object.isOrthographicCamera) {
            panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
            scope.enablePan = false;
          }
        };
      }();
      function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale /= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale *= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
      }
      function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
      }
      function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y > 0) {
          dollyOut(getZoomScale());
        } else if (dollyDelta.y < 0) {
          dollyIn(getZoomScale());
        }
        dollyStart.copy(dollyEnd);
        scope.update();
      }
      function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
      }
      function handleMouseWheel(event) {
        if (event.deltaY < 0) {
          dollyIn(getZoomScale());
        } else if (event.deltaY > 0) {
          dollyOut(getZoomScale());
        }
        scope.update();
      }
      function handleKeyDown(event) {
        let needsUpdate = false;
        switch (event.code) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
        }
        if (needsUpdate) {
          event.preventDefault();
          scope.update();
        }
      }
      function handleTouchStartRotate() {
        if (pointers.length === 1) {
          rotateStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          rotateStart.set(x, y);
        }
      }
      function handleTouchStartPan() {
        if (pointers.length === 1) {
          panStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          panStart.set(x, y);
        }
      }
      function handleTouchStartDolly() {
        const dx = pointers[0].pageX - pointers[1].pageX;
        const dy = pointers[0].pageY - pointers[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
      }
      function handleTouchStartDollyPan() {
        if (scope.enableZoom)
          handleTouchStartDolly();
        if (scope.enablePan)
          handleTouchStartPan();
      }
      function handleTouchStartDollyRotate() {
        if (scope.enableZoom)
          handleTouchStartDolly();
        if (scope.enableRotate)
          handleTouchStartRotate();
      }
      function handleTouchMoveRotate(event) {
        if (pointers.length == 1) {
          rotateEnd.set(event.pageX, event.pageY);
        } else {
          const position = getSecondPointerPosition(event);
          const x = 0.5 * (event.pageX + position.x);
          const y = 0.5 * (event.pageY + position.y);
          rotateEnd.set(x, y);
        }
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
      }
      function handleTouchMovePan(event) {
        if (pointers.length === 1) {
          panEnd.set(event.pageX, event.pageY);
        } else {
          const position = getSecondPointerPosition(event);
          const x = 0.5 * (event.pageX + position.x);
          const y = 0.5 * (event.pageY + position.y);
          panEnd.set(x, y);
        }
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
      }
      function handleTouchMoveDolly(event) {
        const position = getSecondPointerPosition(event);
        const dx = event.pageX - position.x;
        const dy = event.pageY - position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyOut(dollyDelta.y);
        dollyStart.copy(dollyEnd);
      }
      function handleTouchMoveDollyPan(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enablePan)
          handleTouchMovePan(event);
      }
      function handleTouchMoveDollyRotate(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enableRotate)
          handleTouchMoveRotate(event);
      }
      function onPointerDown(event) {
        if (scope.enabled === false)
          return;
        if (pointers.length === 0) {
          scope.domElement.setPointerCapture(event.pointerId);
          scope.domElement.addEventListener("pointermove", onPointerMove);
          scope.domElement.addEventListener("pointerup", onPointerUp);
        }
        addPointer(event);
        if (event.pointerType === "touch") {
          onTouchStart(event);
        } else {
          onMouseDown(event);
        }
      }
      function onPointerMove(event) {
        if (scope.enabled === false)
          return;
        if (event.pointerType === "touch") {
          onTouchMove(event);
        } else {
          onMouseMove(event);
        }
      }
      function onPointerUp(event) {
        removePointer(event);
        if (pointers.length === 0) {
          scope.domElement.releasePointerCapture(event.pointerId);
          scope.domElement.removeEventListener("pointermove", onPointerMove);
          scope.domElement.removeEventListener("pointerup", onPointerUp);
        }
        scope.dispatchEvent(_endEvent);
        state = STATE.NONE;
      }
      function onPointerCancel(event) {
        removePointer(event);
      }
      function onMouseDown(event) {
        let mouseAction;
        switch (event.button) {
          case 0:
            mouseAction = scope.mouseButtons.LEFT;
            break;
          case 1:
            mouseAction = scope.mouseButtons.MIDDLE;
            break;
          case 2:
            mouseAction = scope.mouseButtons.RIGHT;
            break;
          default:
            mouseAction = -1;
        }
        switch (mouseAction) {
          case MOUSE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseDownDolly(event);
            state = STATE.DOLLY;
            break;
          case MOUSE.ROTATE:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            } else {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            }
            break;
          case MOUSE.PAN:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            } else {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onMouseMove(event) {
        if (scope.enabled === false)
          return;
        switch (state) {
          case STATE.ROTATE:
            if (scope.enableRotate === false)
              return;
            handleMouseMoveRotate(event);
            break;
          case STATE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseMoveDolly(event);
            break;
          case STATE.PAN:
            if (scope.enablePan === false)
              return;
            handleMouseMovePan(event);
            break;
        }
      }
      function onMouseWheel(event) {
        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
          return;
        event.preventDefault();
        scope.dispatchEvent(_startEvent);
        handleMouseWheel(event);
        scope.dispatchEvent(_endEvent);
      }
      function onKeyDown(event) {
        if (scope.enabled === false || scope.enablePan === false)
          return;
        handleKeyDown(event);
      }
      function onTouchStart(event) {
        trackPointer(event);
        switch (pointers.length) {
          case 1:
            switch (scope.touches.ONE) {
              case TOUCH.ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleTouchStartRotate();
                state = STATE.TOUCH_ROTATE;
                break;
              case TOUCH.PAN:
                if (scope.enablePan === false)
                  return;
                handleTouchStartPan();
                state = STATE.TOUCH_PAN;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          case 2:
            switch (scope.touches.TWO) {
              case TOUCH.DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false)
                  return;
                handleTouchStartDollyPan();
                state = STATE.TOUCH_DOLLY_PAN;
                break;
              case TOUCH.DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false)
                  return;
                handleTouchStartDollyRotate();
                state = STATE.TOUCH_DOLLY_ROTATE;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onTouchMove(event) {
        trackPointer(event);
        switch (state) {
          case STATE.TOUCH_ROTATE:
            if (scope.enableRotate === false)
              return;
            handleTouchMoveRotate(event);
            scope.update();
            break;
          case STATE.TOUCH_PAN:
            if (scope.enablePan === false)
              return;
            handleTouchMovePan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false)
              return;
            handleTouchMoveDollyPan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false)
              return;
            handleTouchMoveDollyRotate(event);
            scope.update();
            break;
          default:
            state = STATE.NONE;
        }
      }
      function onContextMenu(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
      }
      function addPointer(event) {
        pointers.push(event);
      }
      function removePointer(event) {
        delete pointerPositions[event.pointerId];
        for (let i = 0; i < pointers.length; i++) {
          if (pointers[i].pointerId == event.pointerId) {
            pointers.splice(i, 1);
            return;
          }
        }
      }
      function trackPointer(event) {
        let position = pointerPositions[event.pointerId];
        if (position === void 0) {
          position = new Vector2();
          pointerPositions[event.pointerId] = position;
        }
        position.set(event.pageX, event.pageY);
      }
      function getSecondPointerPosition(event) {
        const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
        return pointerPositions[pointer.pointerId];
      }
      scope.domElement.addEventListener("contextmenu", onContextMenu);
      scope.domElement.addEventListener("pointerdown", onPointerDown);
      scope.domElement.addEventListener("pointercancel", onPointerCancel);
      scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this.update();
    }
  };

  // webapp/index.js
  var { locations, gfx } = require_map();
  var asciiRenderTarget = (() => {
    const palletize = (n) => {
      switch (n) {
        case 0:
          return " ";
        case 1:
          return ":";
        case 2:
          return "?";
        case 3:
          return "X";
      }
    };
    return (iBuffer, iWidth, iHeight) => {
      let out = "";
      for (let h = 0; h < iHeight * 4 * 8; h++) {
        for (let w = 0; w < iWidth * 4 * 8; w++) {
          out += palletize(iBuffer[h * iWidth * 4 * 8 + w]);
        }
        out += "\n";
      }
      return out;
    };
  })();
  var canvasRenderTarget = (canvas) => {
    const palletize = (n) => {
      switch (n) {
        case 0:
          return [224, 248, 208, 255];
        case 1:
          return [136, 192, 112, 255];
        case 2:
          return [52, 104, 86, 255];
        case 3:
          return [8, 24, 32, 255];
      }
    };
    return (iBuffer, iWidth, iHeight) => {
      let cvs = document.createElement("canvas");
      let ctx = cvs.getContext("2d");
      cvs.width = iWidth;
      cvs.height = iHeight;
      let ctx_data = ctx.createImageData(iWidth * 32, iHeight * 32);
      let outCursor = 0;
      for (let h = 0; h < iHeight * 4 * 8; h++) {
        for (let w = 0; w < iWidth * 4 * 8; w++) {
          for (let c = 0; c < 4; c++) {
            let pixel = palletize(iBuffer[h * iWidth * 4 * 8 + w]);
            ctx_data.data[outCursor] = pixel[c];
            outCursor++;
          }
        }
      }
      canvas.width = iWidth * 32;
      canvas.height = iHeight * 32;
      return ctx_data;
    };
  };
  var textureRenderTarget = (parent) => {
    const palletize = (n) => {
      switch (n) {
        case 0:
          return [224, 248, 208, 255];
        case 1:
          return [136, 192, 112, 255];
        case 2:
          return [52, 104, 86, 255];
        case 3:
          return [8, 24, 32, 255];
      }
    };
    return (iBuffer, iWidth, iHeight, location) => {
      const data = new Uint8Array(iWidth * iHeight * 32 * 32 * 4);
      let cursor = 0;
      for (let h = 0; h < iHeight * 4 * 8; h++) {
        for (let w = 0; w < iWidth * 4 * 8; w++) {
          let pixel = palletize(iBuffer[h * iWidth * 4 * 8 + w]);
          for (let c = 0; c < 4; c++) {
            data[cursor] = pixel[c];
            cursor++;
          }
        }
      }
      const texture = new DataTexture(data, iWidth * 32, iHeight * 32);
      texture.flipY = true;
      texture.needsUpdate = true;
      const geometry = new PlaneGeometry(iWidth, iHeight);
      const material = new MeshBasicMaterial({ map: texture });
      const plane = new Mesh(geometry, material);
      plane.name = location.Name;
      return plane;
    };
  };
  var renderer = ((gfx2) => (renderTarget) => (location) => {
    set = gfx2[location.blockset.toLowerCase()];
    let blocks = [];
    location.mapData.forEach((idx) => blocks.push(set.blocks[idx]));
    let buf = typeof window === "undefined" ? Buffer.alloc(location.width * location.height * 4 * 4 * 8 * 8) : new Uint8Array(location.width * location.height * 4 * 4 * 8 * 8);
    let writeCursor = 0;
    for (let h = 0; h < location.height; h++) {
      for (let blockH = 0; blockH < 4; blockH++) {
        for (let tileH = 0; tileH < 8; tileH++) {
          for (let w = 0; w < location.width; w++) {
            let block = blocks[h * location.width + w];
            if (block === void 0)
              break;
            for (let blockW = 0; blockW < 4; blockW++) {
              let tileOffset = block[blockH * 4 + blockW] * 8 * 2;
              for (let tileRowByte = 0; tileRowByte < 2; tileRowByte++) {
                for (let tileBitshift = 6; tileBitshift >= 0; tileBitshift -= 2) {
                  buf[writeCursor] = set.tiles[tileOffset + tileH * 2 + tileRowByte] >> tileBitshift & 3;
                  writeCursor++;
                }
              }
            }
          }
        }
      }
    }
    return renderTarget(buf, location.width, location.height, location);
  })(gfx);
  var locationSelector = (locations2) => (parent) => (changeCb) => {
    const select = document.createElement("select");
    locations2.forEach((l) => {
      const opt = document.createElement("option");
      opt.value = l.CONSTANT_NAME;
      opt.innerText = l.Name;
      select.appendChild(opt);
    });
    select.addEventListener("change", (ev) => changeCb(locations2.find((l) => l.CONSTANT_NAME == ev.target.value)));
    parent.appendChild(select);
  };
  window.addEventListener("load", () => {
    document.querySelectorAll("[data-poke-map-ascii]").forEach((el) => {
      const renderLocation = renderer(asciiRenderTarget);
      let out = document.createElement("pre");
      out.classList.add("ascii");
      out.innerText = renderLocation(locations[0]);
      locationSelector(locations)(el)((l) => out.innerText = renderLocation(l));
      el.appendChild(out);
    });
    document.querySelectorAll("[data-poke-map-canvas]").forEach((el) => {
      let out = document.createElement("canvas");
      const renderLocation = renderer(canvasRenderTarget(out));
      let ctx = out.getContext("2d");
      ctx.putImageData(renderLocation(locations[0]), 0, 0);
      locationSelector(locations)(el)((l) => ctx.putImageData(renderLocation(l), 0, 0));
      el.appendChild(out);
    });
    document.querySelectorAll("[data-poke-map-three]").forEach((el) => {
      const pointer = new Vector2();
      const raycaster = new Raycaster();
      let mousing = false;
      let zCutoff = 21;
      let warpsOn = false;
      el.addEventListener("mouseenter", () => mousing = true);
      el.addEventListener("mouseleave", () => mousing = false);
      const hudEl = document.createElement("div");
      hudEl.classList.add("hud");
      const pickedLabel = document.createElement("span");
      hudEl.appendChild(pickedLabel);
      el.appendChild(hudEl);
      const renderLocation = renderer(textureRenderTarget(el));
      const planes = locations.map(renderLocation);
      const r = new WebGLRenderer();
      r.setClearColor(new Color(14743760));
      r.autoClear = true;
      r.setSize(el.clientWidth, el.clientWidth);
      el.appendChild(r.domElement);
      const scene = new Scene();
      const camera = new PerspectiveCamera(45, 1, 1, 1e4);
      camera.position.x = 50;
      camera.position.y = 40;
      camera.position.z = 275;
      const controls = new OrbitControls(camera, r.domElement);
      controls.mouseButtons = {
        LEFT: MOUSE.PAN,
        MIDDLE: MOUSE.DOLLY,
        RIGHT: MOUSE.ROTATE
      };
      controls.target = new Vector3(camera.position.x, camera.position.y, 0);
      controls.update();
      function animate() {
        if (mousing) {
          raycaster.setFromCamera(pointer, camera);
          for (let i = 0, l = scene.children.length; i < l; i++) {
            scene.children[i].material.color.set(16777215);
          }
          const intersects = raycaster.intersectObjects(scene.children);
          if (intersects.length === 0) {
            hudEl.innerText = "";
          } else {
            intersects.sort((a, b) => a.object.position.z < b.object.position.z);
            for (let i = 0; i < intersects.length; i++) {
              if (intersects[i].object.visible) {
                intersects[i].object.material.color.set(8962160);
                hudEl.innerText = intersects[i].object.name;
                break;
              }
            }
          }
        } else {
          hudEl.innerText = "";
        }
        r.render(scene, camera);
      }
      controls.addEventListener("change", animate);
      window.addEventListener("pointermove", (ev) => {
        pointer.x = ev.clientX / el.clientWidth * 2 - 1;
        pointer.y = -(ev.clientY / el.clientWidth) * 2 + 1;
        animate();
      });
      window.addEventListener("resize", animate);
      let toPosition = [[null, locations[0], null, 0]];
      let toPositionWarp = [];
      let positions = {};
      while (toPosition.length > 0) {
        let [src, l, dir, offset] = toPosition.pop();
        let x = 0;
        let y = 0;
        let z = 0;
        if (src) {
          switch (dir) {
            case "north":
              {
                y = positions[src.CONSTANT_NAME].y + (src.height + l.height) / 2;
                x = positions[src.CONSTANT_NAME].x - (src.width - l.width) / 2 + offset;
              }
              break;
            case "south":
              {
                y = positions[src.CONSTANT_NAME].y - (src.height + l.height) / 2;
                x = positions[src.CONSTANT_NAME].x - (src.width - l.width) / 2 + offset;
              }
              break;
            case "east":
              {
                y = positions[src.CONSTANT_NAME].y + (src.height - l.height) / 2 - offset;
                x = positions[src.CONSTANT_NAME].x + (src.width + l.width) / 2;
              }
              break;
            case "west":
              {
                y = positions[src.CONSTANT_NAME].y + (src.height - l.height) / 2 - offset;
                x = positions[src.CONSTANT_NAME].x - (src.width + l.width) / 2;
              }
              break;
          }
        }
        positions[l.CONSTANT_NAME] = { x, y, z };
        if (l.connections.north) {
          let d = l.connections.north.destination;
          let dest = locations.find((ll) => ll.CONSTANT_NAME == d);
          if (!positions[d]) {
            toPosition.push([l, dest, "north", l.connections.north.offset || 0]);
          }
        }
        if (l.connections.south) {
          let d = l.connections.south.destination;
          let dest = locations.find((ll) => ll.CONSTANT_NAME == d);
          if (!positions[d]) {
            toPosition.push([l, dest, "south", l.connections.south.offset || 0]);
          }
        }
        if (l.connections.east) {
          let d = l.connections.east.destination;
          let dest = locations.find((ll) => ll.CONSTANT_NAME == d);
          if (!positions[d]) {
            toPosition.push([l, dest, "east", l.connections.east.offset || 0]);
          }
        }
        if (l.connections.west) {
          let d = l.connections.west.destination;
          let dest = locations.find((ll) => ll.CONSTANT_NAME == d);
          if (!positions[d]) {
            toPosition.push([l, dest, "west", l.connections.west.offset || 0]);
          }
        }
        l.warps.forEach((w) => w.dest == "LAST_MAP" ? null : toPositionWarp.push([l, w]));
      }
      while (toPositionWarp.length > 0) {
        let [src, warp] = toPositionWarp.pop();
        let dest = locations.find((l) => l.CONSTANT_NAME == warp.dest);
        if (!dest) {
          continue;
        }
        dest.warps.forEach((w) => {
          if (w.dest == "LAST_MAP") {
            return;
          }
          if (w.dest == dest.CONSTANT_NAME) {
            return;
          }
          if (positions[w.dest]) {
            return;
          }
          toPositionWarp.push([dest, w]);
        });
        let nudge = { x: 0, y: 0, z: 1 };
        switch (dest.CONSTANT_NAME) {
          case "REDS_HOUSE_1F":
            {
              nudge.x = -1;
              nudge.y = 2;
            }
            break;
          case "BLUES_HOUSE":
            {
              nudge.x = 1;
              nudge.y = 2;
            }
            break;
          case "OAKS_LAB":
            {
              nudge.x = 1;
              nudge.y = -2;
            }
            break;
          case "ROUTE_22_GATE":
            {
              nudge.x = -2;
              nudge.y = 3;
            }
            break;
          case "ROUTE_2_GATE":
            {
              nudge.y = 7;
            }
            break;
          case "ROUTE_2_TRADE_HOUSE":
            {
              nudge.y = 7;
            }
            break;
          case "VIRIDIAN_FOREST":
            {
              nudge.y = 14;
              nudge.z = 0;
            }
            break;
          case "VIRIDIAN_FOREST_SOUTH_GATE":
            {
              nudge.x = -6;
              nudge.y = 5;
            }
            break;
          case "VIRIDIAN_FOREST_NORTH_GATE":
            {
              nudge.x = -12;
              nudge.y = 17;
            }
            break;
          case "VIRIDIAN_GYM":
            {
              nudge.x = 3;
              nudge.y = 4;
            }
            break;
          case "VIRIDIAN_NICKNAME_HOUSE":
            {
              nudge.x = -3;
              nudge.y = 5;
            }
            break;
          case "VIRIDIAN_SCHOOL_HOUSE":
            {
              nudge.x = -3;
              nudge.y = 4;
            }
            break;
          case "VIRIDIAN_MART":
            {
              nudge.y = 5.5;
            }
            break;
          case "VIRIDIAN_POKECENTER":
            {
              nudge.x = 1;
              nudge.y = 4;
            }
            break;
          case "INDIGO_PLATEAU_LOBBY":
            {
              nudge.x = 2;
              nudge.y = 2;
            }
            break;
          case "LORELEIS_ROOM":
            {
              nudge.y = 6;
              nudge.z = 0;
            }
            break;
          case "BRUNOS_ROOM":
            {
              nudge.y = 6;
              nudge.z = 0;
            }
            break;
          case "AGATHAS_ROOM":
            {
              nudge.y = 6;
              nudge.z = 0;
            }
            break;
          case "LANCES_ROOM":
            {
              nudge.x = -6;
              nudge.y = 1;
              nudge.z = -1;
            }
            break;
          case "CHAMPIONS_ROOM":
            {
              nudge.x = -0.75;
              nudge.y = 3.25;
              nudge.z = 0;
            }
            break;
          case "HALL_OF_FAME":
            {
              nudge.x = 1.5;
              nudge.y = 1;
              nudge.z = 0;
            }
            break;
          case "VICTORY_ROAD_1F":
            {
              nudge.x = 3;
              nudge.y = 18;
            }
            break;
          case "VICTORY_ROAD_2F":
            {
              nudge.x = 3;
              nudge.y = 18;
              nudge.z = 2;
            }
            break;
          case "DIGLETTS_CAVE_ROUTE_2":
            {
              nudge.y = 8;
              nudge.z = -1;
            }
            break;
          case "DIGLETTS_CAVE_ROUTE_11":
            {
              nudge.z = -1;
            }
            break;
          case "DIGLETTS_CAVE":
            {
              nudge.x = 50;
              nudge.y = -40;
              nudge.z = -1;
            }
            break;
          case "MUSEUM_1F":
            {
              nudge.x = -0.5;
              nudge.y = 5;
            }
            break;
          case "MUSEUM_2F":
            {
              nudge.x = -4;
              nudge.y = -1;
            }
            break;
          case "PEWTER_GYM":
            {
              nudge.x = -4;
              nudge.y = 2.5;
            }
            break;
          case "PEWTER_MART":
            {
              nudge.x = -3;
              nudge.y = 2.5;
            }
            break;
          case "PEWTER_NIDORAN_HOUSE":
            {
              nudge.y = 4;
            }
            break;
          case "PEWTER_POKECENTER":
            {
              nudge.x = 2.5;
              nudge.y = 2;
            }
            break;
          case "PEWTER_SPEECH_HOUSE":
            {
              nudge.x = -3;
              nudge.y = 4;
            }
            break;
        }
        if (positions[src.CONSTANT_NAME].z == 0) {
          var p = {
            x: positions[src.CONSTANT_NAME].x + warp.row / 2 - dest.width / 2 - src.width / 4 + nudge.x,
            y: positions[src.CONSTANT_NAME].y - warp.col / 2 + dest.height / 2 + src.height / 4 + nudge.y,
            z: positions[src.CONSTANT_NAME].z + 2 * nudge.z,
            w: true
          };
        } else {
          var p = {
            x: positions[src.CONSTANT_NAME].x + nudge.x,
            y: positions[src.CONSTANT_NAME].y + nudge.y,
            z: positions[src.CONSTANT_NAME].z + 2 * nudge.z,
            w: true
          };
        }
        positions[warp.dest] = p;
      }
      let warpPlanes = [];
      Object.entries(positions).forEach(([k, v]) => {
        let idx = locations.findIndex((l) => l.CONSTANT_NAME == k);
        let p2 = planes[idx];
        p2.position.x = v.x;
        p2.position.y = v.y;
        p2.position.z = v.z;
        p2.visible = v.z < zCutoff;
        if (v.w) {
          warpPlanes.push(p2);
          p2.visible = false;
        }
        scene.add(p2);
      });
      animate();
      document.addEventListener("keyup", (ev) => {
        switch (ev.key) {
          case "r":
            {
              camera.position.x = 50;
              camera.position.y = 40;
              camera.position.z = 275;
              controls.target = new Vector3(camera.position.x, camera.position.y, 0);
              controls.update();
              zCutoff = 21;
              planes.forEach((p2) => p2.visible = p2.position.z < zCutoff);
              animate();
            }
            break;
          case "=":
          case "+":
            {
              zCutoff = Math.min(zCutoff + 2, 21);
              planes.forEach((p2) => p2.visible = p2.position.z < zCutoff);
              animate();
            }
            break;
          case "-":
            {
              zCutoff = Math.max(zCutoff - 2, -3);
              planes.forEach((p2) => p2.visible = p2.position.z < zCutoff);
              animate();
            }
            break;
          case "w":
            {
              warpsOn = !warpsOn;
              warpsOn ? warpPlanes.forEach((p2) => p2.visible = p2.position.z < zCutoff) : warpPlanes.forEach((p2) => p2.visible = false);
              animate();
            }
            break;
        }
      });
    });
  });
})();
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
